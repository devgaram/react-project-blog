---
layout: post-content
title: 자바스크립트의 실행 컨텍스트
date: 2019-12-09
categories: [javascript]
---

인사이드 자바스크립트를 정리하며 작성한 포스팅입니다.     
이 포스팅은 실행 컨텍스트의 개념과 생성 과정에 대해 정리한 내용이며 실행 컨텍스트 이해를 위한 필수 개념인 스코프 체인과 this 바인딩에 대해서는 추후 정리할 예정입니다.

# 실행 컨텍스트란?


콜 스택에 쌓이는 각각의 정보들이 하나의 실행 컨텍스트라고 생각하며 아래의 문구를 읽어보자.

* ECMAScript는 **실행 가능한 코드를 형상화하고 구분하는 추상적인 개념**으로 정의한다.
* **실행 가능한 자바스크립트 코드 블록이 실행되는 환경**으로 코드 블록 안에는 변수, 객체, 실행 가능한 코드가 들어있다.
* 스택의 TOP에 위치하는 실행 컨텍스트가 **현재 실행되는 컨텍스트**다.
* 현재 실행되는 컨텍스트와 관련 없는 코드 블록이 실행되면 새로운 실행 컨텍스트가 생성되어 스택에 쌓이고 제어권이 생성된 컨텍스트로 이동한다.


그렇다면 실행 컨텍스트가 형성되는 경우는 언제일까?     
ECMAScript에서 실행 컨텍스트가 형성되는 경우를 다음과 같이 규정하고 있다.

* 전역 코드
* eval() 함수로 실행되는 코드
* **함수 안의 코드를 실행하는 경우** (대부분의 경우)



# 실행 컨텍스트 생성 과정

자바스크립트에서 함수를 실행하여 실행 컨텍스트를 생성하면 자바스크립트 엔진은 다음 순서대로 작업을 실행한다.

## 1. 활성 객체 생성

실행 컨텍스트가 생성되면 엔진은 이 컨텍스트가 접근 할 수 있는 활성 객체를 생성하며 활성 객체에 앞으로 사용할 매개변수, 사용자 정의 변수 및 객체를 저장한다.

## 2. arguments 객체 생성

2단계에서는 arguments 객체를 생성하며 앞서 만들어진 활성 객체는 이 arguments 객체를 참조한다.

잠깐 arguments 객체에 대해 알아보고 넘어가자    

```javascript
function func(arg1, arg2) {
  console.log(arg1, arg2);
}

func() // undefined undefined
func(1) // 1 undefined
func(1,2) // 1 2
func(1,2,3) // 1 2
```

자바스크립트에서는 위 예제와 같이 함수 형식에 맞춰 인자 값을 넘겨주지 않아도 에러가 발생하지 않는다. 넘겨지지 않은 인자에는 **undefined**값이 할당되고, 초과된 인수는 무시된다.

이러한 자바스크립트 특성 때문에 함수 코드를 작성할 때, 런타임 시에 호출된 인자의 개수를 확인하고 이에 따라 동작을 다르게 해줘야 할 경우가 있는 데, 이를 가능케 하는 게 바로 **arguments 객체**다. 

자바스크립트에서는 함수를 호출할 때 인수들과 함께 암묵적으로 arguments 객체가 함수 내부로 전달되며 arguments 객체에 넘긴 인자들이 배열형태로 저장된다. 단, 실제 배열이 아닌 **유사 배열 객체**다. 유사 배열 객체는 length 프로퍼티가 있어서 배열과 유사하게 동작하지만, 배열 메서드를 사용할 경우 에러가 발생한다.

만약 arguments 객체에서 배열 메서드를 사용하고 싶다면 명시적으로 this를 바인딩 하면 된다.
call과 apply 메서드를 이용하여 this를 바인딩 할 수 있고, ES6 부터는 Arrays.from() 메서드와 전개 연산자를 사용할 수 있다.

```javascript
var args = Array.prototype.slice.apply(arguments); // Array.prototype.slice() 메서드를 호출한다. 단, this는 arguments 객체로 바인딩한다.

// ES6 이후
var args = Array.from(arguments);
var args = [...arguments];
```


## 3. 스코프 정보 생성

현재 컨텍스트의 유효 범위를 나타내는 **스코프 정보**를 생성한다.    
스코프 정보는 현재 실행 중인 실행 컨텍스트 안에서 **연결 리스트**와 유사한 형식으로 만들어진다.    
현재 컨텍스트에서 특정 변수에 접근해야 할 경우, 이 리스트를 사용하며 현재 컨텍스트의 변수뿐 아니라 상위 실행 컨텍스트의 변수도 접근이 가능하다. 이 리스트에서 변수를 찾지 못하면 정의되지 않은 변수로 판단하여 에러를 검출한다. 이 때, 활성 객체는 리스트의 맨 앞에 추가된다.

스코프 체인이 어떻게 만들어지는 지는 추후에 포스팅할 예정이다.


## 4. 변수 생성

실행 컨텍스트 내부에서 사용되는 **지역 변수**의 생성이 이루어진다. 여기서 생성되는 변수는 변수 객체에 저장되며 변수 객체는 앞서 생성한 활성 객체다.

* 지역 변수나 내부 함수를 메모리에 생성하고 지역 변수에는undefined를 할당한다.
* 인자를 생성하고 값을 할당한다. 인자값이 넘겨지지 않았다면 undefined를 할당한다.
* 메모리에 생성할 뿐, **초기화**는 이루어지지 않는다.


## 5. this 바인딩

함수 호출 패턴에 따라 this는 다른 객체를 참조(바인딩)하며, this가 참조하는 객체가 없으면 전역 객체를 참조한다. this 함수 호출 패턴은 중요한 개념이므로 추후에 포스팅할 예정이다.

## 6. 코드 실행

코드 블록의 여러 가지 표현식이 실행되면서 변수의 초기화 및 연산, 또 다른 함수 실행 등이 이루어진다.

**참고**    
전역 실행 컨텍스트는 일반적인 실행 컨텍스트와 약간 다르다.    
* arguments 객체가 없다.
* 스코프 체인은 전역 객체 하나만을 포함한다.
* 전역 코드가 실행될 때 생성되는 컨텍스트다.
* 전역 실행 컨텍스트의 **변수 객체는 전역 객체(window)다.** 따라서 전역적으로 선언된 함수와 변수는 전역 객체의 프로퍼티가 된다.

```javascript
var a = 10;
console.log(window.a); // 10
```


