{"layout":"post-content","title":"mssql 쿼리 팁 - group by 없이 카운트하는 방법 & 페이징 처리를 위한 전체 레코드 갯수 구하기","date":"2019-03-07T00:00:00.000Z","tags":["mssql"],"category":["sql"],"body":"<p>프로시저 속도 개선하는 과정에서 배웠던 sql 팁으로, group by 없이 칼럼과 함께 갯수를 출력하는 방법과\n페이징 처리에 필요한 전체 레코드 갯수를 구하는 방법에 대한 내용입니다.</p>\n<hr>\n<p>관리자 페이지 유지보수 중에 한 프로시저의 실행속도가 굉장히 느린 것을 발견했다.<br>\n실무자에게 확인해 본 결과 페이지 넘길 때마다 기본 일분은 기다린다는 답을 받았다.<br>\n이 프로시저는 어떤 정보를 프로시저 내에서 페이징 처리를 하여 조회하는 쿼리로 4개의 left outer join 과 복잡한 case 조건의 where 절을 가졌다.<br>\n심지어 left join 되는 테이블은 조건과 그룹 처리를 하는 서브쿼리로 구성되었다.</p>\n<h1>Group by 없이 칼럼과 함께 갯수 출력하기</h1>\n<span class=\"clr-grey\">\n처음에는 left join 때문이라고 생각했으나 아니였다.      \n진짜 원인은 select 절에서 각 그룹의 갯수를 조회하는 서브쿼리의 문제였다.    \n이를 left outer join 으로 바꿔봤지만 해결되지 않았고 Group by 처리하자니 조회할 컬럼 값이 너무 많았다.    \n고민하다가 검색을 통해 좋은 방법을 찾았다.  \n</span>\n<pre><code class=\"language-sql\">count(yy) over (partition by xx)\n</code></pre>\n<p>위는 Group by 없이 컬럼값들과 함께 갯수를 출력할 수 있는 쿼리이다.</p>\n<pre><code class=\"language-sql\">count(seq) over (partition by groupSeq)\n</code></pre>\n<p>이를 참고해 select에서 서브쿼리로 조회하던 방식을 위와 같이 수정했더니 실행시간이 13초에서 3초 정도로 줄었다</p>\n<h1>페이징 처리에 필요한 전체 레코드 갯수를 구하는 방법</h1>\n<p><a href=\"https://m.blog.naver.com/monkeychoi/220629982940\">전체갯수구하기 참고 블로그</a></p>\n<span class=\"clr-grey\">\n하지만 아직 한국인을 만족시킬 속도가 아니였기에 속도를 잡아먹는 또 다른 원인을 찾아보았다.     \n바로 전체 레코드 갯수를 구하는 부분이었다.  페이징처리를 위해서 전체 레코드 갯수를 구하는 건 필수였기에 해당 쿼리를 빼는 거는 불가능했다.   \n</span>\n<p>기존 페이징 쿼리</p>\n<pre><code class=\"language-sql\">;<span class=\"hljs-keyword\">WITH</span> myCTE <span class=\"hljs-keyword\">AS</span>\n(\n\t<span class=\"hljs-keyword\">SELECT</span>\n\t\t<span class=\"hljs-keyword\">COUNT</span>(*) <span class=\"hljs-keyword\">OVER</span>() <span class=\"hljs-keyword\">AS</span> TOTALCNT,\t<span class=\"hljs-comment\">-- 이 쿼리때문에 느려짐</span>\n\t\tROW_NUMBER() <span class=\"hljs-keyword\">OVER</span> (<span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> GroupSeq <span class=\"hljs-keyword\">DESC</span>, seq <span class=\"hljs-keyword\">ASC</span>) <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">ROWNUM</span>,\n\t\t*\n\t<span class=\"hljs-keyword\">FROM</span> DBO.MY_BOARD\n)\n<span class=\"hljs-keyword\">SELECT</span> * <span class=\"hljs-keyword\">FROM</span> myCTE <span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-keyword\">ROWNUM</span> <span class=\"hljs-keyword\">BETWEEN</span> (@I_PAGE <span class=\"hljs-number\">-1</span>) * @I_PAGESIZE) + <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">AND</span> @I_PAGE * @I_PAGESIZE\n</code></pre>\n<p>수정 후 쿼리</p>\n<pre><code class=\"language-sql\">;<span class=\"hljs-keyword\">WITH</span> myCTE <span class=\"hljs-keyword\">AS</span>\n(\n\t<span class=\"hljs-keyword\">SELECT</span>\t\t\n\t\tROW_NUMBER() <span class=\"hljs-keyword\">OVER</span> (<span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> GroupSeq <span class=\"hljs-keyword\">DESC</span>, seq <span class=\"hljs-keyword\">ASC</span>) <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">ROWNUM</span>,\n\t\t*\n\t<span class=\"hljs-keyword\">FROM</span> DBO.MY_BOARD\n)\n<span class=\"hljs-keyword\">SELECT</span> *, (<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">COUNT</span>(*) <span class=\"hljs-keyword\">FROM</span> myCTE) <span class=\"hljs-keyword\">AS</span> TOTALCNT \n<span class=\"hljs-keyword\">FROM</span> myCTE <span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-keyword\">ROWNUM</span> <span class=\"hljs-keyword\">BETWEEN</span> (@I_PAGE <span class=\"hljs-number\">-1</span>) * @I_PAGESIZE) + <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">AND</span> @I_PAGE * @I_PAGESIZE\n</code></pre>\n<p>위와 같이 쿼리를 수정한 결과 실행시간이 3초에서 1초로 줄었다.</p>\n","updatedAt":"2020-01-22T18:24:29.837Z"}