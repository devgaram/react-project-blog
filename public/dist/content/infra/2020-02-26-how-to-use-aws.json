{"title":"AWS 연습하자 3탄 - Jenkins와 S3 버킷 & AWS codeDeploy 연동으로 배포하기","date":"2020-02-26T00:00:00.000Z","tags":["aws"],"category":"infra","body":"<blockquote>\n<p>AWS 연습하자 시리즈</p>\n<ul>\n<li><a href=\"/post/2020-02-24-how-to-use-aws\">AWS 연습하자 1탄 - AWS EC2 인스턴스에 Jenkins 서버 구축하기</a></li>\n<li><a href=\"/post/2020-02-25-how-to-use-aws\">AWS 연습하자 2탄 - Jenkins와 Github 연동</a></li>\n</ul>\n</blockquote>\n<p>AWS 연습하기 3탄에서는 AWS S3와 Aws Codedeploy로 자동 배포 환경을 구축하는 과정을 다루겠습니다.</p>\n<h1>배포 서버인 EC2 인스턴스 생성</h1>\n<p><a href=\"/post/2020-02-24-how-to-use-aws\">AWS 연습하자 1탄</a>의 AWS EC2 인스턴스 생성하기 부분을 진행하여 인스턴스를 생성하고 오세요! 저는 Name 태그에 blog-server로 인스턴스를 생성했습니다.</p>\n<h1>AWS Code Deploy 계정 생성</h1>\n<p>여기서 생성한 계정을 가지고 Jenkins와 blog-server 인스턴스에서 설정을 진행할 것입니다.</p>\n<p><strong><a href=\"https://console.aws.amazon.com/iam/\">AWS IAM 콘솔</a> -&gt; 사용자 탭 -&gt; 사용자 추가</strong> 를 클릭합니다.</p>\n<p>사용자 이름을 입력하고 액세스 유형은 프로그래밍 방식 액세스를 선택합니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/29.png\" alt=\"process tree\"></p>\n<p>해당 계정이 사용할 수 있는 정책으로는 CodeDeploy와 S3 권한을 할당 받겠습니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/30.png\" alt=\"process tree\"></p>\n<p><img src=\"/assets/images/2020-02-24-img/31.png\" alt=\"process tree\"></p>\n<p><img src=\"/assets/images/2020-02-24-img/32.png\" alt=\"process tree\"></p>\n<p>.csv 다운로드 버튼을 클릭하여 비밀키를 잘 보관해둡니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/33.png\" alt=\"process tree\"></p>\n<h1>AWS S3 버킷 생성</h1>\n<p><strong><a href=\"https://s3.console.aws.amazon.com/s3/\">AWS S3 콘솔</a> -&gt; 버킷 만들기</strong> 를 클릭합니다.</p>\n<p>버킷 이름이 blog-server-bucket으로 하고 리전이 서울인지 확인합니다. 추가 옵션 없이 다음을 계속하여 버킷 생성을 완료합니다.</p>\n<h1>IAM Role 생성</h1>\n<p>blog-server EC2와 CodeDeploy에게 신뢰할 수 있는 권한을 설정하여 젠킨스가 정상적으로 배포할 수 있게 하겠습니다.</p>\n<blockquote>\n<p>CodeDeploy가 EC2 접근할 수 있도록 설정하는 것!</p>\n</blockquote>\n<p><strong><a href=\"https://console.aws.amazon.com/iam/\">AWS IAM 콘솔</a> -&gt; 역할 -&gt; 역할 만들기</strong> 를 클릭합니다.</p>\n<p>AWS 서비스를 누른 후 이 역할을 사용할 서비스 선택에서 <strong>EC2</strong>를 선택합니다. 권한 정책으로 <strong>AmazonEC2RoleforAWSCodeDeploy</strong> 를 체크한 후 다음: 태그로 넘어갑니다. 태그는 건너 뛰고 역할 이름은 <strong>blog-server-EC2CodeDeployRole</strong>을 입력한 후 역할 만들기를 클릭하겠습니다.</p>\n<p>지금 만든 역할은 blog-server EC2에 IAM 역할로 설정할 것입니다.</p>\n<p>마찬가지로 CodeDeploy도 역할을 생성하겠습니다.</p>\n<p><strong><a href=\"https://console.aws.amazon.com/iam/\">AWS IAM 콘솔</a> -&gt; 역할 -&gt; 역할 만들기</strong> 를 클릭합니다.</p>\n<p>AWS 서비스를 누른 후 이 역할을 사용할 서비스 선택에서 <strong>CodeDeploy</strong>를 선택합니다. 사용 사례 선택 섹션에서도 <strong>CodeDeploy</strong>를 선택합니다. 권한 정책으로 <strong>AWSCodeDeployRole</strong> 를 하나이므로 그냥 확인하고 다음: 태그로 넘어갑니다. 태그는 건너 뛰고 역할 이름은 <strong>blog-server-CodeDeployServiceRole</strong>을 입력한 후 역할 만들기를 클릭하겠습니다.</p>\n<h1>EC2에 AWS 역할 적용하기</h1>\n<p>EC2 콘솔로 이동한 후 아래와 같이 IAM 역할 연결/바꾸기 를 선택합니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/34.png\" alt=\"process tree\"></p>\n<p>아까만든 <strong>blog-server-EC2CodeDeployRole</strong> 을 선택한 후 적용합니다.</p>\n<h1>EC2 AWS CodeDeploy Agent 설치 및 설정</h1>\n<p>이제 blog-server 인스턴스에 CodeDeploy Agent를 설치하겠습니다.</p>\n<p>인스턴스로 접속한 후 패키지 업데이트를 수행합니다.</p>\n<pre><code>ssh -i my-key-pair.pem ec2-user@퍼블릭DNS\nsudo yum update -y\n</code></pre>\n<p>aws cli를 설치하겠습니다.</p>\n<pre><code>sudo yum install awscli\n</code></pre>\n<p>에이전트 설치 후 aws 설정을 하겠습니다.</p>\n<pre><code>sudo aws configure\n</code></pre>\n<p>AWS Access Key ID, AWS Secret Acecess Key ID는 사용자 생성할 때 받은 CSV를 보고 입력합니다.</p>\n<p>추가 정보는 아래와 같이 입력 후 엔터칩니다.\nDefault region name: ap-northeast-2\nDefault output format: json</p>\n<p>계속 설치를 진행하겠습니다.</p>\n<pre><code>cd /home/ec2-user\n\n# agent 파일 다운로드\naws s3 cp s3://aws-codedeploy-ap-northeast-2/latest/install . --region ap-northeast-2\n\n# 실행권한 추가\nchmod +x ./install\n\n# 설치 진행\nsudo ./install auto\n\n# agent가 실행 중인지 확인 PID가 나오면 정상적으로 실행 중인 상태입니다.\nsudo service codedeploy-agent status\n</code></pre>\n<p>만약 <strong>sudo ./install auto</strong> 커맨드 실행 결과 <strong>/usr/bin/env: ruby: No such file or directory</strong>가 나온다면 루비를 설치해야합니다. 아래와 같이 실행 후 다시 설치를 진행합니다.</p>\n<pre><code>sudo yum install ruby -y\n</code></pre>\n<p>추가로 재 부팅시 자동으로 code deploy agent가 실행될 수 있도록 스크립트를 생성하고 권한을 주겠습니다.</p>\n<pre><code># 아래 스크립트를 입력합니다.\nsudo vim /etc/init.d/codedeploy-startup.sh\n\nsudo chmod +x /etc/init.d/codedeploy-startup.sh\n</code></pre>\n<blockquote>\n<p>#!/bin/bash<br>\necho ‘Starting codedeploy-agent’<br>\nsudo service codedeploy-agent restart</p>\n</blockquote>\n<h1>nginx와 Docker로 무중단 배포하기</h1>\n<h2>1) 도커, 도커컴포즈 설치 및 프로젝트 파일 생성</h2>\n<p>도커 컨테이너 위에서 애플리케이션을 구동하기위해서 ec2에 도커와 도커컴포즈를 설치합니다.</p>\n<pre><code>sudo yum install docker\n\n# 도커 컴포즈 다운로드\n$ sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.25.4/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose\n\n# 실행 권한 주기\n$ sudo chmod +x /usr/local/bin/docker-compose\n\n# 설치 완료됐는 지 확인하기\n$ docker-compose --version\n\n# bash: docker-compose: command not found 문구가 나오면 아래 커맨드 실행하기\n$ sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose\n</code></pre>\n<p>잠시 배포에 대해 짚고 넘어가겠습니다. 뒤에서 실습을 진행하겠지만, AWS Code Deploy에서 배포한 파일은 /home/ec2-user/build 에 복사되게 할 것입니다.</p>\n<p>배포 후 /home/ec2-user/build 이 폴더에는 Dockerfile 과 docker-compose.yml 파일이 존재할것이고 이를 이용해 컨테이너에 서버를 올릴 것입니다.</p>\n<p>혹시 docker ps 해봤더니 <strong>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</strong> 에러가 떴다면 docker service가 실행이 안된 것이므로 아래와 같이 명령을 내리겠습니다. <a href=\"https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user\">도커 설치 가이드</a>를 참고했습니다.</p>\n<pre><code>sudo groupadd docker\nsudo usermod -aG docker $USER\nsudo newgrp docker\n\n# 아래 커맨드 실행 결과 상태가 active여야 정상적인 것!\nsudo systemctl status docker\nsudo systemctl start docker\nsudo systemctl enable docker\n</code></pre>\n<p>이제 프로젝트에 Dockerfile과 docker-compose 파일을 작성하겠습니다.</p>\n<blockquote>\n<p>도커에 대해 기본지식이 필요합니다. 나중에 도커 관련 포스팅도 작성하겠습니다…!</p>\n</blockquote>\n<p>프로젝트 루트에 다음과 같이 Dockerfile을 작성합니다.</p>\n<pre><code># 로컬과 같은 버전\nFROM node:12.14\n\n# 도커 이미지 만든 사람\nLABEL maintainer=&quot;joingaram@gmail.com&quot;\n\n# 3000포트로 도커 데몬에 연결\nEXPOSE 3000\n\n# 작업 디렉토리 &amp; 자동으로 작업 디렉토리로 현재 위치 변경\nWORKDIR /usr/src/app\n\nCOPY package.json .\nCOPY yarn.lock .\nRUN yarn cache clean &amp; yarn install --network-timeout 100000\nCOPY . .\n\nCMD [&quot;yarn&quot;, &quot;start&quot;]\n\n</code></pre>\n<p>프로젝트 루트에 docker-compose.blue.yml 파일과 docker-compose.green.yml 파일을 생성한 후 아래와 같이 입력합니다. 포트만 3001, 3002로 다릅니다.</p>\n<p>docker-compose.blue.yml</p>\n<pre><code>version: &quot;3.7&quot;\nservices: \n  blog-server:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    volumes: \n      - .:/usr/src/app\n    ports:\n      - &quot;3001:3000&quot; \n</code></pre>\n<p>docker-compose.green.yml</p>\n<pre><code>version: &quot;3.7&quot;\nservices: \n  blog-server:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    volumes: \n      - .:/usr/src/app\n    ports:\n      - &quot;3002:3000&quot;  \n</code></pre>\n<h2>2) nginx로 로드밸런싱 설정</h2>\n<p>우선 nginx를 설치합니다. 프록시 서버로 두 개의 도커 컨테이너를 로드밸런싱하는 역할을 담당할 것입니다.</p>\n<pre><code>sudo amazon-linux-extras install nginx1\nsudo service nginx start\n\n# 잘 실행되었는지 확인\nps -ef | grep nginx\n</code></pre>\n<p>이제 <strong>nginx 설정 파일 수정</strong> 작업을 하겠습니다.</p>\n<pre><code>sudo vi /etc/nginx/nginx.conf\n</code></pre>\n<p>다음과 같이 수정한 후 저장합니다.</p>\n<pre><code># Load Balancing\nupstream blog-server {\n  least_conn;\n  server 127.0.0.1:3001 weight=5 max_fails=3 fail_timeout=10s;\n  server 127.0.0.1:3002 weight=10 max_fails=3 fail_timeout=10s;\n}\n\nserver {\n  listen 80;\n  server_name 서버 아이피; # 세미콜론 붙여주셔야 합니다.\n  location / {\n    proxy_pass http://blog-server;\n  }\n}\n</code></pre>\n<p>잘 설정했는 지 확인하고 nginx를 재시작합니다.</p>\n<pre><code>\nsudo nginx -t\nsudo service nginx restart\n</code></pre>\n<blockquote>\n<p><a href=\"https://opentutorials.org/module/384/4328\">생활코딩nginx</a></p>\n<ul>\n<li>Nginx는 4개의 로드밸런싱 메서드를 제공합니다. 그중  least_conn 은 연결이 가장 작은 서버로 요청을 보냅니다.</li>\n<li>weight=n : 업스트림 서버의 비중을 나타냅니다. 이 값을 2로 설정하면 그렇지 않은 서버에 비해 두배 더 자주 선택됩니다.</li>\n<li>max_fails=n : n으로 지정한 횟수만큼 실패가 일어나면 서버가 죽은 것으로 간주합니다.</li>\n<li>fail_timeout=n : max_fails가 지정된 상태에서 이 값이 설정만큼 서버가 응답하지 않으면 죽은 것으로 간주합니다.</li>\n</ul>\n</blockquote>\n<h1>Jenkins 배포 설정</h1>\n<p>우선 Pipeline AWS STEP과 AWS Codedeploy 플러그인을 설치해줍니다. Pipeline AWS STEP은 S3로 소스 전송할 때, AWS Codedeploy로는 S3 버킷의 코드를 인스턴스에 배포하도록 설정하겠습니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/22.png\" alt=\"process tree\"></p>\n<p><img src=\"/assets/images/2020-02-24-img/25.png\" alt=\"process tree\"></p>\n<p>각 플러그인 사용방법</p>\n<ul>\n<li><a href=\"https://github.com/jenkinsci/pipeline-aws-plugin#deployapi\">Pipeline AWS STEP</a></li>\n<li><a href=\"https://github.com/jenkinsci/aws-codedeploy-plugin\">AWS Codedeploy</a></li>\n</ul>\n<h2>1) S3 UPLOAD 작성</h2>\n<p>먼저 AWS 접근을 위한 설정을 하겠습니다.</p>\n<p><strong>젠킨스 메인 -&gt; Credentials -&gt; System -&gt; Global credentials -&gt; Add Credentials</strong> 를 차례로 클릭합니다.</p>\n<p>Kind는 AWS Credentials를 선택하고 Access key와 secret key는 위에서 생성한 csv 파일을 보고 입력합니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/23.png\" alt=\"process tree\"></p>\n<p>OK 클릭 후 클릭해보면 아래와 같이 ID를 볼수 있습니다. 파이프라인 작성 시에 사용해야하므로 저장해둡니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/24.png\" alt=\"process tree\"></p>\n<p>AWS 연습하기 2탄에서 작업했던 파이프라인을 아래와 같이 수정합니다.</p>\n<ul>\n<li>credentials에는 위에서 복사한 ID를 입력합니다.</li>\n<li>Bucket에는 아까 생성한 S3 버킷 입력을 입력합니다.</li>\n</ul>\n<pre><code>pipeline {\n   agent any\n\n   environment {\n       S3PATH = &quot;${env.JOB_NAME}&quot;\n   }\n   tools {\n      nodejs &quot;node&quot;\n   }\n\n   stages {\n      stage('Build') {\n         steps {\n            git 'https://github.com/devgaram/express-project-blog.git'\n         }\n      }\n      \n      stage('Install dependencies') {\n          steps {\n              sh 'npm install -g yarn'\n              sh 'yarn install'\n          }\n      }\n      stage('Test') {\n          steps {\n              echo 'test..'\n              // yarn test\n          }\n      }\n      stage('Upload S3') {\n          steps {\n              echo 'Upload S3'\n              withAWS(credentials: '667cec8d-baa7-497f-b2db-2d424c121a22') {\n                s3Upload(file: '.', bucket: 'blog-server-bucket', path: &quot;${S3PATH}&quot;, excludePathPattern: '**/node_modules/**, **/.git/**')\n              }\n          }\n      }\n      stage('Deploy') {\n          steps {\n              echo 'deploy'\n          }\n      }\n   }\n   post {\n        success {\n            echo 'successed'\n        }\n        failure {\n            echo 'failed'\n        }\n   }\n}\n</code></pre>\n<p><strong>Apply -&gt; 저장 -&gt; Build Now</strong> 를 클릭하면 잘 실행될 것입니다.</p>\n<h2>2) AWS CodeDeploy 설정</h2>\n<p><strong>Jenkins 메인 -&gt; blog-server 아이템 -&gt; Pipeline Syntax -&gt; Snippet Generator</strong>를 선택합니다.</p>\n<p>Snippet Generators는 파이프라인 스크립트 생성에 도움을 주는 녀석입니다. 얘를 이용해 AWS CodeDeploy를 이용한 배포를 설정하겠습니다.</p>\n<p><strong>Steps 섹션 -&gt; Sample Step - step:General Build Step 선택 -&gt; Build Step - Deploy an application to AWS CodeDeploy 선택</strong> 을 진행합니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/26.png\" alt=\"process tree\"></p>\n<ul>\n<li>AWS CodeDeploy Application Name: EC2 인스턴스 이름</li>\n<li>AWS CodeDeploy Deployment Group: CodeDeploy 그룹 명</li>\n<li>AWS CodeDeploy Deployment Config: 배포 환경, 여기선 CodeDeployDefault.OneAtATime</li>\n<li>AWS Region: AP_NORTHEAST_2</li>\n<li>S3 Bucket: S3 버킷 이름</li>\n</ul>\n<p>Use Access/Secret keys 라디오 버튼을 선택하여 csv로 저장했던 내용을 입력해줍니다.</p>\n<p>마지막으로 Generate Pipeline Script 버튼을 클릭하면 나오는 텍스트를 복사합니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/27.png\" alt=\"process tree\"></p>\n<p>최종적으로 파이프라인을 아래와 같이 구성됩니다.</p>\n<pre><code>pipeline {\n   agent any\n\n   environment {\n       S3PATH = &quot;${env.JOB_NAME}&quot;\n       AWS_SECRET_ACCESS_KEY = &quot;${env.AWS_SECRET_ACCESS_KEY}&quot;\n   }\n   tools {\n      nodejs &quot;node&quot;\n   }\n\n   stages {\n      stage('Build') {\n         steps {\n            git 'https://github.com/devgaram/express-project-blog.git'\n         }\n      }\n      \n      stage('Install dependencies') {\n          steps {\n              sh 'npm install -g yarn'\n              sh 'yarn install'\n          }\n      }\n      stage('Test') {\n          steps {\n              echo 'test..'\n              // yarn test\n          }\n      }\n      stage('Upload S3') {\n          steps {\n              echo 'Upload S3'\n              withAWS(credentials: '667cec8d-baa7-497f-b2db-2d424c121a22') {\n                s3Upload(file: '.', bucket: 'blog-server-bucket', path: &quot;${S3PATH}&quot;, excludePathPattern: '**/node_modules/**, **/.git/**')\n              }\n          }\n      }\n      stage('Deploy') {\n          steps {\n              echo 'deploy'\n              step([$class: 'AWSCodeDeployPublisher', applicationName: 'blog-server', awsAccessKey: 'AKIASDBC2NNSJWD4F76B', awsSecretKey: &quot;${AWS_SECRET_ACCESS_KEY}&quot;, credentials: 'awsAccessKey', deploymentConfig: 'CodeDeployDefault.OneAtATime', deploymentGroupAppspec: false, deploymentGroupName: 'blog-server-CodeDeploy-group', excludes: '', iamRoleArn: '', includes: '**', proxyHost: '', proxyPort: 0, region: 'ap-northeast-2', s3bucket: 'blog-server-bucket', s3prefix: '', subdirectory: '', versionFileName: '', waitForCompletion: false])\n          }\n      }\n   }\n   post {\n        success {\n            echo 'successed'\n        }\n        failure {\n            echo 'failed'\n        }\n   }\n}\n\n\n</code></pre>\n<h2>3) AWS Deploy 설정 파일</h2>\n<p>AWS CodeDeploy는 프로젝트 루트에 있는 appspec.yml를 이용하여 배포를 진행합니다. 자세한 내용은 <a href=\"https://docs.aws.amazon.com/ko_kr/codedeploy/latest/userguide/reference-appspec-file.html#appspec-reference-server\">aws 가이드</a>에서 확인하세요.</p>\n<p>프로젝트 루트에 appspec.yml 파일 생성 후 아래와 같이 입력합니다. AWS CodeDeploy가 ec2의 /home/ec2-user/build/ 위치에 S3 버킷에 있는 코드를 옮기도록 설정했습니다. 배포 후에는 <a href=\"http://execute-deploy.sh\">execute-deploy.sh</a> 작업을 통해 도커 컨테이너를 올릴 것입니다.</p>\n<pre><code>version: 0.0\nos: linux\nfiles:\n  - source:  /\n    destination: /home/ec2-user/build/\nhooks:\n  AfterInstall: # 배포 후\n    - location: execute-deploy.sh\n      timeout: 180\n</code></pre>\n<p><a href=\"http://execute-deploy.sh\">execute-deploy.sh</a></p>\n<pre><code>#!/bin/bash\ncd /home/ec2-user/build\nchmod +x ./deploy.sh\n./deploy.sh &gt; /dev/null 2&gt; /dev/null &lt; /dev/null &amp;\n</code></pre>\n<p>현재 블루 컨테이너가 돌고 있다면 그린 컨테이너를 구동한 후 블루 컨테이너를 종료합니다. 이 방법을 통해 무중단 배포를 할 수 있는 것입니다. 아래와 같이 작성합니다.</p>\n<p><a href=\"http://deploy.sh\">deploy.sh</a></p>\n<pre><code>#!/bin/bash\n\nDOCKER_APP_NAME=blog-server\n\nEXIST_BLUE=$(docker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml ps | grep Up)\n\nif [ -z &quot;$EXIST_BLUE&quot; ]; then\n\techo &quot;blue up&quot;\n\tdocker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml up -d\n\n\tsleep 10\n\n\tdocker-compose -p ${DOCKER_APP_NAME}-green -f docker-compose.green.yml down\nelse\n\techo &quot;green up&quot;\n\tdocker-compose -p ${DOCKER_APP_NAME}-green -f docker-compose.green.yml up -d\n\n\tsleep 10\n\n\tdocker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml down\nfi\n</code></pre>\n<p>자 이제 실제로 커밋 푸시하면 배포까지 완료되는 것을 볼 수 있습니다!</p>\n<p><img src=\"/assets/images/2020-02-24-img/28.png\" alt=\"process tree\"></p>\n<blockquote>\n<p>추가로 해야할 것</p>\n<ul>\n<li>S3에 왜 node_modules랑 .git도 올라가는 거지…? 분명 제외시켰는 데…</li>\n</ul>\n</blockquote>\n<p>참고</p>\n<ul>\n<li><a href=\"https://jojoldu.tistory.com/265\">기억보단 기록을</a></li>\n<li><a href=\"https://velog.io/@jeff0720/Travis-CI-AWS-CodeDeploy-Docker-%EB%A1%9C-%EB%B0%B0%ED%8F%AC-%EC%9E%90%EB%8F%99%ED%99%94-%EB%B0%8F-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EB%B0%B0%ED%8F%AC-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0-2\">https://velog.io/@jeff0720/Travis-CI-AWS-CodeDeploy-Docker-로-배포-자동화-및-무중단-배포-환경-구축하기-2</a></li>\n<li><a href=\"https://medium.com/faun/create-a-continuous-delivery-pipeline-using-jenkins-gitlab-github-and-deploy-on-aws-ec2-with-3aaadf073196\">https://medium.com/faun/create-a-continuous-delivery-pipeline-using-jenkins-gitlab-github-and-deploy-on-aws-ec2-with-3aaadf073196</a></li>\n</ul>\n","updatedAt":"2020-02-26T17:20:02.499Z"}