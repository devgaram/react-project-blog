{"title":"코딩인터뷰 완전분석 - 트리와 그래프 feat. 힙","date":"2020-01-03T00:00:00.000Z","tags":["coding-interview","data-structure"],"category":"algorithm","body":"<blockquote>\n<p>참고 서적<br/>\n<a href=\"https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545\">코딩 인터뷰 완전분석</a> 트리와 그래프<br/>\n<a href=\"http://www.yes24.com/Product/Goods/69750539\">C언어로 쉽게 풀어쓴 자료구조</a> 제 7장 트리, 제 8장 우선순위 큐</p>\n</blockquote>\n<h1>1. 트리(Tree)</h1>\n<ul>\n<li>트리는 노드(node)와 간선(edge)로 이루어진 자료구조이다.</li>\n<li>트리는 하나의 루트 노드를 가진다.</li>\n<li>루트 노드는 0개 이상의 자식 노드를 가진다.</li>\n<li>그 자식 노드 또한 0개 이상의 자식 노드를 가진다.</li>\n<li>그 자식의 자식 노드 또한…</li>\n<li>노드들은 특정 순서대로 나열될 수도 있고 없을 수도 있다.</li>\n<li>각 노드는 어떤 자료형으로도 표현이 가능하다.</li>\n<li>각 노드는 부모 노드로의 연결이 있을 수도 있고 없을 수도 있다.</li>\n</ul>\n<h2>용어 정리</h2>\n<ul>\n<li>트리에는 **사이클(cycle)**이 존재할 수 없다.</li>\n<li>자식이 없는 노드는 **말단 노드(leaf node)**라고 부른다.</li>\n<li>**차수(degree)**는 자식 노드의 개수로 자식 노드가 3개면 그 노드의 차수는 3이다. 트리의 차수는 트리가 가지고 있는 노드의 차수 중에서 가장 큰 차수이다.</li>\n<li>**레벨(level)**은 트리의 각 층에 번호를 매긴 것으로 루트의 레벨은 1이 되고 한 층씩 내려갈수록 1씩 증가한다</li>\n<li>트리의 **높이(height)**는 트리가 가진 최대 레벨이다.</li>\n</ul>\n<p>예시) 노드 클래스</p>\n<pre><code class=\"language-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Node</span> </span>{\n  <span class=\"hljs-keyword\">public</span> String name;\n  <span class=\"hljs-keyword\">public</span> Node[] children;\n}\n</code></pre>\n<p>예시) 트리 클래스</p>\n<pre><code class=\"language-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Tree</span> </span>{\n  <span class=\"hljs-keyword\">public</span> Node root;\n}\n</code></pre>\n<h2>이진 트리(Binary tree)와 이진 탐색 트리(Binary search tree)</h2>\n<ul>\n<li>이진트리\n<ul>\n<li>이진 트리의 노드는 최대 2개까지의 자식 노드가 존재할 수 있고 모든 노드의 차수는 2 이하가 된다.</li>\n<li>n개의 노드를 가진 이진 트리는 n-1개의 간선을 가진다. 루트 노드를 제외한 노드들은 부모와 정확히 하나의 간선으로 이어져있기 때문이다.</li>\n<li>높이가 h인 이진 트리는 최소 h개 노드를 가지고 최대 2<sup>h</sup>-1 노드를 가진다.</li>\n<li>레벨 i에서 노드의 개수는 2<sup>i-1</sup> 다.</li>\n<li>n개의 노드를 가진 이진 트리의 최대 높이는 n이며 최소 높이는 log<sub>2</sub>(n+1) 이다.</li>\n</ul>\n</li>\n<li>이진 탐색 트리\n<ul>\n<li>모든 노드 n은 <span class=\"clr-note\">모든 왼쪽 자식들 &lt;= n &lt; 모든 오른쪽 자식들</span> 속성을 만족한다.</li>\n<li>이진 탐색 트리의 탐색, 삽입, 삭제 연산의 시간 복잡도는 트리의 높이를 h라고 했을 때 O(h)가 된다.</li>\n<li>n개의 노드를 가진 균형 잡힌 이진 트리의 높이는 log<sub>2</sub>n 이므로 평균적인 시간 복잡도는 O(log<sub>2</sub>n)</li>\n<li>한쪽으로 치우친 이진 트리의 경우 트리의 높이가 노드의 개수 n과 같게 되어 시간복잡도는 선형 탐색과 같이 O(n)이 된다.</li>\n</ul>\n</li>\n</ul>\n<h2>이진 트리 표현 방법</h2>\n<p><strong>1. 배열 이용</strong> <br/><br/>\n<img src=\"/assets/images/2020-01-03-img/1.png\" alt=\"배열 이용\"><br/></p>\n<ul>\n<li>주로 포화 이진 트리나 완전 이진 트리의 경우에 많이 쓰인다.</li>\n<li>높이가 k인 완전 이진 트리로 가정하여 배열의 크기를 최대 노드 개수인 2<sup>k</sup>-1 로 할당한 다음 완전 이진 트리의 번호대로 노드를 저장한다.</li>\n<li>편한 계산을 위해 인덱스는 1부터 시작한다.</li>\n<li>오른쪽 그림처럼 일반 이진 트리의 경우 공간 낭비가 크다.</li>\n</ul>\n<blockquote>\n<p>부모 &amp; 자식 노드 찾는 법 <br/><br/>\n현재 노드 i를 기준으로, <br/>\n부모 노드의 인덱스 =  <strong>i/2</strong> <br/>\n왼쪽 자식 노드의 인덱스 =  <strong>i*2</strong> <br/>\n오른쪽 자식 노드의 인덱스 = <strong>i*2 + 1</strong> <br/></p>\n</blockquote>\n<br/>\n<p><strong>2. 연결리스트 이용</strong> <br/><br/></p>\n<ul>\n<li>노드가 자바에서는 클래스, C에서는 구조체로 표현되고 각 노드가 포인터를 가지고 있어서 이 포인터를 이용하여 노드와 노드를 연결하는 방법이다.</li>\n<li>하나의 노드가 왼쪽 자식 노드, 오른쪽 자식 노드를 필드로 가진다.</li>\n</ul>\n<h2>트리가 ‘균형’ 트리인지 아닌지 확인하는 방법</h2>\n<p><span class=\"clr-note\">O(log N)</span> 시간에 insert와 find를 할 수 있는 정도로 균형이 잘 잡혀있는 지 확인하면 된다. 꼭 완전 이진 트리처럼 완벽하게 균형 잡혀 있을 필요는 없다.</p>\n<blockquote>\n<p>예) 레드-블랙 트리와 AVL 트리</p>\n</blockquote>\n<h2>이진 트리의 종류</h2>\n<ul>\n<li>완전 이진 트리(complete binary tree) : 트리의 모든 높이에서 노드가 꽉 차 있다. 마지막 단계(level)은 꽉 차 있지 않아도 되지만 노드가 왼쪽에서 오른쪽으로 채워져야 한다.</li>\n<li>전 이진 트리(full binary tree) : 자식노드가 0개 또는 2개인 경우다.</li>\n<li>포화 이진 트리(perfect binary tree) : 전 이진 트리면서 완전 이진 트리인 경우다. 모든 말단 노드는 같은 레벨에 있으며 마지막 레벨에서 노드의 개수가 최대가 되어야 한다. 노드의 개수는 정확히 2<sup>k-1</sup>(k는 트리의 레벨)</li>\n</ul>\n<h2>이진 트리 순회 방법</h2>\n<p>**중위 순회(in-order traversal)**는 <span class=\"clr-note\">왼쪽 가지(branch) - 현재 노드 - 오른쪽 가지</span> 순서로 노드를 방문하고 출력하는 방법이다.</p>\n<blockquote>\n<p>이진 탐색 트리를 이 방법으로 순회한다면? <span class=\"is-has-danger\">오름차순</span>으로 방문!</p>\n</blockquote>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">inOrderTraversal</span><span class=\"hljs-params\">(TreeNode node)</span> </span>{\n  <span class=\"hljs-keyword\">if</span> (node != <span class=\"hljs-keyword\">null</span>) {\n    inOrderTraversal(node.left);\n    visit(node);\n    inOrderTraversal(node.right);\n  }\n}\n</code></pre>\n<br/>\n<p>**전위 순회(pre-order traversal)**는 <span class=\"clr-note\">현재 노드 - 왼쪽 가지(branch) - 오른쪽 가지</span> 순서로 노드를 방문하고 출력하는 방법이다.</p>\n<blockquote>\n<p>가장 먼저 방문할 노드는? 루트 노드!</p>\n</blockquote>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">preOrderTraversal</span><span class=\"hljs-params\">(TreeNode node)</span> </span>{\n  <span class=\"hljs-keyword\">if</span> (node != <span class=\"hljs-keyword\">null</span>) {\n    visit(node);\n    preOrderTraversal(node.left);    \n    preOrderTraversal(node.right);\n  }\n}\n</code></pre>\n<br/>\n<p>**후위 순회(post-order traversal)**는 <span class=\"clr-note\">왼쪽 가지(branch) - 오른쪽 가지 - 현재 노드</span> 순서로 노드를 방문하고 출력하는 방법이다. 예) 현재 디렉토리 용량 계산</p>\n<blockquote>\n<p>맨 마지막에 방문할 노드는? 루트 노드!</p>\n</blockquote>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">postOrderTraversal</span><span class=\"hljs-params\">(TreeNode node)</span> </span>{\n  <span class=\"hljs-keyword\">if</span> (node != <span class=\"hljs-keyword\">null</span>) {    \n    postOrderTraversal(node.left);    \n    postOrderTraversal(node.right);\n    visit(node);\n  }\n}\n</code></pre>\n<br/>\n<p>**레벨 순회(level traversal)**는 각 노드를 레벨 순으로 순회하는 방법이다. 레벨 1에서 시작하며 동일한 레벨의 경우에는 왼쪽에서 오른쪽으로 순으로 방문한다.</p>\n<blockquote>\n<p>중위, 전위, 후위는 스택을 사용하며 레벨 순회는 <strong>큐</strong>를 이용한다.</p>\n</blockquote>\n<h2>이진 트리 순회의 응용</h2>\n<p>**수식 트리(expression tree)**를 처리하는 데 사용\n<br/></p>\n<p><img src=\"/assets/images/2020-01-03-img/2.png\" alt=\"수식 트리 예제\"><br/></p>\n<ul>\n<li>루트 노드는 연산자이고 서브 트리가 피연산자이므로 서브 트리를 계산하면 전체 수식을 계산할 수 있다.</li>\n<li>위 표에 나와있듯이 가장 적합한 순회 방식은 <strong>후위 순회</strong>다.</li>\n</ul>\n<h1>2. 이진 힙(최소힙과 최대힙)</h1>\n<p>**우선 순위 큐(priority queue)**에서 각 노드들은 우선 순위를 가지고 있고 우선 순위가 높은 노드가 먼저 나가게 된다. 이는 배열, 연결 리스트 등 여러 가지 방법으로 구현이 가능한데, 가장 효율적인 구조는 **히프(heap)**다.</p>\n<h2>우선 순위 큐 구현 방법</h2>\n<p><strong>배열을 이용한 방법</strong></p>\n<ul>\n<li>정렬이 안 된 배열\n<ul>\n<li>삽입 : 맨 끝에 삽입 O(1)</li>\n<li>삭제 : 가장 우선 순위 높은 요소 찾기 O(n) + 삭제 후 뒤에 요소들 앞으로 이동 부담</li>\n</ul>\n</li>\n<li>정렬이 된 배열(우선 순위 낮은 순으로)\n<ul>\n<li>삽입 : 탐색을 통해 삽입 위치를 결정해야 하며, 위치를 찾은 후에는 요소를 이동시켜서 빈 공간을 만들어야 한다. O(n)</li>\n<li>삭제 : 맨 끝 요소 삭제 O(1)</li>\n</ul>\n</li>\n</ul>\n<br/>\n<p><strong>연결리스트를 이용한 방법</strong></p>\n<ul>\n<li>정렬이 안 된 리스트\n<ul>\n<li>삽입 : 첫 번째 노드로 삽입 O(1)</li>\n<li>삭제 : 포인터 따라서 모든 노드를 뒤져보아야 한다. O(n)</li>\n</ul>\n</li>\n<li>정렬이 된 리스트(우선 순위 높은 순으로)\n<ul>\n<li>삽입 : 맨 끝에 삽입해야하므로 O(n)</li>\n<li>삭제 : 맨 앞 노드 삭제 O(1)\n<br/></li>\n</ul>\n</li>\n</ul>\n<p><strong>히프를 이용한 방법</strong></p>\n<ul>\n<li>히프는 완전 이진 트리의 일종으로 우선 순위 큐를 위하여 만들어진 자료 구조이다.</li>\n<li>반 정렬 상태를 유지한다.</li>\n<li>삽입, 삭제 시간복잡도는 **O(log<sub>2</sub>n)**로 상당히 유리</li>\n</ul>\n<h2>히프란?</h2>\n<ul>\n<li>여러 개의 값들 중에서 가장 큰 값이나 가장 작은 값을 빠르게 찾아내도록 만들어진 자료구조다.</li>\n<li><strong>부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은)</strong> 이진 트리다.</li>\n<li>반 정렬 상태로, 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다는 정도다.</li>\n<li>히프 트리는 중복된 값을 허용한다.</li>\n<li>히프는 <span class=\"clr-note\">완전 이진 트리</span>다.</li>\n<li>최대 힙 : 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리</li>\n<li>최소 힙 : 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리</li>\n</ul>\n<h2>히프 구현 방법(최대 힙)</h2>\n<p>히프는 완전 이진 트리이기 때문에 표준적인 자료 구조는 배열이다. 완전 이진 트리 구현 방법은 위 트리의 표현 방법에서 이미 언급했다.</p>\n<p><strong>최대 힙 표현 방법</strong>\n<br/></p>\n<p><img src=\"/assets/images/2020-01-03-img/3.png\" alt=\"히프\"></p>\n<br/>\n<ul>\n<li>\n<p>삽입 연산</p>\n<ul>\n<li>1단계 - 히프의 끝(마지막 노드 다음)에 새로운 노드를 삽입한다. <span class=\"clr-grey\">위 그림에서 키 값이 3인 말단 노드의 형제로 삽입한다.</span></li>\n<li>2단계 - 삽입된 노드와 그 부모 노드의 키 값을 비교한다. 삽입된 노드의 키 값이 부모 노드의 키 값보다 크면 두 노드의 위치를 바꾼다.</li>\n<li>3단계 - 삽입된 노드의 키 값이 자신의 부모 노드 키 값보다 작아질 때까지 단계 2를 반복한다.</li>\n</ul>\n</li>\n<li>\n<p>삭제 연산</p>\n<ul>\n<li>1단계 - 루트 노드가 삭제 된다. 빈자리에는 히프의 마지막 노드를 가져온다.</li>\n<li>2단계 - 새로운 루트 노드를 자식 노드들과 비교해보면서 자식 노드가 더 크면 두 노드의 위치를 바꾼다. 자식 노드 두 개 모두 값이 더 크다면 더 큰 값을 가진 노드와 교환한다.</li>\n<li>3단계 - 노드의 값이 자식보다 클 때까지 2단계를 반복한다.</li>\n</ul>\n</li>\n</ul>\n<p><strong>자바스크립트 구현 코드</strong></p>\n<br/>\n<pre><code class=\"language-javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MaxHeap</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(elements) {\n    <span class=\"hljs-keyword\">this</span>.heap = [,...elements]\n  }\n\n  insert(key) {\n    <span class=\"hljs-keyword\">this</span>.heap.push(key)\n    <span class=\"hljs-keyword\">let</span> current = <span class=\"hljs-keyword\">this</span>.heap.length - <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">let</span> parent = <span class=\"hljs-built_in\">parseInt</span>(current / <span class=\"hljs-number\">2</span>)\n    <span class=\"hljs-keyword\">while</span> (parent &gt;= <span class=\"hljs-number\">1</span>) {\n      <span class=\"hljs-keyword\">if</span> (key &gt; <span class=\"hljs-keyword\">this</span>.heap[parent]) [<span class=\"hljs-keyword\">this</span>.heap[current], <span class=\"hljs-keyword\">this</span>.heap[parent]] = [<span class=\"hljs-keyword\">this</span>.heap[parent], <span class=\"hljs-keyword\">this</span>.heap[current]]\n      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">break</span>\n      current = parent\n      parent = <span class=\"hljs-built_in\">parseInt</span>(current / <span class=\"hljs-number\">2</span>)\n    }\n  }\n\n  <span class=\"hljs-keyword\">delete</span>() {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.heap.length === <span class=\"hljs-number\">1</span>) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"heap is empty\"</span>\n    }\n    [<span class=\"hljs-keyword\">this</span>.heap[<span class=\"hljs-number\">1</span>], <span class=\"hljs-keyword\">this</span>.heap[<span class=\"hljs-keyword\">this</span>.heap.length - <span class=\"hljs-number\">1</span>]] = [<span class=\"hljs-keyword\">this</span>.heap[<span class=\"hljs-keyword\">this</span>.heap.length - <span class=\"hljs-number\">1</span>], <span class=\"hljs-keyword\">this</span>.heap[<span class=\"hljs-number\">1</span>]]\n    <span class=\"hljs-keyword\">let</span> maxValue = <span class=\"hljs-keyword\">this</span>.heap.pop()\n    <span class=\"hljs-keyword\">let</span> current = <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">let</span> leftChild = current * <span class=\"hljs-number\">2</span>\n    <span class=\"hljs-keyword\">while</span> (leftChild &lt; <span class=\"hljs-keyword\">this</span>.heap.length) {\n      <span class=\"hljs-keyword\">let</span> largest = leftChild\n      <span class=\"hljs-keyword\">if</span> (leftChild + <span class=\"hljs-number\">1</span> &lt; <span class=\"hljs-keyword\">this</span>.heap.length) largest = <span class=\"hljs-keyword\">this</span>.heap[leftChild] &lt; <span class=\"hljs-keyword\">this</span>.heap[leftChild + <span class=\"hljs-number\">1</span>] ? leftChild + <span class=\"hljs-number\">1</span> : leftChild\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.heap[largest] &gt; <span class=\"hljs-keyword\">this</span>.heap[current]) [<span class=\"hljs-keyword\">this</span>.heap[largest], <span class=\"hljs-keyword\">this</span>.heap[current]] = [<span class=\"hljs-keyword\">this</span>.heap[current], <span class=\"hljs-keyword\">this</span>.heap[largest]]\n      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">break</span>\n      current = largest\n      leftChild = current * <span class=\"hljs-number\">2</span>\n    }\n\n    <span class=\"hljs-keyword\">return</span> maxValue\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> maxHeap = <span class=\"hljs-keyword\">new</span> MaxHeap([<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>])\n<span class=\"hljs-built_in\">console</span>.log(maxHeap.heap);\nmaxHeap.insert(<span class=\"hljs-number\">8</span>);\n<span class=\"hljs-built_in\">console</span>.log(maxHeap.heap);\n<span class=\"hljs-keyword\">let</span> maxValue = maxHeap.delete();\n<span class=\"hljs-built_in\">console</span>.log(maxValue);\n<span class=\"hljs-built_in\">console</span>.log(maxHeap.heap);\n\n</code></pre>\n<h2>히프의 시간 복잡도</h2>\n<ul>\n<li>삽입 연산\n<ul>\n<li>최악의 경우는 루트 노드까지 올라간 경우이므로 트리의 높이에 해당하는 비교 연산과 이동 연산이 필요하다. 히프는 완전 이진 탐색이므로 히프의 높이는 log<sub>2</sub>n이 되고 시간 복잡도도 O(log<sub>2</sub>n)</li>\n</ul>\n</li>\n<li>삭제 연산\n<ul>\n<li>삽입 연산과 같다.</li>\n</ul>\n</li>\n</ul>\n<h2>히프의 응용</h2>\n<ul>\n<li>히프 정렬\n<ul>\n<li>최대 히프를 이용하여 정렬할 수 있다.</li>\n<li>요소가 n개일 때, 시간 복잡도는 **O(nlog<sub>2</sub>n)**이다.</li>\n<li>전체 자료 정렬이 아닌 가장 큰 값 몇 개만 정렬하고 싶을 때 사용하면 좋다.</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> heapSort = <span class=\"hljs-function\">(<span class=\"hljs-params\">elements, num</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> sortedElements = []\n  <span class=\"hljs-keyword\">const</span> maxHeap = <span class=\"hljs-keyword\">new</span> MaxHeap([])\n  elements.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">element</span> =&gt;</span> {\n    maxHeap.insert(element)\n  });\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;num; i++) {\n    sortedElements.push(maxHeap.delete())\n  }\n  <span class=\"hljs-keyword\">return</span> sortedElements\n}\n\n<span class=\"hljs-built_in\">console</span>.log(heapSort([<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">8</span>], <span class=\"hljs-number\">5</span>))\n</code></pre>\n<ul>\n<li>허프만 코드 (Huffman Coding) <span class=\"clr-grey\">나중에 추가할 예정…</span></li>\n</ul>\n<h1>3. 트라이(접두사 트리, prefix tree)</h1>\n<blockquote>\n<p>참조 링크 <a href=\"https://en.wikipedia.org/wiki/Trie\">wikipedia</a></p>\n</blockquote>\n<p><img src=\"/assets/images/2020-01-03-img/4.png\" alt=\"트라이\"></p>\n<ul>\n<li>n-차 트리의 변종으로 각 노드에 문자를 저장하는 자료구조이다.</li>\n<li>문자열 탐색에 효율적인 자료구조이다.</li>\n<li>트리를 아래쪽으로 순회하면 단어 하나가 나온다.</li>\n<li>TerminatingTrieNode로 널 노드를 표현한 경우, 트라이에서 각 노드는 1개 ~ 문자열 길이 + 1개 까지 자식을 가질 수 있다.</li>\n<li>널 노드 대신 불린 플래그로 표현한 경우, 각 노드는 0개 ~ 문자열 길이개까지 자식을 가질 수 있다.</li>\n</ul>\n<blockquote>\n<p><em><em>널 노드(</em> 노드)</em>*</p>\n<ul>\n<li>단어의 끝을 나타낸다.</li>\n<li>예) MANY 이후에 널 노드가 나오면 MANY라는 단어가 완성되었다는 의미다.</li>\n</ul>\n<p><strong>널 노드 구현 방법</strong></p>\n<ul>\n<li>TrieNode를 상속한 TerminatingTrieNode로 표현하기</li>\n<li>널 노드의 부모 노드 안에 불린 플래그를 새로 정의함으로써 표현하기</li>\n</ul>\n</blockquote>\n<p><strong>어디에 사용할까?</strong></p>\n<ul>\n<li>자동 완성</li>\n<li>문자열이 어떤 문자열의 접두사인지 확인하고 싶을 때 <span class=\"clr-grey\">cf) 단순 삽입/조회만 한다면 해시테이블 사용을 권장</span></li>\n<li>예: ‘a’, 'axe’로 시작하는 단어를 찾고 싶을 때</li>\n</ul>\n<blockquote>\n<p>예시, M, MA, MAN, MANY를 차례대로 살펴보는 경우 트리의 현재 노드를 참조값으로 넘김으로써 루트 노드에서 시작할 필요가 없고 단순히 Y가 MAN의 자식인지만 확인해보면 된다.</p>\n</blockquote>\n<h2>트라이 VS 해시테이블</h2>\n<ul>\n<li>최악의 경우, 시간복잡도는?\n<ul>\n<li>트라이 : O(K) (K: 가장 긴 문자열)</li>\n<li>해시테이블 : 충돌이 자주 발생되었다면 O(N)의 시간복잡도를 가진다. (N: 키의 개수) 또한 입력 문자열을 기반으로 해시 계산을 하므로 O(K)의 시간이 걸린다.</li>\n<li>cf) 탐색할 문자열이 트라이에 없는 경우에는 문자열 길이 K보다 시간이 덜 걸린다.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>트라이와 해시의 시간복잡도가 비슷하다…?</strong> <br/>\n길이가 K인 무자열이 주어졌을 때 트라이는 O(K) 시간에 해당 문자열이 유효한 접두사인지 확인할 수 있다. 이 시간은 해시테이블 사용했을 때와 정확히 같은 수행 시간이다. 우리가 종종 해시테이블을 검색하는 시간이 O(1)이라고 하지만 완전히 맞는 말은 아니다. 해시테이블도 입력 문자열은 전부 읽어야 하므로 길이가 K인 단어를 검색하는 데 걸리는 시간은 O(K)가 된다.</p>\n</blockquote>\n<ul>\n<li>\n<p>알파벳 정렬?</p>\n<ul>\n<li>일반적으로 자료구조에 문자열을 저장한다면 각 문자열의 순서가 중요하기도 하다. 트라이는 노드를 저장할 때 왼쪽에서 오른쪽으로 사전 순으로 저장한다면 쉽게 정렬이 가능하다.</li>\n</ul>\n</li>\n<li>\n<p>기타</p>\n<ul>\n<li>트라이는 삭제가 직관적이며 해시 함수가 필요 없으나 해시 테이블 보다는 많은 공간을 차지한다.</li>\n</ul>\n</li>\n</ul>\n<h2>트라이 구현</h2>\n<pre><code class=\"language-javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Trie</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(key) {\n    <span class=\"hljs-keyword\">this</span>.is_terminal = <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-keyword\">this</span>.key = key\n    <span class=\"hljs-keyword\">this</span>.trie_child = <span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">26</span>).fill(<span class=\"hljs-literal\">null</span>)    \n  }\n\n  char_to_index(key) {\n    <span class=\"hljs-keyword\">return</span> key.charCodeAt(<span class=\"hljs-number\">0</span>) - <span class=\"hljs-string\">'a'</span>.charCodeAt(<span class=\"hljs-number\">0</span>)\n  }\n\n  <span class=\"hljs-comment\">// 새로운 문자열을 트라이에 추가</span>\n  insert (key) {\n    <span class=\"hljs-keyword\">let</span> current_trie = <span class=\"hljs-keyword\">this</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;key.length; i++) {      \n      <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-keyword\">this</span>.char_to_index(key[i])\n      <span class=\"hljs-keyword\">if</span> (current_trie.trie_child[index] === <span class=\"hljs-literal\">null</span>) current_trie.trie_child[index] = <span class=\"hljs-keyword\">new</span> Trie(key.slice(<span class=\"hljs-number\">0</span>, i+<span class=\"hljs-number\">1</span>))\n      current_trie = current_trie.trie_child[index]   \n    }\n    current_trie.is_terminal = <span class=\"hljs-literal\">true</span>\n  }\n\n  <span class=\"hljs-comment\">// 트라이 출력</span>\n  print (trie, dep) {\n    <span class=\"hljs-built_in\">console</span>.log(dep, trie.key)\n    <span class=\"hljs-keyword\">if</span> (trie.is_terminal) <span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">26</span>; i++) {\n      <span class=\"hljs-keyword\">if</span> (trie.trie_child[i] !== <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">this</span>.print(trie.trie_child[i], dep + <span class=\"hljs-number\">1</span>)\n    }\n  }\n\n  <span class=\"hljs-comment\">// key를 접두어로 가지고 있는지, 가지고 있으면 해당 접두어가 끝나는 부분의 위치를 반환</span>\n  find (key) {\n    <span class=\"hljs-keyword\">let</span> current_trie = <span class=\"hljs-keyword\">this</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;key.length; i++) {      \n      <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-keyword\">this</span>.char_to_index(key[i])\n      <span class=\"hljs-keyword\">if</span> (current_trie.trie_child[index] === <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n      <span class=\"hljs-keyword\">else</span> current_trie = current_trie.trie_child[index]   \n    }\n    <span class=\"hljs-keyword\">return</span> current_trie\n  }\n\n  <span class=\"hljs-comment\">// key를 포함하는 지, 포함하면 true</span>\n  exist (key) {\n    <span class=\"hljs-keyword\">let</span> current_trie = <span class=\"hljs-keyword\">this</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;key.length; i++) {      \n      <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-keyword\">this</span>.char_to_index(key[i])\n      <span class=\"hljs-keyword\">if</span> (current_trie.trie_child[index] === <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n      <span class=\"hljs-keyword\">else</span> current_trie = current_trie.trie_child[index]   \n    }\n    <span class=\"hljs-keyword\">return</span> current_trie.is_terminal\n  }\n  \n\n}\n\n<span class=\"hljs-keyword\">var</span> trie = <span class=\"hljs-keyword\">new</span> Trie(<span class=\"hljs-literal\">null</span>)\n<span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-string\">'to'</span>,<span class=\"hljs-string\">'tea'</span>, <span class=\"hljs-string\">'ted'</span>, <span class=\"hljs-string\">'ten'</span>, <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'inn'</span>]\narr.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">str</span> =&gt;</span> trie.insert(str))\n<span class=\"hljs-comment\">// trie.print(trie, 0)</span>\n<span class=\"hljs-built_in\">console</span>.log(trie.exist(<span class=\"hljs-string\">'tea'</span>)) <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-built_in\">console</span>.log(trie.exist(<span class=\"hljs-string\">'aaa'</span>)) <span class=\"hljs-comment\">// false</span>\n<span class=\"hljs-built_in\">console</span>.log(trie.exist(<span class=\"hljs-string\">'a'</span>)) <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-built_in\">console</span>.log(trie.find(<span class=\"hljs-string\">'te'</span>)) <span class=\"hljs-comment\">// Trie {is_terminal: false, key: \"te\", trie_child: Array(26)}</span>\n\n</code></pre>\n<h1>4. 그래프(Graph)</h1>\n","updatedAt":"2020-01-22T18:03:45.559Z"}