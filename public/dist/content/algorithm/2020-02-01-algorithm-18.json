{"layout":"post-content","title":"알고리즘 개념 잡자 6탄 - 그래프","date":"2020-02-01T00:00:00.000Z","categories":["algorithm"],"body":"<blockquote>\n<p>참고서적</p>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/69750539\">C언어로 쉽게 풀어쓴 자료구조</a></li>\n</ul>\n</blockquote>\n<br/>\n<h1>1. 그래프(graph)란</h1>\n<ul>\n<li>연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조다.</li>\n<li>정점(vertex)과 간선(edge)들의 집합으로 구성된다 =&gt; G = (V, E)</li>\n<li>정점 == 객체 == 노드, 간선 == 관계 == 노드</li>\n<li>그래프로 표현할 수 있는 것들) 도로, 영역 간 인접 관계, 선수 과목</li>\n<li>간선의 종류에 따라 무방향 그래프와 방향 그래프로 구분된다.</li>\n</ul>\n<blockquote>\n<p><strong>오일러 경로</strong></p>\n<ul>\n<li>모든 간선을 한번만 통과하면서 처음 정점으로 되돌아오는 경로다.</li>\n<li>그래프의 모든 정점에 연결된 간선의 개수가 짝수일 때만 오일러 경로가 존재한다.</li>\n</ul>\n</blockquote>\n<h1>2. 그래프 용어정리</h1>\n<ul>\n<li>가중치 그래프(네트워크) : 간선에 비용이나 가중치가 할당된 그래프</li>\n<li>차수(degree) : 정점이 가지고 있는 인접 링크의 수</li>\n<li>인접 정점(adjacent vertex) : 간선에 의해 직접 연결된 정점\n<ul>\n<li>무방향 그래프에서 정점의 차수(degree)는 인접 정점의 수다.</li>\n<li>무방향 그래프에 존재하는 정점의 모든 차수를 합하면 그래프의 간선 수의 2배가 된다.</li>\n</ul>\n</li>\n<li>방향 그래프 : 간선에 방향성이 존재하는 그래프\n<ul>\n<li>집입 차수(in-degree) : 외부에서 오는 간선 수</li>\n<li>진출 차수(out-degree) : 외부로 향하는 간선 수</li>\n<li>정점의 진입 차수와 진출 차수의 합은 방향 그래프의 간선의 수가 된다.</li>\n</ul>\n</li>\n<li>경로 길이(path length) : 경로를 구성하는 데 사용된 간선의 수\n<ul>\n<li>단순 경로(simple path) : 경로 중에서 반복되는 간선이 없는 경우</li>\n<li>사이클(cycle) : 단순 경로의 시작 정점과 종료 정점이 동일한 경우</li>\n</ul>\n</li>\n<li>연결 그래프(connected graph) : 무방향 그래프에 있는 모든 정점에 대해 항상 경로가 존재하면 그래프는 연결되어 있다고 한다.\n<ul>\n<li>그래프의 어느 두 정점을 선택해도 그 사이에 경로가 존재하면 연결 그래프다.</li>\n<li>트리는 그래프의 특수한 형태로 사이클을 가지지 않는 연결 그래프이다.</li>\n</ul>\n</li>\n<li>완전 그래프(complete graph) : 그래프에 속해 있는 모든 정점이 서로 연결되어 있는 그래프\n<ul>\n<li>무방향 완전 그래프의 정점 수가 n이면 하나의 정점은 n-1개의 다른 정점으로 연결되므로 간선의 수는 n x (n-1)/2가 된다.</li>\n</ul>\n</li>\n</ul>\n<h1>3. 그래프의 구현</h1>\n<h2>1) 인접 행렬(adjacency matrix)</h2>\n<p><img src=\"/assets/images/2020-02-23-img/1.png\" alt=\"process tree\"><br/></p>\n<ul>\n<li>2차원 배열로 표현</li>\n<li>n개의 정점을 가지는 그래프를 표현하기 위해서는 n<sup>2</sup>의 메모리 공간이 필요해서 간선이 많이 존재하는 밀집 그래프를 표현하는 경우에 적합하다.</li>\n<li>간선 수가 적은 최소 그래프의 경우에는 메모리의 낭비가 크므로 부적합하다.</li>\n<li>두 정점을 연결하는 간선의 존재 여부를 O(1) 시간 안에 알 수 있다.</li>\n<li>정점의 차수는 인접 행렬의 행이나 열을 조사하면 알 수 있으므로 O(n)의 연산에 알 수 있다.</li>\n<li>정점 i에 대한 차수는 인접 행렬의 i번째 행에 있는 값을 모두 더하면 된다.</li>\n<li>그래프에 존재하는 모든 간선의 수를 알아내려면 인접 행렬 전체를 조사해야하므로 O(n<sup>2</sup>)의 시간이 요구된다.</li>\n</ul>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-keyword\">int</span> n, m; <span class=\"hljs-comment\">// n: 정점개수, m: 간선 개수</span>\n  <span class=\"hljs-keyword\">int</span> v1, v2, d, c; <span class=\"hljs-comment\">// v1: 정점1, v2: 정점2, d: 0(무방향) 1(v1-&gt;v2), c: 간선 가중치 (1이상)</span>\n  <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d %d\"</span>, &amp;n, &amp;m);\n  \n  <span class=\"hljs-keyword\">int</span> graph[n+<span class=\"hljs-number\">1</span>][n+<span class=\"hljs-number\">1</span>] = {<span class=\"hljs-number\">0</span>}; <span class=\"hljs-comment\">// 0으로 초기화</span>\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;m+<span class=\"hljs-number\">1</span>; i++) {\n    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d %d %d %d\"</span>, &amp;v1, &amp;v2, &amp;d, &amp;c);\n    <span class=\"hljs-keyword\">if</span> (d == <span class=\"hljs-number\">0</span>) {\n      graph[v1][v2] = graph[v2][v1] = c;\n    } <span class=\"hljs-keyword\">else</span> {\n      graph[v1][v2] = c;\n    }\n  }\n  \n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n<h2>2) 인접 리스트(adjacency list)</h2>\n<p><img src=\"/assets/images/2020-02-23-img/2.png\" alt=\"process tree\"><br/></p>\n<ul>\n<li>각 정점에 인접한 정점들을 연결리스트로 표현</li>\n<li>각 연결 리스트들은 헤드 포인터를 가지고 있고 이 헤드 포인터들은 하나의 배열로 구성되어 있어 정점의 번호만 알면 이 번호를 배열의 인덱스로 하여 각 정점의 연결리스트에 쉽게 접근할 수 있다.</li>\n<li>정점의 수가 n개고 간선의 수가 e개인 무방향 그래프를 표시하기 위해서는 n개의 연결 리스트가 필요하고 n개의 헤드 포인터와 2e개의 노드가 필요하다.</li>\n<li>간선의 개수가 적은 희소 그래프의 표현에 적합하다.</li>\n<li>간선의 존재 여부나 정점 i의 차수를 알기 위해서는 정점 i의 연결리스트를 탐색해야 하므로 연결리스트에 있는 노드의 수만큼(정점 차수만큼)의 시간이 필요하다.</li>\n<li>n개의 정점, e개의 간선을 가진 그래프의 전체 간선 수를 알아내려면 O(n+e)의 연산이 요구된다.</li>\n</ul>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;vector&gt;</span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-keyword\">int</span> n, m;\n  <span class=\"hljs-keyword\">int</span> v1, v2, d, c;\n  <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d %d\"</span>, &amp;n, &amp;m);\n\n  <span class=\"hljs-built_in\">vector</span>&lt;pair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt; &gt; graph[n+<span class=\"hljs-number\">1</span>];\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;m+<span class=\"hljs-number\">1</span>; i++) {\n    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d %d %d %d\"</span>, &amp;v1, &amp;v2, &amp;d, &amp;c);\n    <span class=\"hljs-keyword\">if</span> (d == <span class=\"hljs-number\">0</span>) { <span class=\"hljs-comment\">// 무방향</span>\n      graph[v1].push_back(make_pair(v2, c));\n      graph[v2].push_back(make_pair(v1, c));\n    } <span class=\"hljs-keyword\">else</span> {\n      graph[v1].push_back(make_pair(v2, c));\n    }\n  }\n}\n</code></pre>\n<h1>4. 그래프 탐색</h1>\n<ul>\n<li>그래프에서 모든 노드를 방문하고 싶다면?\n<ul>\n<li>DFS, BFS 중 아무거나 사용해도 상관없으나 DFS가 좀 더 간단하긴 하다.</li>\n</ul>\n</li>\n<li>두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶다면?\n<ul>\n<li>BFS가 일반적으로 더 낫다.</li>\n<li>DFS는 경로를 찾을 수는 있겠지만 모든 노드를 탐색해야할지도 모르고 최단 경로가 아닐 수도 있다.</li>\n</ul>\n</li>\n</ul>\n<h2>1) 깊이 우선 탐색(DFS)</h2>\n<blockquote>\n<p>미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 가다가 더 이상 갈 수 없게 되면 가장 가까운 갈림길로 돌아와서 다른 방향으로 다시 탐색을 진행하는 방법과 유사하다.</p>\n</blockquote>\n<ul>\n<li>순환 호출이나 명시적 스택을 사용한다.</li>\n<li>전위 순회를 포함한 다른 형태의 트리 순회는 모두 DFS의 한 종류다.</li>\n<li>그래프 탐색의 경우는 어떤 노드를 방문했었는지 여부를 반드시 검사해야한다. 이를 검사하지 않으면 무한 루프에 빠질 위험이 있다.</li>\n<li>정점의 수가 n, 간선의 수가 e인 그래프를 깊이 우선 탐색하는 시간은? (힌트 : 모든 간선을 조사한다.)\n<ul>\n<li>인접리스트 : O(n+e)</li>\n<li>인접행렬 : O(n<sup>2</sup>)</li>\n</ul>\n</li>\n</ul>\n<p><strong>인접 행렬로 표현된 무방향 그래프 DFS</strong></p>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> MAX_V 20; <span class=\"hljs-comment\">// 정점 최대 값</span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-keyword\">int</span> n; <span class=\"hljs-comment\">// 입력받은 정점의 수</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> graph[][MAX_V], <span class=\"hljs-keyword\">int</span> visited[], <span class=\"hljs-keyword\">int</span> v)</span> </span>{  \n  visited[v] = <span class=\"hljs-literal\">true</span>;\n  <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d\"</span>, v);\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;n+<span class=\"hljs-number\">1</span>; i++) {\n    <span class=\"hljs-keyword\">if</span> (graph[v][i] == <span class=\"hljs-number\">1</span> &amp;&amp; !visited[i]) dfs(graph, visited, i);\n  }\n}\n</code></pre>\n<h2>2) 너비 우선 탐색(BFS)</h2>\n<ul>\n<li>큐를 사용한다.</li>\n<li>시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.</li>\n</ul>\n<p><strong>인접 행렬로 표현된 무방향 그래프 BFS</strong></p>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;queue&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> MAX_V 20; <span class=\"hljs-comment\">// 정점 최대 값</span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-keyword\">int</span> n; <span class=\"hljs-comment\">// 입력받은 정점의 수</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> graph[][MAX_V], <span class=\"hljs-keyword\">int</span> visited[], <span class=\"hljs-keyword\">int</span> v)</span> </span>{  \n  visited[v] = <span class=\"hljs-literal\">true</span>;\n  <span class=\"hljs-built_in\">queue</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; q;\n  q.push(v);\n\n  <span class=\"hljs-keyword\">while</span>(!q.empty()) {\n    <span class=\"hljs-keyword\">int</span> top = q.front();\n    q.pop();\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d\"</span>, top);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;n+<span class=\"hljs-number\">1</span>; i++) {\n      <span class=\"hljs-keyword\">if</span> (graph[v][i] == <span class=\"hljs-number\">1</span> &amp;&amp; !visited[i]) {\n        q.push(i);\n        visited[i] = <span class=\"hljs-literal\">true</span>;\n      }\n    }\n  }\n  \n}\n\n</code></pre>\n<h2>3) 양방향 탐색</h2>\n<ul>\n<li>출발지와 도착지 사이에 최단 경로를 찾을 때 사용한다.</li>\n<li>출발지, 도착지 두 노드에서 동시에 너비 우선 탐색을 수행한 뒤, 두 탐색 지점이 충돌하는 경우에 경로를 찾는 방법이다.</li>\n<li>두 탐색 알고리즘이 대략 d/2 단계(s와 t 사이의 중간 지점)에서 충돌하여 각 출발지와 도착지 노드의 방문 노드의 개수는 대략 k<sup>d/2</sup>가 된다. (k : 각 노드의 인접 노드의 개수)</li>\n</ul>\n","updatedAt":"2020-02-23T14:47:05.891Z"}