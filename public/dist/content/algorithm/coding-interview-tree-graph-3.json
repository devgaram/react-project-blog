{"title":"알고리즘 개념 잡자 4탄 - 트라이","date":"2020-01-03T00:00:00.000Z","tags":["coding-interview","data-structure"],"category":"algorithm","body":"<blockquote>\n<p>참고 서적<br/>\n<a href=\"https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545\">코딩 인터뷰 완전분석</a> 트리와 그래프<br/>\n<a href=\"http://www.yes24.com/Product/Goods/69750539\">C언어로 쉽게 풀어쓴 자료구조</a> 제 7장 트리, 제 8장 우선순위 큐</p>\n</blockquote>\n<h1>3. 트라이(접두사 트리, prefix tree)</h1>\n<blockquote>\n<p>참조 링크 <a href=\"https://en.wikipedia.org/wiki/Trie\">wikipedia</a></p>\n</blockquote>\n<p><img src=\"/assets/images/2020-01-03-img/4.png\" alt=\"트라이\"></p>\n<ul>\n<li>n-차 트리의 변종으로 각 노드에 문자를 저장하는 자료구조이다.</li>\n<li>문자열 탐색에 효율적인 자료구조이다.</li>\n<li>트리를 아래쪽으로 순회하면 단어 하나가 나온다.</li>\n<li>TerminatingTrieNode로 널 노드를 표현한 경우, 트라이에서 각 노드는 1개 ~ 문자열 길이 + 1개 까지 자식을 가질 수 있다.</li>\n<li>널 노드 대신 불린 플래그로 표현한 경우, 각 노드는 0개 ~ 문자열 길이개까지 자식을 가질 수 있다.</li>\n</ul>\n<blockquote>\n<p><em><em>널 노드(</em> 노드)</em>*</p>\n<ul>\n<li>단어의 끝을 나타낸다.</li>\n<li>예) MANY 이후에 널 노드가 나오면 MANY라는 단어가 완성되었다는 의미다.</li>\n</ul>\n<p><strong>널 노드 구현 방법</strong></p>\n<ul>\n<li>TrieNode를 상속한 TerminatingTrieNode로 표현하기</li>\n<li>널 노드의 부모 노드 안에 불린 플래그를 새로 정의함으로써 표현하기</li>\n</ul>\n</blockquote>\n<p><strong>어디에 사용할까?</strong></p>\n<ul>\n<li>자동 완성</li>\n<li>문자열이 어떤 문자열의 접두사인지 확인하고 싶을 때 <span class=\"clr-grey\">cf) 단순 삽입/조회만 한다면 해시테이블 사용을 권장</span></li>\n<li>예: ‘a’, 'axe’로 시작하는 단어를 찾고 싶을 때</li>\n</ul>\n<blockquote>\n<p>예시, M, MA, MAN, MANY를 차례대로 살펴보는 경우 트리의 현재 노드를 참조값으로 넘김으로써 루트 노드에서 시작할 필요가 없고 단순히 Y가 MAN의 자식인지만 확인해보면 된다.</p>\n</blockquote>\n<h2>트라이 VS 해시테이블</h2>\n<ul>\n<li>최악의 경우, 시간복잡도는?\n<ul>\n<li>트라이 : O(K) (K: 가장 긴 문자열)</li>\n<li>해시테이블 : 충돌이 자주 발생되었다면 O(N)의 시간복잡도를 가진다. (N: 키의 개수) 또한 입력 문자열을 기반으로 해시 계산을 하므로 O(K)의 시간이 걸린다.</li>\n<li>cf) 탐색할 문자열이 트라이에 없는 경우에는 문자열 길이 K보다 시간이 덜 걸린다.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>트라이와 해시의 시간복잡도가 비슷하다…?</strong> <br/>\n길이가 K인 무자열이 주어졌을 때 트라이는 O(K) 시간에 해당 문자열이 유효한 접두사인지 확인할 수 있다. 이 시간은 해시테이블 사용했을 때와 정확히 같은 수행 시간이다. 우리가 종종 해시테이블을 검색하는 시간이 O(1)이라고 하지만 완전히 맞는 말은 아니다. 해시테이블도 입력 문자열은 전부 읽어야 하므로 길이가 K인 단어를 검색하는 데 걸리는 시간은 O(K)가 된다.</p>\n</blockquote>\n<ul>\n<li>\n<p>알파벳 정렬?</p>\n<ul>\n<li>일반적으로 자료구조에 문자열을 저장한다면 각 문자열의 순서가 중요하기도 하다. 트라이는 노드를 저장할 때 왼쪽에서 오른쪽으로 사전 순으로 저장한다면 쉽게 정렬이 가능하다.</li>\n</ul>\n</li>\n<li>\n<p>기타</p>\n<ul>\n<li>트라이는 삭제가 직관적이며 해시 함수가 필요 없으나 해시 테이블 보다는 많은 공간을 차지한다.</li>\n</ul>\n</li>\n</ul>\n<h2>트라이 구현</h2>\n<pre><code class=\"language-javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Trie</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(key) {\n    <span class=\"hljs-keyword\">this</span>.is_terminal = <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-keyword\">this</span>.key = key\n    <span class=\"hljs-keyword\">this</span>.trie_child = <span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">26</span>).fill(<span class=\"hljs-literal\">null</span>)    \n  }\n\n  char_to_index(key) {\n    <span class=\"hljs-keyword\">return</span> key.charCodeAt(<span class=\"hljs-number\">0</span>) - <span class=\"hljs-string\">'a'</span>.charCodeAt(<span class=\"hljs-number\">0</span>)\n  }\n\n  <span class=\"hljs-comment\">// 새로운 문자열을 트라이에 추가</span>\n  insert (key) {\n    <span class=\"hljs-keyword\">let</span> current_trie = <span class=\"hljs-keyword\">this</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;key.length; i++) {      \n      <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-keyword\">this</span>.char_to_index(key[i])\n      <span class=\"hljs-keyword\">if</span> (current_trie.trie_child[index] === <span class=\"hljs-literal\">null</span>) current_trie.trie_child[index] = <span class=\"hljs-keyword\">new</span> Trie(key.slice(<span class=\"hljs-number\">0</span>, i+<span class=\"hljs-number\">1</span>))\n      current_trie = current_trie.trie_child[index]   \n    }\n    current_trie.is_terminal = <span class=\"hljs-literal\">true</span>\n  }\n\n  <span class=\"hljs-comment\">// 트라이 출력</span>\n  print (trie, dep) {\n    <span class=\"hljs-built_in\">console</span>.log(dep, trie.key)\n    <span class=\"hljs-keyword\">if</span> (trie.is_terminal) <span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">26</span>; i++) {\n      <span class=\"hljs-keyword\">if</span> (trie.trie_child[i] !== <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">this</span>.print(trie.trie_child[i], dep + <span class=\"hljs-number\">1</span>)\n    }\n  }\n\n  <span class=\"hljs-comment\">// key를 접두어로 가지고 있는지, 가지고 있으면 해당 접두어가 끝나는 부분의 위치를 반환</span>\n  find (key) {\n    <span class=\"hljs-keyword\">let</span> current_trie = <span class=\"hljs-keyword\">this</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;key.length; i++) {      \n      <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-keyword\">this</span>.char_to_index(key[i])\n      <span class=\"hljs-keyword\">if</span> (current_trie.trie_child[index] === <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n      <span class=\"hljs-keyword\">else</span> current_trie = current_trie.trie_child[index]   \n    }\n    <span class=\"hljs-keyword\">return</span> current_trie\n  }\n\n  <span class=\"hljs-comment\">// key를 포함하는 지, 포함하면 true</span>\n  exist (key) {\n    <span class=\"hljs-keyword\">let</span> current_trie = <span class=\"hljs-keyword\">this</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;key.length; i++) {      \n      <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-keyword\">this</span>.char_to_index(key[i])\n      <span class=\"hljs-keyword\">if</span> (current_trie.trie_child[index] === <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n      <span class=\"hljs-keyword\">else</span> current_trie = current_trie.trie_child[index]   \n    }\n    <span class=\"hljs-keyword\">return</span> current_trie.is_terminal\n  }\n  \n\n}\n\n<span class=\"hljs-keyword\">var</span> trie = <span class=\"hljs-keyword\">new</span> Trie(<span class=\"hljs-literal\">null</span>)\n<span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-string\">'to'</span>,<span class=\"hljs-string\">'tea'</span>, <span class=\"hljs-string\">'ted'</span>, <span class=\"hljs-string\">'ten'</span>, <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'inn'</span>]\narr.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">str</span> =&gt;</span> trie.insert(str))\n<span class=\"hljs-comment\">// trie.print(trie, 0)</span>\n<span class=\"hljs-built_in\">console</span>.log(trie.exist(<span class=\"hljs-string\">'tea'</span>)) <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-built_in\">console</span>.log(trie.exist(<span class=\"hljs-string\">'aaa'</span>)) <span class=\"hljs-comment\">// false</span>\n<span class=\"hljs-built_in\">console</span>.log(trie.exist(<span class=\"hljs-string\">'a'</span>)) <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-built_in\">console</span>.log(trie.find(<span class=\"hljs-string\">'te'</span>)) <span class=\"hljs-comment\">// Trie {is_terminal: false, key: \"te\", trie_child: Array(26)}</span>\n\n</code></pre>\n","updatedAt":"2020-02-23T12:41:23.122Z"}