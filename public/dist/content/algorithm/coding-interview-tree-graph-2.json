{"title":"알고리즘 개념 잡자 3탄 - 이진힙","date":"2020-01-03T00:00:00.000Z","tags":["coding-interview","data-structure"],"category":"algorithm","body":"<blockquote>\n<p>참고 서적<br/>\n<a href=\"https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545\">코딩 인터뷰 완전분석</a> 트리와 그래프<br/>\n<a href=\"http://www.yes24.com/Product/Goods/69750539\">C언어로 쉽게 풀어쓴 자료구조</a> 제 7장 트리, 제 8장 우선순위 큐</p>\n</blockquote>\n<h1>1. 이진 힙(최소힙과 최대힙)</h1>\n<p>**우선 순위 큐(priority queue)**에서 각 노드들은 우선 순위를 가지고 있고 우선 순위가 높은 노드가 먼저 나가게 된다. 이는 배열, 연결 리스트 등 여러 가지 방법으로 구현이 가능한데, 가장 효율적인 구조는 **히프(heap)**다.</p>\n<h2>우선 순위 큐 구현 방법</h2>\n<p><strong>배열을 이용한 방법</strong></p>\n<ul>\n<li>정렬이 안 된 배열\n<ul>\n<li>삽입 : 맨 끝에 삽입 O(1)</li>\n<li>삭제 : 가장 우선 순위 높은 요소 찾기 O(n) + 삭제 후 뒤에 요소들 앞으로 이동 부담</li>\n</ul>\n</li>\n<li>정렬이 된 배열(우선 순위 낮은 순으로)\n<ul>\n<li>삽입 : 탐색을 통해 삽입 위치를 결정해야 하며, 위치를 찾은 후에는 요소를 이동시켜서 빈 공간을 만들어야 한다. O(n)</li>\n<li>삭제 : 맨 끝 요소 삭제 O(1)</li>\n</ul>\n</li>\n</ul>\n<br/>\n<p><strong>연결리스트를 이용한 방법</strong></p>\n<ul>\n<li>정렬이 안 된 리스트\n<ul>\n<li>삽입 : 첫 번째 노드로 삽입 O(1)</li>\n<li>삭제 : 포인터 따라서 모든 노드를 뒤져보아야 한다. O(n)</li>\n</ul>\n</li>\n<li>정렬이 된 리스트(우선 순위 높은 순으로)\n<ul>\n<li>삽입 : 맨 끝에 삽입해야하므로 O(n)</li>\n<li>삭제 : 맨 앞 노드 삭제 O(1)\n<br/></li>\n</ul>\n</li>\n</ul>\n<p><strong>히프를 이용한 방법</strong></p>\n<ul>\n<li>히프는 완전 이진 트리의 일종으로 우선 순위 큐를 위하여 만들어진 자료 구조이다.</li>\n<li>반 정렬 상태를 유지한다.</li>\n<li>삽입, 삭제 시간복잡도는 **O(log<sub>2</sub>n)**로 상당히 유리</li>\n</ul>\n<h2>히프란?</h2>\n<ul>\n<li>여러 개의 값들 중에서 가장 큰 값이나 가장 작은 값을 빠르게 찾아내도록 만들어진 자료구조다.</li>\n<li><strong>부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은)</strong> 이진 트리다.</li>\n<li>반 정렬 상태로, 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다는 정도다.</li>\n<li>히프 트리는 중복된 값을 허용한다.</li>\n<li>히프는 <span class=\"clr-note\">완전 이진 트리</span>다.</li>\n<li>최대 힙 : 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리</li>\n<li>최소 힙 : 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리</li>\n</ul>\n<h2>히프 구현 방법(최대 힙)</h2>\n<p>히프는 완전 이진 트리이기 때문에 표준적인 자료 구조는 배열이다. 완전 이진 트리 구현 방법은 위 트리의 표현 방법에서 이미 언급했다.</p>\n<p><strong>최대 힙 표현 방법</strong>\n<br/></p>\n<p><img src=\"/assets/images/2020-01-03-img/3.png\" alt=\"히프\"></p>\n<br/>\n<ul>\n<li>\n<p>삽입 연산</p>\n<ul>\n<li>1단계 - 히프의 끝(마지막 노드 다음)에 새로운 노드를 삽입한다. <span class=\"clr-grey\">위 그림에서 키 값이 3인 말단 노드의 형제로 삽입한다.</span></li>\n<li>2단계 - 삽입된 노드와 그 부모 노드의 키 값을 비교한다. 삽입된 노드의 키 값이 부모 노드의 키 값보다 크면 두 노드의 위치를 바꾼다.</li>\n<li>3단계 - 삽입된 노드의 키 값이 자신의 부모 노드 키 값보다 작아질 때까지 단계 2를 반복한다.</li>\n</ul>\n</li>\n<li>\n<p>삭제 연산</p>\n<ul>\n<li>1단계 - 루트 노드가 삭제 된다. 빈자리에는 히프의 마지막 노드를 가져온다.</li>\n<li>2단계 - 새로운 루트 노드를 자식 노드들과 비교해보면서 자식 노드가 더 크면 두 노드의 위치를 바꾼다. 자식 노드 두 개 모두 값이 더 크다면 더 큰 값을 가진 노드와 교환한다.</li>\n<li>3단계 - 노드의 값이 자식보다 클 때까지 2단계를 반복한다.</li>\n</ul>\n</li>\n</ul>\n<p><strong>자바스크립트 구현 코드</strong></p>\n<br/>\n<pre><code class=\"language-javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MaxHeap</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(elements) {\n    <span class=\"hljs-keyword\">this</span>.heap = [,...elements]\n  }\n\n  insert(key) {\n    <span class=\"hljs-keyword\">this</span>.heap.push(key)\n    <span class=\"hljs-keyword\">let</span> current = <span class=\"hljs-keyword\">this</span>.heap.length - <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">let</span> parent = <span class=\"hljs-built_in\">parseInt</span>(current / <span class=\"hljs-number\">2</span>)\n    <span class=\"hljs-keyword\">while</span> (parent &gt;= <span class=\"hljs-number\">1</span>) {\n      <span class=\"hljs-keyword\">if</span> (key &gt; <span class=\"hljs-keyword\">this</span>.heap[parent]) [<span class=\"hljs-keyword\">this</span>.heap[current], <span class=\"hljs-keyword\">this</span>.heap[parent]] = [<span class=\"hljs-keyword\">this</span>.heap[parent], <span class=\"hljs-keyword\">this</span>.heap[current]]\n      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">break</span>\n      current = parent\n      parent = <span class=\"hljs-built_in\">parseInt</span>(current / <span class=\"hljs-number\">2</span>)\n    }\n  }\n\n  <span class=\"hljs-keyword\">delete</span>() {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.heap.length === <span class=\"hljs-number\">1</span>) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"heap is empty\"</span>\n    }\n    [<span class=\"hljs-keyword\">this</span>.heap[<span class=\"hljs-number\">1</span>], <span class=\"hljs-keyword\">this</span>.heap[<span class=\"hljs-keyword\">this</span>.heap.length - <span class=\"hljs-number\">1</span>]] = [<span class=\"hljs-keyword\">this</span>.heap[<span class=\"hljs-keyword\">this</span>.heap.length - <span class=\"hljs-number\">1</span>], <span class=\"hljs-keyword\">this</span>.heap[<span class=\"hljs-number\">1</span>]]\n    <span class=\"hljs-keyword\">let</span> maxValue = <span class=\"hljs-keyword\">this</span>.heap.pop()\n    <span class=\"hljs-keyword\">let</span> current = <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">let</span> leftChild = current * <span class=\"hljs-number\">2</span>\n    <span class=\"hljs-keyword\">while</span> (leftChild &lt; <span class=\"hljs-keyword\">this</span>.heap.length) {\n      <span class=\"hljs-keyword\">let</span> largest = leftChild\n      <span class=\"hljs-keyword\">if</span> (leftChild + <span class=\"hljs-number\">1</span> &lt; <span class=\"hljs-keyword\">this</span>.heap.length) largest = <span class=\"hljs-keyword\">this</span>.heap[leftChild] &lt; <span class=\"hljs-keyword\">this</span>.heap[leftChild + <span class=\"hljs-number\">1</span>] ? leftChild + <span class=\"hljs-number\">1</span> : leftChild\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.heap[largest] &gt; <span class=\"hljs-keyword\">this</span>.heap[current]) [<span class=\"hljs-keyword\">this</span>.heap[largest], <span class=\"hljs-keyword\">this</span>.heap[current]] = [<span class=\"hljs-keyword\">this</span>.heap[current], <span class=\"hljs-keyword\">this</span>.heap[largest]]\n      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">break</span>\n      current = largest\n      leftChild = current * <span class=\"hljs-number\">2</span>\n    }\n\n    <span class=\"hljs-keyword\">return</span> maxValue\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> maxHeap = <span class=\"hljs-keyword\">new</span> MaxHeap([<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>])\n<span class=\"hljs-built_in\">console</span>.log(maxHeap.heap);\nmaxHeap.insert(<span class=\"hljs-number\">8</span>);\n<span class=\"hljs-built_in\">console</span>.log(maxHeap.heap);\n<span class=\"hljs-keyword\">let</span> maxValue = maxHeap.delete();\n<span class=\"hljs-built_in\">console</span>.log(maxValue);\n<span class=\"hljs-built_in\">console</span>.log(maxHeap.heap);\n\n</code></pre>\n<h2>히프의 시간 복잡도</h2>\n<ul>\n<li>삽입 연산\n<ul>\n<li>최악의 경우는 루트 노드까지 올라간 경우이므로 트리의 높이에 해당하는 비교 연산과 이동 연산이 필요하다. 히프는 완전 이진 탐색이므로 히프의 높이는 log<sub>2</sub>n이 되고 시간 복잡도도 O(log<sub>2</sub>n)</li>\n</ul>\n</li>\n<li>삭제 연산\n<ul>\n<li>삽입 연산과 같다.</li>\n</ul>\n</li>\n</ul>\n<h2>히프의 응용</h2>\n<ul>\n<li>히프 정렬\n<ul>\n<li>최대 히프를 이용하여 정렬할 수 있다.</li>\n<li>요소가 n개일 때, 시간 복잡도는 **O(nlog<sub>2</sub>n)**이다.</li>\n<li>전체 자료 정렬이 아닌 가장 큰 값 몇 개만 정렬하고 싶을 때 사용하면 좋다.</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> heapSort = <span class=\"hljs-function\">(<span class=\"hljs-params\">elements, num</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> sortedElements = []\n  <span class=\"hljs-keyword\">const</span> maxHeap = <span class=\"hljs-keyword\">new</span> MaxHeap([])\n  elements.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">element</span> =&gt;</span> {\n    maxHeap.insert(element)\n  });\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;num; i++) {\n    sortedElements.push(maxHeap.delete())\n  }\n  <span class=\"hljs-keyword\">return</span> sortedElements\n}\n\n<span class=\"hljs-built_in\">console</span>.log(heapSort([<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">8</span>], <span class=\"hljs-number\">5</span>))\n</code></pre>\n<ul>\n<li>허프만 코드 (Huffman Coding) <span class=\"clr-grey\">나중에 추가할 예정…</span></li>\n</ul>\n","updatedAt":"2020-02-23T12:41:54.189Z"}