{"title":"Koa 가이드","date":"2020-01-04T00:00:00.000Z","tags":"koa","category":"nodejs","body":"<blockquote>\n<p>원본 <a href=\"https://github.com/koajs/koa/blob/master/docs/guide.md\">Koa user guide</a></p>\n</blockquote>\n<hr>\n<h1>가이드</h1>\n<p>이 가이드는 미들웨어 사용법과 애플리케이션 구조에 대해서 다룬다.\n예제의 미들웨어에서는 async 함수를 사용한다. 물론 commonFunction 또는 generatorFunction을 사용할 수도 있다.</p>\n<h2>목차</h2>\n<ul>\n<li><a href=\"#%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4-%EC%82%AC%EC%9A%A9%EB%B2%95\">미들웨어 사용법</a></li>\n<li><a href=\"#%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4-%ED%91%9C%EC%A4%80-%EC%82%AC%EC%9A%A9%EB%B2%95\">미들웨어 표준 사용법</a>\n<ul>\n<li><a href=\"#%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4-%EC%98%B5%EC%85%98%EB%93%A4\">미들웨어 옵션들</a></li>\n<li><a href=\"#%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4-%EC%9D%B4%EB%A6%84-%EC%A7%80%EC%A0%95\">미들웨어 이름 지정</a></li>\n<li><a href=\"#koa-compose%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4-%EC%A1%B0%ED%95%A9%ED%95%98%EA%B8%B0\">koa-compose를 통해 다양한 미들웨어 조합하기</a></li>\n<li><a href=\"#%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4-Response\">미들웨어 Response</a></li>\n</ul>\n</li>\n<li><a href=\"#async-operations\">Async operations</a></li>\n<li><a href=\"#debugging-koa\">Debugging Koa</a></li>\n</ul>\n<h1>미들웨어 사용법</h1>\n<p>Koa 미들웨어는 (ctx, next) 같은 파라미터를 가진 <code>MiddlewareFunction</code> 반환하는 간단한 함수다. 미들웨어가 동작할 때, 반드시 <code>next()</code> 를 통해 다음 미들웨어로 갈 수 있다.</p>\n<p>만약 Koa를 통해 전파되는 request 소요 시간을 추적하고 싶다면 다음과 같이 <code>X-Response-Time</code>  헤더에 시간을 셋팅하면 된다.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">responseTime</span>(<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> start = <span class=\"hljs-built_in\">Date</span>.now();\n  <span class=\"hljs-keyword\">await</span> next();\n  <span class=\"hljs-keyword\">const</span> ms = <span class=\"hljs-built_in\">Date</span>.now() - start;\n  ctx.set(<span class=\"hljs-string\">'X-Response-Time'</span>, <span class=\"hljs-string\">`<span class=\"hljs-subst\">${ms}</span>ms`</span>);\n}\n\napp.use(responseTime);\n</code></pre>\n<p>프론트엔드 개발자는 <code>next()</code> 전의 코드를 “capture” 단계로 <code>next()</code> 후의 코드를 “bubble” 단계로 생각할 수 있다.  아래의 이미지는 어떻게 async 함수로 request, reponse 구현을 스택 플로우로 활용할 수 있는 지 설명해준다.</p>\n<p><img src=\"/assets/images/2020-01-04-img/middleware.gif\" alt=\"Koa middleware\"></p>\n<ol>\n<li>response time 생성</li>\n<li>Await를 통해 다음 미들웨어로</li>\n<li>소요시간 계산을 위해 또 다른 time을 생성</li>\n<li>Await를 통해 다음 미들웨어로</li>\n<li>response body에 “Hello World” 셋팅</li>\n<li>소요시간 계산</li>\n<li>로그로 출력</li>\n<li>응답시간 계산</li>\n<li><code>X-Response-Time</code>  헤더 필드에 값 셋팅</li>\n<li>Koa로 이동하여 response 전달</li>\n</ol>\n<p>이제 우리는 Koa 미들웨어를 생성하는 방법에 대해 알아볼 것이다.</p>\n<h2>미들웨어 표준 사용법</h2>\n<p>이 섹션은 미들웨어 옵션, 디버깅 등을 위한 미들웨어 사용 방법에 대해 다룬다.</p>\n<h3>미들웨어 옵션들</h3>\n<p>공용 미들웨어를 생성할 때 옵션을 허용하여 편리하게 함수를 확장하여 미들웨어를 랩핑할 수 있다.  미들웨어에서 옵션을 허용하지 않을 수도 있는 데, 이는 좋은 표준이기도 하다.</p>\n<p>여기 <code>logger</code> 미들웨어는 커스텀을 위해 <code>format</code>을 이용하여 값을 셋팅 후 문자열로 리턴한다.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">logger</span>(<span class=\"hljs-params\">format</span>) </span>{\n  format = format || <span class=\"hljs-string\">':method \":url\"'</span>;\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">ctx, next</span>) </span>{\n    <span class=\"hljs-keyword\">const</span> str = format\n      .replace(<span class=\"hljs-string\">':method'</span>, ctx.method)\n      .replace(<span class=\"hljs-string\">':url'</span>, ctx.url);\n\n    <span class=\"hljs-built_in\">console</span>.log(str);\n\n    <span class=\"hljs-keyword\">await</span> next();\n  };\n}\n\napp.use(logger());\napp.use(logger(<span class=\"hljs-string\">':method :url'</span>));\n</code></pre>\n<h3>미들웨어 이름 지정</h3>\n<p>미들웨어의 이름을 지정하는 것은 선택사항이나 이름을 사용하면 디버깅 목적으로 사용할 때 유용하다.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">logger</span>(<span class=\"hljs-params\">format</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">logger</span>(<span class=\"hljs-params\">ctx, next</span>) </span>{\n\n  };\n}\n</code></pre>\n<h3>koa-compose를 통해 다양한 미들웨어 조합하기</h3>\n<p><a href=\"https://github.com/koajs/compose\">koa-compose</a> 를 사용하면 여러 개의 미들웨어를 조립하여 하나의 미들웨어로 사용할 수 있다. 미들웨어를 재사용하거나 export할 때 유리하다.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> compose = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'koa-compose'</span>);\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">random</span>(<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'/random'</span> == ctx.path) {\n    ctx.body = <span class=\"hljs-built_in\">Math</span>.floor(<span class=\"hljs-built_in\">Math</span>.random() * <span class=\"hljs-number\">10</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">await</span> next();\n  }\n};\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">backwards</span>(<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'/backwards'</span> == ctx.path) {\n    ctx.body = <span class=\"hljs-string\">'sdrawkcab'</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">await</span> next();\n  }\n}\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">pi</span>(<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'/pi'</span> == ctx.path) {\n    ctx.body = <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-built_in\">Math</span>.PI);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">await</span> next();\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> all = compose([random, backwards, pi]);\n\napp.use(all);\n</code></pre>\n<h3>미들웨어 Response</h3>\n<p>미들웨어는 요청에 대한 응답을 위해 <code>next()</code>를 생략할지도 모른다. 일반적으로 <code>next()</code>는 미들웨어의 라우팅을 결정하나 다음과 같은 작업을 한다.\n예를 들어 아래의 코드는 요청에 대해 &quot;two&quot;를 응답하나 3개의 미들웨어 모두 실행된다. 3개의 미들웨어에 response를 조작할 수 있는 기회가 주어지는 것이다.</p>\n<pre><code class=\"language-js\">app.use(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&gt;&gt; one'</span>);\n  <span class=\"hljs-keyword\">await</span> next();\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&lt;&lt; one'</span>);\n});\n\napp.use(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&gt;&gt; two'</span>);\n  ctx.body = <span class=\"hljs-string\">'two'</span>;\n  <span class=\"hljs-keyword\">await</span> next();\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&lt;&lt; two'</span>);\n});\n\napp.use(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&gt;&gt; three'</span>);\n  <span class=\"hljs-keyword\">await</span> next();\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&lt;&lt; three'</span>);\n});\n</code></pre>\n<p>아래의 코드는 두번째 미들웨어에서 <code>next()</code>를 생략했고 response로 &quot;two&quot;를 셋팅하여 세번째 미들웨어는 무시될 것이다.</p>\n<pre><code class=\"language-js\">app.use(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&gt;&gt; one'</span>);\n  <span class=\"hljs-keyword\">await</span> next();\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&lt;&lt; one'</span>);\n});\n\napp.use(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&gt;&gt; two'</span>);\n  ctx.body = <span class=\"hljs-string\">'two'</span>;\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&lt;&lt; two'</span>);\n});\n\napp.use(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&gt;&gt; three'</span>);\n  <span class=\"hljs-keyword\">await</span> next();\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&lt;&lt; three'</span>);\n});\n</code></pre>\n<p>가장 마지막 미들웨어에서 <code>next()</code>를 실행하면 noop function, 아무 동작을 하지 않으며 미들웨어가 스택의 어느 곳에서나 올바르게 구성할 수 있다.</p>\n<h2>Async operations</h2>\n<p>Async 함수와 promise 기반인 Koa는 non-blocking sequential code를 허용한다. 예를 들어 이 미들웨어는 <code>./docs</code> 디렉토리에서 파일 이름들을 읽어온 후  parallel, 병렬로 각각의 마크다운 파일 형태의 내용을 읽어 body에 결과를 join 하여 셋팅한다.</p>\n<blockquote>\n<p>non-blocking이란, 어떤 쓰레드에서 오류가 발생하거나 멈추었을 때 다른 쓰레드에게 영향을 끼치지 않도록 만드는 방법들을 말한다.</p>\n</blockquote>\n<blockquote>\n<p>parallel, 병렬이라는 뜻처럼 데이터를 한번에 여러 개를 전송한다</p>\n</blockquote>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'mz/fs'</span>);\n\napp.use(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> paths = <span class=\"hljs-keyword\">await</span> fs.readdir(<span class=\"hljs-string\">'docs'</span>);\n  <span class=\"hljs-keyword\">const</span> files = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.all(paths.map(<span class=\"hljs-function\"><span class=\"hljs-params\">path</span> =&gt;</span> fs.readFile(<span class=\"hljs-string\">`docs/<span class=\"hljs-subst\">${path}</span>`</span>, <span class=\"hljs-string\">'utf8'</span>)));\n\n  ctx.type = <span class=\"hljs-string\">'markdown'</span>;\n  ctx.body = files.join(<span class=\"hljs-string\">''</span>);\n});\n</code></pre>\n<h2>Koa 디버깅하기</h2>\n<p>Koa along with many of the libraries it’s built with support the <strong>DEBUG</strong> environment variable from <a href=\"https://github.com/visionmedia/debug\">debug</a> which provides simple conditional logging.</p>\n<p>For example\nto see all Koa-specific debugging information just pass <code>DEBUG=koa*</code> and upon boot you’ll see the list of middleware used, among other things.</p>\n<pre><code>$ DEBUG=koa* node --harmony examples/simple\n  koa:application use responseTime +0ms\n  koa:application use logger +4ms\n  koa:application use contentLength +0ms\n  koa:application use notfound +0ms\n  koa:application use response +0ms\n  koa:application listen +0ms\n</code></pre>\n<p>Since JavaScript does not allow defining function names at\nruntime, you can also set a middleware’s name as <code>._name</code>.\nThis is useful when you don’t have control of a middleware’s name.\nFor example:</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>);\n<span class=\"hljs-keyword\">const</span> serve = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'koa-static'</span>);\n\n<span class=\"hljs-keyword\">const</span> publicFiles = serve(path.join(__dirname, <span class=\"hljs-string\">'public'</span>));\npublicFiles._name = <span class=\"hljs-string\">'static /public'</span>;\n\napp.use(publicFiles);\n</code></pre>\n<p>Now, instead of just seeing “serve” when debugging, you will see:</p>\n<pre><code>  koa:application use static /public +0ms\n</code></pre>\n","updatedAt":"2020-01-22T18:19:16.346Z"}