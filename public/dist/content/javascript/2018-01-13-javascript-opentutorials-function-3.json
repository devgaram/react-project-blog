{"layout":"post-content","title":"(생활코딩) javascript 함수지향3","date":"2018-01-13T00:00:00.000Z","tags":["javascript"],"category":["javascript"],"body":"<p>생활코딩 함수지향 파트 중 클로저에 대한 내용을 정리했습니다.</p>\n<hr>\n<h1>1. 클로저의 개념</h1>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">outter</span>(<span class=\"hljs-params\"></span>) </span>{ \n  <span class=\"hljs-keyword\">var</span> title = <span class=\"hljs-string\">'coding everybody'</span>; \n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ \n    alert(title); \n  } \n} \ninner = outter(); \ninner();\n</code></pre>\n<p>함수 outter의 리턴 값은 내부함수이며 변수 inner에 내부함수가 값으로 저장된다.<br>\noutter 호출이 종료된 순간, outter는 사라진다.<br>\n하지만, inner()를 실행했을 때 알럿창에 coding everybody가 보인다.</p>\n<p>왜?<br>\n<span class=\"clr-note\">내부함수는 외부함수가 종료되도 외부함수에 접근할 수 있다.</span></p>\n<h1>2. private variable</h1>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">factory_movie</span>(<span class=\"hljs-params\">title</span>)</span>{ \n    <span class=\"hljs-keyword\">return</span>{ \n        <span class=\"hljs-attr\">get_title</span> : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ \n            <span class=\"hljs-keyword\">return</span> title; \n        }, \n        <span class=\"hljs-attr\">set_tile</span> : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">_title</span>)</span>{ \n            <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">typeof</span> _title === <span class=\"hljs-string\">'String'</span>){ \n                title = _title; \n            } <span class=\"hljs-keyword\">else</span>{ \n                alert(<span class=\"hljs-string\">'제목은 문자열이여야 합니다.'</span>); \n            } \n        } \n    } \n} \nghost = factory_movie(<span class=\"hljs-string\">'Ghost in the shell'</span>); \nmatrix = factory_movie(<span class=\"hljs-string\">'Matrix'</span>); \nalert(ghost.get_title());    <span class=\"hljs-comment\">//Ghost in the shell </span>\nalert(matrix.get_tiel());    <span class=\"hljs-comment\">//Matrix</span>\n</code></pre>\n<p>factory_movie의 리턴 값은 get_title, set_title 메소드를 속성으로 가지고 있는 객체이다.<br>\nghost, matrix 변수는 객체를 담게된다.<br>\nfactory_movie 호출 후, 함수의 생이 종료되어도 ghost, matrix를 통해 함수의 지역변수인 title에 접근할 수 있다.</p>\n<p>왜 private variable을 사용해야 하는가?<br>\n<span class=\"clr-note\">외부에서 title 변수를 수정해도 ghost, matrix가 가진 title의 맥락에는 영향을 주지 않는다.    즉, 데이터의 수정과 저장을 안전하게 할 수 있다.</span></p>\n<h1>3. 클로저의 응용</h1>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> arr = []; \n<span class=\"hljs-keyword\">for</span>( <span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">5</span>; i++){\n     arr[i] = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ \n        <span class=\"hljs-built_in\">console</span>.log(i);\n     } \n} \n \n<span class=\"hljs-keyword\">for</span>( <span class=\"hljs-keyword\">var</span> index <span class=\"hljs-keyword\">in</span> arr ){ \n    <span class=\"hljs-built_in\">console</span>.log(arr[index]()); \n} \n<span class=\"hljs-comment\">//결과는 5 5 5 5 5</span>\n</code></pre>\n<p>함수가 실행되는 시점의 변수가 내부함수에 저장된다.<br>\n두번째 반목문에서 배열객체의 함수를 실행하는 순간의 i가 콘솔에 찍히게 된다.<br>\n그러나, i는 첫번째 포문에 의해 이미 5가 되어버린 상태이므로 5만 다섯번 찍히게 된다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> arr = []; \n<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">5</span>; i++){ \n    arr[i] = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">id</span>)</span>{ \n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ \n            <span class=\"hljs-keyword\">return</span> id; \n        } \n    }(i); \n} \n \n<span class=\"hljs-keyword\">for</span>( <span class=\"hljs-keyword\">var</span> index <span class=\"hljs-keyword\">in</span> arr){ \n    <span class=\"hljs-built_in\">console</span>.log(arr[index]());  \n} \n<span class=\"hljs-comment\">//결과는 0,1,2,3,4</span>\n</code></pre>\n<p>외부함수의 인자 값으로 i가 전달되고, 내부함수는 이 시점의 i를 저장한다.<br>\n첫번째 포문에서 외부함수가 i를 인자값으로 하면서 실행되는 시점에서 내부함수가 정의된다.</p>\n","updatedAt":"2020-01-22T18:21:10.070Z"}