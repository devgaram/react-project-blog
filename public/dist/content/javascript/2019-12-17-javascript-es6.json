{"layout":"post-content","title":"ES6를 모르면 React 배우기가 어려워요.","date":"2019-12-17T00:00:00.000Z","tags":["es6","react"],"categories":["javascript"],"body":"<p>React를 배워볼까? 하고 두근거리는 마음으로 React 공식 문서에 방문해서 자습서부터 차근차근 읽어본 적이 있습니다.<br>\n그런데, 으잉? 이건 대체 뭐지? 제게 커다란 장벽이 나타났습니다. 그 것은 바로 바로… <strong>ES6 문법!!!</strong><br>\n그래서 준비했습니다. <span class=\"clr-note\">“ES6를 모르면 React 배우기가 어려워요!”</span> 지금부터 저와 함께 ES6 최신 문법을 정리해봅시다!</p>\n<h1>변수 선언하기</h1>\n<h2>1. const</h2>\n<p>블록(중괄호 {}) 유효 범위의 상수를 선언하며 재할당 및 재선언이 불가능합니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> number = <span class=\"hljs-number\">42</span>;\n\n<span class=\"hljs-keyword\">try</span> {\n  number = <span class=\"hljs-number\">99</span>;\n} <span class=\"hljs-keyword\">catch</span>(err) {\n  <span class=\"hljs-built_in\">console</span>.log(err); <span class=\"hljs-comment\">// TypeError: Assignment to constant variable.</span>\n}\n\n<span class=\"hljs-built_in\">console</span>.log(number); <span class=\"hljs-comment\">// 42</span>\n</code></pre>\n<h2>2. let</h2>\n<p><code class=\"codetainer\">let</code> 키워드를 사용하면 변수의 유효 범위를 블록 {} 안으로 한정시킬 수 있고 글로벌 변수의 값을 보호할 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> topic = <span class=\"hljs-string\">\"js\"</span>\n<span class=\"hljs-keyword\">if</span> (topic) {\n  <span class=\"hljs-keyword\">var</span> topic = <span class=\"hljs-string\">\"리액트\"</span>\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'블록'</span>, topic) <span class=\"hljs-comment\">// 블록 리액트</span>\n}\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'글로벌'</span>, topic) <span class=\"hljs-comment\">// 글로벌 리액트</span>\n</code></pre>\n<p>위 예제의 if 블록 안의 topic 변수와 if 블록 밖의 topic 변수는 같은 변수입니다.<br>\n<code class=\"codetainer\">var</code> 키워드는 함수 유효 범위를 가지기 때문입니다. 자바스크립트의 호이스팅에 의해 함수 안에 정의된 변수는 함수의 맨 앞에서 정의되고 <code class=\"codetainer\">undefined</code>로 초기화되기 때문에 두 topic 변수가 사실상 같은 변수가 됩니다.\n<br/><br/></p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> topic = <span class=\"hljs-string\">\"js\"</span>\n<span class=\"hljs-keyword\">if</span> (topic) {\n  <span class=\"hljs-keyword\">let</span> topic = <span class=\"hljs-string\">\"리액트\"</span>\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'블록'</span>, topic) <span class=\"hljs-comment\">// 블록 리액트</span>\n}\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'글로벌'</span>, topic) <span class=\"hljs-comment\">// 글로벌 js</span>\n</code></pre>\n<p>if 블록 안의 변수가 if 블록 밖의 변수에 영향을 끼치지 않게 하려면 <code class=\"codetainer\">let</code> 키워드를 사용하면 됩니다. <code class=\"codetainer\">let</code>은 블록 유효 범위이므로 호이스팅 시 블록의 맨 앞에서 정의되고 초기화 됩니다.\n<br/><br/></p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-built_in\">console</span>.log(name) <span class=\"hljs-comment\">// Uncaught ReferenceError: Cannot access 'name' before initialization</span>\n<span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">'lee'</span> \n\n<span class=\"hljs-built_in\">console</span>.log(age); <span class=\"hljs-comment\">// undefined</span>\n<span class=\"hljs-keyword\">var</span> age = <span class=\"hljs-string\">'20'</span>\n</code></pre>\n<p>단, var로 선언된 변수는 선언과 초기화가 동시에 진행되고 let을 선언된 변수는 호이스팅되어 선언 단계가 이뤄지나 초기화 단계는 실제 let이 사용된 코드에 도착할 때 이루어집니다. 그래서 let 키워드로 선언한 변수를 초기화 단계 이전에 접근하면 reference 에러가 발생합니다.</p>\n<h2>3. 템플릿 문자열</h2>\n<p>템플릿 문자열 덕분에 더하기 기호 + 없이 편하게 문자열과 변수를 이어 붙인 string을 생성할 수 있습니다.<br>\n<code class=\"codetainer\">${}</code> 안에는 자바스크립트 변수, 식 어떤 것이든 가능하며 템플릿 문자열은 공백, 탭, 개행 문자를 사용할 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${lastName}</span>, <span class=\"hljs-subst\">${firstName}</span> <span class=\"hljs-subst\">${middleName}</span>`</span>)\n</code></pre>\n<p><span class=\"clr-grey\"></span>\n<span class=\"clr-note\"></span></p>\n<h2>4. 디폴트 파라미터</h2>\n<p>이제 함수를 호출 시 인자 값이 넘어오지 않았다면 디폴트 값을 사용할 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span>(<span class=\"hljs-params\">name=<span class=\"hljs-string\">\"lee\"</span>, age=<span class=\"hljs-string\">\"20\"</span></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${name}</span> : <span class=\"hljs-subst\">${age}</span>`</span>)\n}\nfunc() <span class=\"hljs-comment\">// lee : 20</span>\n</code></pre>\n<p>함수 호출 시 인자 넘기지 않아도 디폴트 값을 사용해 함수가 정상적으로 실행됩니다. 문자열뿐 아니라 객체 등 다양한 타입의 값을 디폴트로 사용할 수 있습니다.</p>\n<h1>화살표 함수 =&gt;</h1>\n<p>화살표 함수를 사용하면 function 키워드 없이도 함수를 만들 수 있고 return을 사용하지 않아도 식을 계산한 값이 자동으로 반환됩니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> materials = [\n  <span class=\"hljs-string\">'Hydrogen'</span>,\n  <span class=\"hljs-string\">'Helium'</span>,\n  <span class=\"hljs-string\">'Lithium'</span>,\n  <span class=\"hljs-string\">'Beryllium'</span>\n];\nmaterials.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">{length}</span>) =&gt;</span> length); <span class=\"hljs-comment\">// [8, 6, 7, 9]</span>\n</code></pre>\n<br/>\n또한, <span class=\"clr-note\">화살표 함수는 this를 새로 바인딩 하지 않습니다.</span> 대신 코드에서 바로 바깥의 함수(혹은 class)의 this 값을 사용합니다. 뿐만 아니라 <code class=\"codetainer\">arguments, super, new.target</code>을 바인딩 하지 않습니다.\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> obj = {\n  <span class=\"hljs-attr\">i</span>: <span class=\"hljs-number\">10</span>,\n  <span class=\"hljs-attr\">b</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.i, <span class=\"hljs-keyword\">this</span>),\n  <span class=\"hljs-attr\">c</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-keyword\">this</span>.i, <span class=\"hljs-keyword\">this</span>)\n  }\n}\nobj.b(); <span class=\"hljs-comment\">// prints undefined, Window</span>\nobj.c(); <span class=\"hljs-comment\">// prints 10, Object {...}</span>\n</code></pre>\n<br/>\nthis를 바인딩 하지 않기 때문에 메소드 함수에는 사용하지 않아야 하며 생성자로서도 사용할 수 없기 때문에 <code class=\"codetainer\">new</code>와 함께 사용하면 오류가 발생합니다.\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> Foo = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {};\n<span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">new</span> Foo(); <span class=\"hljs-comment\">// TypeError: Foo is not a constructor</span>\n</code></pre>\n<h1>ES6 객체와 배열</h1>\n<h2>1. 구조 분해(Destructuring)</h2>\n<p>구조 분해를 사용하면 객체의 필드를 원하는 변수에 대입할 수 있습니다.</p>\n<p>다음은 sandwich를 분해해서 bread와 meat 필드를 같은 이름의 변수에 넣어주는 코드입니다. 두 변수의 값은 sandwich에 있는 같은 이름의 필드 값으로 초기화되지만, 두 변수를 변경해도 원래의 필드 값은 바뀌지는 않습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> sandwich = {\n  <span class=\"hljs-attr\">bread</span>: <span class=\"hljs-string\">\"크런치\"</span>,\n  <span class=\"hljs-attr\">meat</span>: <span class=\"hljs-string\">\"참치\"</span>,\n  <span class=\"hljs-attr\">cheese</span>: <span class=\"hljs-string\">\"스위스\"</span>,\n  <span class=\"hljs-attr\">toppings</span>: [<span class=\"hljs-string\">\"상추\"</span>, <span class=\"hljs-string\">\"토마토\"</span>, <span class=\"hljs-string\">\"머스타드\"</span>]\n}\n\n<span class=\"hljs-keyword\">var</span> {bread, meat} = sandwich\n\n<span class=\"hljs-built_in\">console</span>.log(bread, meat) <span class=\"hljs-comment\">// 크런치 참치</span>\n</code></pre>\n<p>객체를 분해해서 함수의 인자로 넘길 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> func = <span class=\"hljs-function\">(<span class=\"hljs-params\">{firstName}</span>) =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`이름은 <span class=\"hljs-subst\">${firstName}</span>`</span>)\n}\n\nfunc({\n  <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">'garam'</span>,\n  <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">'lee'</span>\n}) <span class=\"hljs-comment\">// 이름은 lee</span>\n</code></pre>\n<p>배열의 경우도 비슷합니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> x = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\n<span class=\"hljs-keyword\">var</span> [y, z] = x;\n<span class=\"hljs-built_in\">console</span>.log(y,z); <span class=\"hljs-comment\">// 1 2</span>\n</code></pre>\n<p>변수 선언이 분리되어도 값 할딩이 가능합니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> a, b;\n[a, b] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n<span class=\"hljs-built_in\">console</span>.log(a, b); <span class=\"hljs-comment\">// 1 2</span>\n</code></pre>\n<p>기본값을 할당하여 분해한 값이 undefined면 기본 값을 사용합니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> a, b;\n[a=<span class=\"hljs-number\">5</span>, b=<span class=\"hljs-number\">7</span>] = [<span class=\"hljs-number\">1</span>];\n<span class=\"hljs-built_in\">console</span>.log(a); <span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-built_in\">console</span>.log(b); <span class=\"hljs-comment\">// 7</span>\n</code></pre>\n<p>두 변수 값 교환이 가능합니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">3</span>;\n\n[a, b] = [b, a];\n<span class=\"hljs-built_in\">console</span>.log(a); <span class=\"hljs-comment\">// 3</span>\n<span class=\"hljs-built_in\">console</span>.log(b); <span class=\"hljs-comment\">// 1</span>\n</code></pre>\n<p>불필요한 값을 콤마를 사용해 생략하는 리스트 매칭을 사용할 수 있습니다. 무시하고 싶은 원소 위치에 콤마를 넣으면 리스트 매칭이 됩니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> [,,third] = [<span class=\"hljs-string\">\"a\"</span>,<span class=\"hljs-string\">\"b\"</span>,<span class=\"hljs-string\">\"c\"</span>]\n<span class=\"hljs-built_in\">console</span>.log(third) <span class=\"hljs-comment\">// c</span>\n</code></pre>\n<h2>2. 객체 리터럴 개선</h2>\n<p>구조 분해의 반대라고 할 수 있으며 객체 리터럴 개선을 사용하면 현재 영역에 있는 변수를 객체의 필드로 묶을 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"lee\"</span>\n<span class=\"hljs-keyword\">var</span> age = <span class=\"hljs-string\">\"20\"</span>\n<span class=\"hljs-keyword\">var</span> print = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${<span class=\"hljs-keyword\">this</span>.name}</span> : <span class=\"hljs-subst\">${<span class=\"hljs-keyword\">this</span>.age}</span>`</span>)\n}\n<span class=\"hljs-keyword\">var</span> person = {name, age, print}\nperson.print() <span class=\"hljs-comment\">// lee : 20</span>\n</code></pre>\n<p>객체 리터럴 개선으로 변수를 객체의 필드로 대입할 수 있으며 function 키워드를 입력하지 않고 메서드를 정의할 수 있다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// 예전 방식</span>\n<span class=\"hljs-keyword\">var</span> obj = {\n  <span class=\"hljs-attr\">name</span>: name,\n  <span class=\"hljs-attr\">age</span>: age,\n  <span class=\"hljs-attr\">print</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${name}</span> : <span class=\"hljs-subst\">${age}</span>`</span>)\n  }\n}\n\n<span class=\"hljs-comment\">// 개선된 방식</span>\n<span class=\"hljs-keyword\">const</span> obj = {\n  name,\n  age,\n  print() {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${name}</span> : <span class=\"hljs-subst\">${age}</span>`</span>)\n  }\n}\n</code></pre>\n<h2>3. 스프레드 연산자</h2>\n<p>스프레드 연산자는 세 개의 점(…)으로 이루어진 연산자로,\n<code class=\"codetainer\">함수호출, 배열 리터럴과 문자열, 객체 리터럴</code>에서 사용할 수 있습니다.</p>\n<p>이전에는 두 배열의 모든 원소가 들어간 새로운 배열을 만들기 위해서 <code class=\"codetainer\">push(), splice(), concat() </code> 등을 사용해야 했습니다. 이제 스프레드 연산자를 통해 쉽게 만들 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// 이전 방식</span>\n<span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n<span class=\"hljs-keyword\">var</span> arr2 = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\narr1 = arr1.concat(arr2);\n\n<span class=\"hljs-comment\">// 전개 방식</span>\n<span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n<span class=\"hljs-keyword\">var</span> arr2 = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\narr1 = [...arr1, ...arr2]; <span class=\"hljs-comment\">// arr1은 [0,1,2,3,4,5]</span>\n\n<span class=\"hljs-comment\">// 새로운 배열 생성</span>\n<span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n<span class=\"hljs-keyword\">var</span> arr2 = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\n<span class=\"hljs-keyword\">var</span> arr3 = [...arr1, ...arr2] <span class=\"hljs-comment\">// [0,1,2,3,4,5]</span>\n\n<span class=\"hljs-comment\">// 중간 조합도 가능</span>\n<span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n<span class=\"hljs-keyword\">var</span> arr2 = [<span class=\"hljs-number\">3</span>, ...arr1, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]; <span class=\"hljs-comment\">// 3,0,1,2,4,5</span>\n\n<span class=\"hljs-comment\">// 나머지 원소 얻기 가능</span>\n<span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">var</span> [first, ...rest] = arr1;\n<span class=\"hljs-built_in\">console</span>.log(rest); <span class=\"hljs-comment\">// 1,2,3</span>\n</code></pre>\n<p>스프레드 연산자는 원본 배열을 변경하지 않고 복사본을 만듭니다.<br>\n다음 예제를 통해 실제로 확인해보자. arr1 배열의 마지막 원소를 변수에 담으려고 <code class=\"codetainer\">Array.reverse</code>를 이용해 배열을 뒤집고 첫번째 원소를 변수에 넣는 예제입니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// 원본 배열이 변경된다.</span>\n<span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n<span class=\"hljs-keyword\">var</span> [last] = arr1.reverse();\n<span class=\"hljs-built_in\">console</span>.log(last); <span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-built_in\">console</span>.log(arr1); <span class=\"hljs-comment\">// 2 1 0</span>\n\n<span class=\"hljs-comment\">// 전개 연산을 통해 원본 배열 유지하기</span>\n<span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n<span class=\"hljs-keyword\">var</span> [last] = [...arr1].reverse();\n<span class=\"hljs-built_in\">console</span>.log(last); <span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-built_in\">console</span>.log(arr1); <span class=\"hljs-comment\">// 0,1,2</span>\n</code></pre>\n<p>객체에 사용할 수도 있습니다. 사용법은 배열과 유사합니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> obj1 = { <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>, <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">42</span> };\n<span class=\"hljs-keyword\">var</span> obj2 = { <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'baz'</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">13</span> };\n<span class=\"hljs-keyword\">var</span> obj3 = <span class=\"hljs-string\">\"obj\"</span>\n<span class=\"hljs-keyword\">var</span> mergedObj = { ...obj1, ...obj2, obj3};\n<span class=\"hljs-built_in\">console</span>.log(mergedObj); <span class=\"hljs-comment\">// { foo: \"baz\", x: 42, y: 13, obj3: \"obj\" }</span>\n</code></pre>\n<p>함수 호출할 때도 사용할 수 있어서 배열의 엘리먼트를 함수의 인자로 사용하고자 할 때<code class=\"codetainer\">Function.prototype.apply()</code>를 대체할 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// 이전 방식</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\">x, y, z</span>) </span>{ }\n<span class=\"hljs-keyword\">var</span> args = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\nmyFunction.apply(<span class=\"hljs-literal\">null</span>, args);\n\n<span class=\"hljs-comment\">// 전개 방식</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\">x, y, z</span>) </span>{ }\n<span class=\"hljs-keyword\">var</span> args = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\nmyFunction(...args);\n\n<span class=\"hljs-comment\">// new 키워드와 함께 사용할 수 있습니다.</span>\n<span class=\"hljs-keyword\">var</span> dateFields = [<span class=\"hljs-number\">1970</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>];  <span class=\"hljs-comment\">// 1 Jan 1970</span>\n<span class=\"hljs-keyword\">var</span> d = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(...dateFields);\n</code></pre>\n<h1>클래스</h1>\n<p>이전에는 공식적으로 클래스가 없어서 타입을 함수로 정의하고 그 함수 객체에 있는 프로토타입을 사용해 메서드를 정의했습니다. ES6부터 클래스 선언이 추가되어서 쉽게 클래스 패턴 생성이 가능해졌습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> Foo = <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>() {}\n  bar() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Hello World!\"</span>;\n  }\n};\n\n<span class=\"hljs-keyword\">var</span> instance = <span class=\"hljs-keyword\">new</span> Foo();\ninstance.bar(); <span class=\"hljs-comment\">// \"Hello World!\"</span>\nFoo.name; <span class=\"hljs-comment\">// \"\"</span>\n</code></pre>\n<p>class 키워드를 사용하더라도 내부적으로는 자바스크립트의 프로토타입 상속을 사용하고 있습니다. <code class=\"codetainer\">Foo.prototype</code>을 콘솔에 찍어보면 프로토타입에 생성자와 bar 메서드가 있는 것을 확인할 수 있을 것입니다.</p>\n<h1>ES6 모듈</h1>\n<p>모듈은 다른 자바스크립트 파일의 코드를 쉽게 불러서 활용할 수 있는 재사용 가능한 코드 조각입니다. <code class=\"codetainer\">export</code>와 <code class=\"codetainer\">import</code> 키워드를 이용하면 됩니다.</p>\n<p><code class=\"codetainer\">export</code>를 사용해 다른 모듈에서 활용할 수 있도록 이름(함수, 객체, 변수, 상수 등)을 외부에 익스포트할 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// export_1.js</span>\n<span class=\"hljs-comment\">// print, log 함수를 외부에 export</span>\n<span class=\"hljs-comment\">// 로컬 선언됨</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> print(message) =&gt; log(message, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>())\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> log(message, timestamp) =&gt; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${timestamp.toString()}</span> : <span class=\"hljs-subst\">${message}</span>`</span>)\n\n<span class=\"hljs-comment\">// export_2.js</span>\n<span class=\"hljs-comment\">// 단 하나의 이름만 외부에 export 하고 싶다면 export default 사용</span>\n<span class=\"hljs-keyword\">const</span> freel = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>();\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> freel;\n</code></pre>\n<p><code class=\"codetainer\">import</code>를 사용해 다른 자바스크립트 파일을 불러와 사용할 수 있습니다. 임포트 시 객체 구조 분해를 사용할 수 있으며, <code class=\"codetainer\">export default</code>를 사용한 경우 구조분해 없이 한 이름으로 부를 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> { print, log } <span class=\"hljs-keyword\">from</span> ./export_1\n<span class=\"hljs-keyword\">import</span> freel <span class=\"hljs-keyword\">from</span> ./export_2\n\n<span class=\"hljs-comment\">// import * 를 사용하여 다른 모듈에서 가져온 모든 이름을 사용자가 정한 로컬 이름 공간 안에 가둘 수 있음</span>\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">from</span> fns <span class=\"hljs-keyword\">from</span> ./export_1\n</code></pre>\n<h1>커먼JS</h1>\n<p>모든 버전의 노드에서 지원하는 일반적인 모듈 패턴입니다. 커먼 JS를 사용하여 객체를 <code class=\"codetainer\">module.exports</code>를 사용해 익스포트할 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">//export.js</span>\n<span class=\"hljs-keyword\">const</span> print(message) =&gt; log(message, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>())\n<span class=\"hljs-keyword\">const</span> log(message, timestamp) =&gt; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${timestamp.toString()}</span> : <span class=\"hljs-subst\">${message}</span>`</span>)\n\n<span class=\"hljs-built_in\">module</span>.exports = {print, log}\n</code></pre>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> { print, log } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./export'</span>)\n</code></pre>\n<h1>ES6에서 비동기 프로그래밍</h1>\n<p>나중에 따로 정리할 예정.</p>\n<h2>1. promises</h2>\n<h2>2. 제너레이터</h2>\n","updatedAt":"2020-01-22T18:27:08.394Z"}