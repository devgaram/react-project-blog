{"layout":"post-content","title":"(JS) call()과 apply()","date":"2018-01-08T00:00:00.000Z","tags":["javascript"],"category":["javascript"],"body":"<p>call() 과 apply() 메서드를 이용하여 명시적으로 this에 바인딩할 수 있습니다.</p>\n<hr>\n<p>모든 함수의 부모 객체인 Function.prototype 객체의 메서드라서 모든 함수에서 호출 가능합니다.</p>\n<h2>Function.prototype.apply()</h2>\n<pre><code class=\"language-javascript\">fun.apply(thisArg, [argArray])\n</code></pre>\n<p>fun 메서드를 호출할 때, fun 내부의 this를 매개변수인 thisArg로 바인딩 시킵니다.\nargArray는 fun 메서드에서 인자로 사용됩니다.<br>\n<span class=\"clr-grey\">argArray : 배열리터럴, Array 객체</span></p>\n<h2>Function.prototype.call()</h2>\n<pre><code class=\"language-javascript\">fun.call(thisArg[,arg1[,arg2[,....]]])\n</code></pre>\n<p>apply와 기능이 같으며, 배열형태가 아닌 각각의 하나의 인자형태로 값을 넘긴다는 차이점이 있습니다.</p>\n<h1>추가 개념</h1>\n<h2>객체의 메서드를 호출할 때, 객체 메서드 내부의 this는?</h2>\n<p>해당 메서드를 호출한 객체</p>\n<h2>함수를 호출할 때, 함수 내부의 this는?</h2>\n<p>전역객체에 바인딩 된다. window\n*내부함수를 호출했을 때도, 내부 this는 window!</p>\n<h2>생성자 함수를 호출할 때, 생성자 함수 내부의 this는?</h2>\n<p>생성자 함수 코드가 실행되기 전 생성되는 빈 객체<br>\n이 객체는 부모인 프로토타입과 연결되어있으므로 부모의 프로퍼티와 메서드를 사용할 수 있다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.age = <span class=\"hljs-number\">0</span>;    <span class=\"hljs-comment\">// (1)</span>\n    setInterval( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">growUp</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-keyword\">this</span>.age++;    <span class=\"hljs-comment\">// (2)</span>\n    },<span class=\"hljs-number\">1000</span>); \n} \n<span class=\"hljs-keyword\">var</span> p  = <span class=\"hljs-keyword\">new</span> Person();\n</code></pre>\n<p>(1)의 this는 생성자 함수를 호출하면서 만들어지는 빈 객체<br>\n(2)의 this는 window 전역객체를 가르킨다.</p>\n<p>그래서, 위의 코드는 1초마다 나이가 1씩 증가하는 결과를 얻을 수 없다.</p>\n<p>그렇다면, (2)가 Person 생성자로 만들어진 객체로 바인딩되게 하고 싶으며 어떻게 해야할까?</p>\n<p>아래 코드와 같이 비전역 변수에 할당하여 해결할 수 있다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-keyword\">var</span> that = <span class=\"hljs-keyword\">this</span>;\n    that.age = <span class=\"hljs-number\">0</span>;     \n \n    setInterval( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">growUp</span>(<span class=\"hljs-params\"></span>)</span>{\n        that.age++;\n    }, <span class=\"hljs-number\">1000</span>); \n}\n</code></pre>\n<p>ES6의 화살표 함수를 이용하면 비전역 변수를 이용하지 않고도 생성자 객체에 바인딩 시킬 수 있다.<br>\n화살표 함수는 자신만의 this를 생성하지 않기 때문이다!!</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.age = <span class=\"hljs-number\">0</span>;     \n \n    setInterval( <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n        <span class=\"hljs-keyword\">this</span>.age++;\n    }, <span class=\"hljs-number\">1000</span>); \n}\n</code></pre>\n<p>위 화살표 함수 내 this는 정확히 Person() 생성자를 통해 생성된 객체를 가리키게 된다!</p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98\">출처</a></p>\n","updatedAt":"2020-01-22T18:21:09.421Z"}