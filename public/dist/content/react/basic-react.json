{"title":"React 기반을 다져보자!","date":"2020-01-07T00:00:00.000Z","tags":["jsx"],"categories":["react"],"body":"<p><span class=\"clr-grey\">새로 알게 된 내용이 있으면 계속해서 추가할 예정입니다. </span></p>\n<blockquote>\n<p><strong>참조 링크</strong> <br/></p>\n<ul>\n<li><a href=\"https://reactjs-kr.firebaseapp.com/docs/hello-world.html\">리액트 공식 문서</a></li>\n</ul>\n</blockquote>\n<h1>JSX</h1>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> element = <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, world<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\nReactDOM.render(\n  element,\n  <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'root'</span>) <span class=\"hljs-comment\">// ID가 root인 노드에 렌더링하겠다!</span>\n);\n</code></pre>\n<ul>\n<li>JSX는 화면에서 볼 수 있는 내용에 대한 설명인 <code>React elements</code> 객체를 만든다.</li>\n<li>표현식이므로 if문, for 반복, 변수 할당, 매개 변수로 사용 가능하다.</li>\n<li>Babel은 JSX를 <code>React.createElement()</code> 호출로 컴파일합니다.</li>\n<li>리액트 요소는 <code>Immutable Objects</code>라서 한번 만들면 그 자식이나 속성을 변경할 수 없다. UI를 업데이트 하려면 새로운 요소를 만들어서 <code>ReactDOM.render()</code>에 전달해야한다.</li>\n</ul>\n<blockquote>\n<p><strong>Note:</strong> <br/>\n실제로 대부분의 React 어플리케이션은 ReactDOM.render() 를 한번만 호출한다. -&gt; state를 이용한다.</p>\n</blockquote>\n<h1>순수 함수란?</h1>\n<p>순수 함수는 입력을 변경하지않으며 항상 동일한 입력에 대해 동일한 결과를 반환하는 함수다.</p>\n<p><strong>순수 함수</strong></p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> a + b;\n}\n</code></pre>\n<p><strong>순수 함수가 아님</strong></p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">withdraw</span>(<span class=\"hljs-params\">account, amount</span>) </span>{\n  account.total -= amount;\n}\n</code></pre>\n<h1>Props</h1>\n<ul>\n<li>부모 컴포넌트에서 자식 컴포넌트로 전달된 데이터다.</li>\n<li>Props는 읽기전용이므로 수정할 수 없다.</li>\n<li>모든 React 컴포넌트는 props와 관련한 동작을 할 때 <code>순수 함수</code>처럼 동작해야한다.</li>\n</ul>\n<h1>State</h1>\n<h2>1. 클래스 컴포넌트에서 state 사용하기</h2>\n<pre><code class=\"language-javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Clock</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(props) {\n    <span class=\"hljs-keyword\">super</span>(props);\n    <span class=\"hljs-keyword\">this</span>.state = {<span class=\"hljs-attr\">date</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()};\n  }\n\n  <span class=\"hljs-comment\">// mounting : Clock 이 DOM에 최초로 렌더링 될 때</span>\n  componentDidMount() {\n\n  }\n\n  <span class=\"hljs-comment\">// unmounting : DOM에서 Clock 을 삭제했을 때</span>\n  componentWillUnmount() {\n\n  }\n  render() {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, world!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>It is {this.state.date.toLocaleTimeString()}.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  }\n}\n\nReactDOM.render(\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Clock</span> /&gt;</span>,\n  document.getElementById('root')\n);\n</span></code></pre>\n<h2>2. 함수형 컴포넌트에서 state 사용하기</h2>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> React, { useEffect, useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-comment\">// ...</span>\n\n<span class=\"hljs-keyword\">const</span> PetSitterApplyContainer = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> [current, setCurrent] = useState(<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// 인자는 초기값</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n\n  <span class=\"hljs-comment\">// 라이프사이클 훅</span>\n  useEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handleResize</span>(<span class=\"hljs-params\"></span>) </span>{\n      dispatch(resize(<span class=\"hljs-built_in\">window</span>.innerWidth, <span class=\"hljs-built_in\">window</span>.innerHeight))\n    }\n    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'resize'</span>, handleResize)\n  });\n\n  <span class=\"hljs-keyword\">const</span> next = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    setCurrent(current + <span class=\"hljs-number\">1</span>)\n  }\n\n  <span class=\"hljs-keyword\">const</span> prev = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    setCurrent(current - <span class=\"hljs-number\">1</span>)\n  }\n  \n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">PetSitterApply</span> \n      <span class=\"hljs-attr\">current</span>=<span class=\"hljs-string\">{current}</span> /&gt;</span>\n  )\n}\n</span></code></pre>\n<ul>\n<li>state는 React 컴포넌트가 유저 액션, 네트워크 응답, 기타 등등에 대한 응답으로 시간 경과에 따라 출력을 변경할 수 있게 한다.</li>\n<li>State는 로컬이며 캡슐화되어있다 : 부모 컴포넌트나 자식 컴포넌트는 특정 컴포넌트의 state 유무를 알 수 없으며 해당 컴포넌트가 함수나 클래스로 선언되었는 지 알 수 없기 때문</li>\n<li><code>componentDidMount() 훅</code> : 컴포넌트 출력이 DOM에 렌더링 된 이후 동작한다.</li>\n<li><code>componentWillUnmount() 훅</code> : 컴포넌트가 DOM에서 삭제된 이후 동작한다.</li>\n<li><code>useEffect</code> : 리액트 컴포넌트가 렌더링 될 때마다 특정 작업을 수행하도록 설정 할 수 있는 Hook으로 클래스형 컴포넌트의 componentDidMount 와 componentDidUpdate 를 합친 형태다.</li>\n</ul>\n<h2>3. State 바르게 사용하기</h2>\n<ul>\n<li>State를 직접 수정하지말기</li>\n</ul>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// Wrong</span>\n<span class=\"hljs-keyword\">this</span>.state.comment = <span class=\"hljs-string\">'Hello'</span>;\n\n<span class=\"hljs-comment\">// Correct</span>\n<span class=\"hljs-keyword\">this</span>.setState({<span class=\"hljs-attr\">comment</span>: <span class=\"hljs-string\">'Hello'</span>});\n</code></pre>\n<ul>\n<li>this.props 및 this.state가 비동기로 업데이트될 수 있다는 것을 고려하기</li>\n</ul>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// Wrong</span>\n<span class=\"hljs-keyword\">this</span>.setState({\n  <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-keyword\">this</span>.state.counter + <span class=\"hljs-keyword\">this</span>.props.increment,\n});\n\n<span class=\"hljs-comment\">// Correct : 이전 state를 인수로 받음</span>\n<span class=\"hljs-keyword\">this</span>.setState(<span class=\"hljs-function\">(<span class=\"hljs-params\">prevState, props</span>) =&gt;</span> ({\n  <span class=\"hljs-attr\">counter</span>: prevState.counter + props.increment\n}));\n</code></pre>\n<h1>하향식(top-down) 혹은 단방향(unidirectional) 데이터 흐름</h1>\n<ul>\n<li>모든 state는 항상 특정 컴포넌트가 가지며, 해당 state에서 파생된 모든 데이터 또는 UI는 트리의 컴포넌트 <code>아래(below)</code>에만 영향을 미친다.</li>\n<li>컴포넌트는 자신의 state를 자식 컴포넌트에 props 로 내려줄 수 있다. =&gt; <code>컴포넌트 트리 == props의 폭포</code></li>\n</ul>\n<h1>Refs</h1>\n<p>일반적인 리액트 데이터 플로우에서 부모 컴포넌트와 자식 컴포넌트는 <code>props</code>를 통해서만 통신할 수 있어서 자식 컴포넌트를 수정하려면 새로운 <code>props</code>와 함께 다시 렌더링해야한다. 그럼 일반적인 데이터 플로우 밖에서 자식 컴포넌트(컴포넌트 인스턴스 or DOM)에 직접 접근하려면 어떻게 해야할까? <code>Refs</code>를 사용하면 되지만 공식문서에서는 Refs 보다는 state를 이용하기로 권장한다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomTextInput</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(props) {\n    <span class=\"hljs-keyword\">super</span>(props);\n    <span class=\"hljs-keyword\">this</span>.focusTextInput = <span class=\"hljs-keyword\">this</span>.focusTextInput.bind(<span class=\"hljs-keyword\">this</span>);\n  }\n\n  focusTextInput() {\n    <span class=\"hljs-comment\">// Explicitly focus the text input using the raw DOM API</span>\n    <span class=\"hljs-keyword\">this</span>.textInput.focus();\n  }\n\n  render() {\n    <span class=\"hljs-comment\">// Use the `ref` callback to store a reference to the text input DOM</span>\n    <span class=\"hljs-comment\">// element in an instance field (for example, this.textInput).</span>\n    <span class=\"hljs-keyword\">return</span> (\n      &lt;div&gt;\n        &lt;input\n          type=\"text\"\n          ref={(input) =&gt; { this.textInput = input; }} /&gt;\n        &lt;input\n          type=\"button\"\n          value=\"Focus the text input\"\n          onClick={this.focusTextInput}\n        /&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n</code></pre>\n<ul>\n<li>React는 컴포넌트가 마운트될 때 DOM 요소와 함께 ref 콜백을 호출하며 언마운트될 때 null 과 함께 호출한다. ref 콜백은 componentDidMount 나 componentDidUpdate 라이프사이클 훅 전에 호출된다.</li>\n<li>ref 속성을 HTML 요소에서 사용하면, ref 콜백은 기본 DOM 요소를 인수로 받는다.</li>\n</ul>\n<blockquote>\n<p>Refs는 언제 사용하면 좋을까?</p>\n<ul>\n<li>input/textarea 포커스 제어, 텍스트 선택, 미디어 재생을 관리할 때</li>\n<li>명령형 애니메이션을 발동시킬 때</li>\n<li>써드 파티 DOM 라이브러리를 통합할 때</li>\n</ul>\n</blockquote>\n","updatedAt":"2020-01-14T10:46:33.487Z"}