{"layout":"post-content","title":"운영체제 - 프로세스 동기화 2","date":"2020-01-14T00:00:00.000Z","tags":["os"],"categories":["operating-system"],"body":"<blockquote>\n<ol>\n<li>생산자-소비자 문제(Producer and Consumer Problem)</li>\n<li>독자-저자 문제(Readers-Writers Problem)</li>\n<li>식사하는 철학자 문제(Dining Philosopher Problem)</li>\n</ol>\n</blockquote>\n<h1>전통적 동기화(Classical Synchronization Problems)</h1>\n<h2>Producer and Consumer Problem</h2>\n<ul>\n<li>생산자-소비자 문제\n<ul>\n<li>생산자가 데이터를 생산하면 소비자는 그것을 소비</li>\n<li>예1: 컴파일러(생산자) &gt; 어셈블러(소비자)</li>\n<li>예2: 파일서버 &gt; 클라이언트</li>\n<li>예3: 웹 서버(html 생산함) -&gt; 웹 클라이언트(브라우저로 소비)</li>\n</ul>\n</li>\n<li>유한버퍼 문제 (Bounded Buffer Problem)\n<ul>\n<li>생산된 데이터는 버퍼에 일단 저장(속도 차이 등)</li>\n<li>현실 시스템에서 버퍼 크기는 유한</li>\n<li>생산자는 버퍼가 가득 차면 더 넣을 수 없다.</li>\n<li>소비자는 버퍼가 비면 뺄 수 없다.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>예시<br/>\n일반적으로 농작물 생산 속도와 소비 속도가 다르다. 현실적으로 바로 농산물을 소비자에게 주는 게 아니라 창고에 우선 저장한다. 저장된 여러 농작물을 소비자가 조금씩 빼먹고 생산자는 계속 생산해서 저장한다. 이 창고가 바로 <strong>버퍼</strong>다. 버퍼는 데이터를 저장할 수 있는 메모리 또는 디스크 공간으로 주로 메모리를 이용하긴 한다. 그런데 버퍼의 크기는 얼마나 될까? 현실 시스템에서 당연히 버퍼 크기는 유한하다. 컴퓨터에서 메모리가 한정적이니 당연한 얘기다.</p>\n</blockquote>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/****** 버퍼 ******/</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Buffer</span> </span>{\n  <span class=\"hljs-keyword\">int</span>[] buf;\n  <span class=\"hljs-keyword\">int</span> size;\n  <span class=\"hljs-keyword\">int</span> count;  <span class=\"hljs-comment\">// 버퍼의 현재 자원 크기</span>\n  <span class=\"hljs-keyword\">int</span> in; <span class=\"hljs-comment\">// 생산자 insert 할 버퍼의 위치</span>\n  <span class=\"hljs-keyword\">int</span> out;  <span class=\"hljs-comment\">// 소비자가 remove 할 버퍼의 위치</span>\n\n  Buffer(<span class=\"hljs-keyword\">int</span> size) {\n    buf = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[size];\n    <span class=\"hljs-keyword\">this</span>.size = size;\n    count = in = out = <span class=\"hljs-number\">0</span>;\n  }\n  <span class=\"hljs-comment\">// 생산자</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> item)</span> </span>{\n    <span class=\"hljs-comment\">/* check if buf is full */</span>\n    <span class=\"hljs-keyword\">while</span> (count == size)\n    ;\n    \n    buf[in] = item;\n    in = (in+<span class=\"hljs-number\">1</span>)%size; <span class=\"hljs-comment\">//circular</span>\n    count++; \n  }\n  <span class=\"hljs-comment\">// 소비자</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">/* check if buf is empty */</span>\n    <span class=\"hljs-keyword\">while</span> (count == <span class=\"hljs-number\">0</span>)\n    ;\n    \n    <span class=\"hljs-keyword\">int</span> item = buf[out];\n    out = (out+<span class=\"hljs-number\">1</span>)%size;\n    count--;\n    <span class=\"hljs-keyword\">return</span> item;    \n  }\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/****** 생산자 ******/</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Producer</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Thread</span> </span>{\n  Buffer b;\n  <span class=\"hljs-keyword\">int</span> N;\n  Producer(Buffer b, <span class=\"hljs-keyword\">int</span> N) {\n    <span class=\"hljs-keyword\">this</span>.b = b; <span class=\"hljs-keyword\">this</span>.N = N;\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;N; i++)\n    b.insert(i);\n  }\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/****** 소비자 ******/</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Consumer</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Thread</span> </span>{\n  Buffer b;\n  <span class=\"hljs-keyword\">int</span> N;\n  Consumer(Buffer b, <span class=\"hljs-keyword\">int</span> N) {\n    <span class=\"hljs-keyword\">this</span>.b = b; <span class=\"hljs-keyword\">this</span>.N = N;\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">int</span> item;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;N; i++)\n    item = b.remove();\n  }\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/****** 메인 ******/</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] arg)</span> </span>{\n    Buffer b = <span class=\"hljs-keyword\">new</span> Buffer(<span class=\"hljs-number\">100</span>);\n    Producer p = <span class=\"hljs-keyword\">new</span> Producer(b, <span class=\"hljs-number\">10000</span>);\n    Consumer c = <span class=\"hljs-keyword\">new</span> Consumer(b, <span class=\"hljs-number\">10000</span>);\n    p.start();\n    c.start();\n    <span class=\"hljs-keyword\">try</span> {\n      p.join();\n      c.join();\n    } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {}\n      System.out.println(<span class=\"hljs-string\">\"Number of items in the buf is \"</span> + b.count);\n  }\n}\n</code></pre>\n<ul>\n<li>위 코드는 잘못된 결과가 나온다.\n<ul>\n<li><code>실행 불가</code> 또는 <code>count != 0</code> (생산된 항목 숫자 != 소비자 항목 숫자)</li>\n<li>최종적으로 버퍼 내에는 0개의 항목이 있어야 한다.</li>\n</ul>\n</li>\n<li>원인은 무엇일까?\n<ul>\n<li>공통변수 count, buf[]에 대한 동시 업데이트 때문이다.</li>\n<li>공통 변수 업데이트 구간(=임계구역)에 대한 동시 진입한다.</li>\n</ul>\n</li>\n<li>어떻게 해결하지?\n<ul>\n<li><span class=\"clr-note\">임계구역에 대한 동시 접근 방지(상호배타)하기</span></li>\n<li>세마포를 사용한 상호배타 (mutual exclusion) 하기</li>\n<li>세마포: mutex.value = 1 (# of permit)</li>\n</ul>\n</li>\n</ul>\n<br/>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/****** 버퍼 ******/</span>\n<span class=\"hljs-keyword\">import</span> java.util.concurrent.Semaphore;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Buffer</span> </span>{\n  <span class=\"hljs-keyword\">int</span>[] buf;\n  <span class=\"hljs-keyword\">int</span> size;\n  <span class=\"hljs-keyword\">int</span> count;  <span class=\"hljs-comment\">// 버퍼의 현재 자원 크기</span>\n  <span class=\"hljs-keyword\">int</span> in; <span class=\"hljs-comment\">// 생산자 insert 할 버퍼의 위치</span>\n  <span class=\"hljs-keyword\">int</span> out;  <span class=\"hljs-comment\">// 소비자가 remove 할 버퍼의 위치</span>\n  Semaphore mutex;\n\n  Buffer(<span class=\"hljs-keyword\">int</span> size) {\n    buf = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[size];\n    <span class=\"hljs-keyword\">this</span>.size = size;\n    count = in = out = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">this</span>.mutex = <span class=\"hljs-keyword\">new</span> Semaphore(<span class=\"hljs-number\">1</span>);\n  }\n  <span class=\"hljs-comment\">// 생산자</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> item)</span> </span>{\n    <span class=\"hljs-comment\">/* check if buf is full */</span>\n    <span class=\"hljs-keyword\">while</span> (count == size)\n    ;\n    <span class=\"hljs-keyword\">try</span> {\n      mutex.acquire();\n      <span class=\"hljs-comment\">/****** S : 임계구역 *****/</span>\n      buf[in] = item;\n      in = (in+<span class=\"hljs-number\">1</span>)%size; <span class=\"hljs-comment\">//circular</span>\n      count++;\n      <span class=\"hljs-comment\">/****** E : 임계구역 *****/</span>    \n    } <span class=\"hljs-keyword\">catch</span>(InterruptedException) {}    \n    mutex.release();\n  }\n  <span class=\"hljs-comment\">// 소비자</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">/* check if buf is empty */</span>\n    <span class=\"hljs-keyword\">while</span> (count == <span class=\"hljs-number\">0</span>)\n    ;\n    <span class=\"hljs-keyword\">try</span> {\n      mutex.acquire();\n      <span class=\"hljs-comment\">/****** S : 임계구역 *****/</span>\n      <span class=\"hljs-keyword\">int</span> item = buf[out];\n      out = (out+<span class=\"hljs-number\">1</span>)%size;\n      count--;\n      <span class=\"hljs-keyword\">return</span> item;\n      <span class=\"hljs-comment\">/****** E : 임계구역 *****/</span>\n    } <span class=\"hljs-keyword\">catch</span>(InterruptedException) {}    \n    mutex.release();\n    <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n  }\n}\n</code></pre>\n<p><br/><br/></p>\n<ul>\n<li>하지만 또! <code>Busy-wait</code> 라는 문제가 있다.\n<ul>\n<li>insert의 <code>while (count == size);</code>와 remove의 <code>while (count == 0);</code> 로 인해 반복문에 붙잡히는 경우가 생긴다. cpu가 딴 일 못하고 붙잡힌다.</li>\n<li>생산자: 버퍼가 가득 차면 기다려야 = 빈(empty) 공간이 있어야 한다.</li>\n<li>소비자: 버퍼가 비면 기다려야 = 찬(full) 공간이 있어야 한다.</li>\n</ul>\n</li>\n<li>어떻게 해결하지?\n<ul>\n<li>무한루프가 아니라 아예 감옥에 가둬버리자!</li>\n<li>세마포를 사용한 busy-wait 회피</li>\n<li>생산자: empty.acquire() // # of permit = BUF_SIZE</li>\n<li>소비자: full.acquire() // # of permit = 0</li>\n</ul>\n</li>\n</ul>\n<br/>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/****** 버퍼 ******/</span>\n<span class=\"hljs-keyword\">import</span> java.util.concurrent.Semaphore;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Buffer</span> </span>{\n  <span class=\"hljs-keyword\">int</span>[] buf;\n  <span class=\"hljs-keyword\">int</span> size;\n  <span class=\"hljs-keyword\">int</span> count;  <span class=\"hljs-comment\">// 버퍼의 현재 자원 크기</span>\n  <span class=\"hljs-keyword\">int</span> in; <span class=\"hljs-comment\">// 생산자 insert 할 버퍼의 위치</span>\n  <span class=\"hljs-keyword\">int</span> out;  <span class=\"hljs-comment\">// 소비자가 remove 할 버퍼의 위치</span>\n  Semaphore mutex;   <span class=\"hljs-comment\">// 임계구역에 1개만 들어가게 하려고</span>\n  Semaphore empty;\n  Semaphore full;\n\n  Buffer(<span class=\"hljs-keyword\">int</span> size) {\n    buf = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[size];\n    <span class=\"hljs-keyword\">this</span>.size = size;\n    count = in = out = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">this</span>.mutex = <span class=\"hljs-keyword\">new</span> Semaphore(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-keyword\">this</span>.empty = <span class=\"hljs-keyword\">new</span> Semaphore(size);\n    <span class=\"hljs-keyword\">this</span>.full = <span class=\"hljs-keyword\">new</span> Semaphore(<span class=\"hljs-number\">0</span>);\n  }\n  <span class=\"hljs-comment\">// 생산자</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> item)</span> </span>{\n    <span class=\"hljs-comment\">/* check if buf is full */</span>\n    <span class=\"hljs-keyword\">while</span> (count == size)\n    ;\n    <span class=\"hljs-keyword\">try</span> {\n      empty.acuire();\n      mutex.acquire();\n      <span class=\"hljs-comment\">/****** S : 임계구역 *****/</span>\n      buf[in] = item;\n      in = (in+<span class=\"hljs-number\">1</span>)%size; <span class=\"hljs-comment\">//circular</span>\n      count++;\n      <span class=\"hljs-comment\">/****** E : 임계구역 *****/</span>    \n    } <span class=\"hljs-keyword\">catch</span>(InterruptedException) {}    \n    mutex.release();\n    full.release();\n  }\n  <span class=\"hljs-comment\">// 소비자</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">/* check if buf is empty */</span>\n    <span class=\"hljs-keyword\">while</span> (count == <span class=\"hljs-number\">0</span>)\n    ;\n    <span class=\"hljs-keyword\">try</span> {\n      full.acquire();\n      mutex.acquire();\n      <span class=\"hljs-comment\">/****** S : 임계구역 *****/</span>\n      <span class=\"hljs-keyword\">int</span> item = buf[out];\n      out = (out+<span class=\"hljs-number\">1</span>)%size;\n      count--;\n      <span class=\"hljs-keyword\">return</span> item;\n      <span class=\"hljs-comment\">/****** E : 임계구역 *****/</span>\n    } <span class=\"hljs-keyword\">catch</span>(InterruptedException) {}    \n    mutex.release();\n    empty.release();\n    <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n  }\n}\n</code></pre>\n<h2>Readers-Writers Problem</h2>\n<ul>\n<li>공통 데이터베이스\n<ul>\n<li>Readers: read data, never modify it</li>\n<li>Writers: read data and modifiy it</li>\n<li>상호배타: 한 번에 한 개의 프로세스만 접근하는 것 효율성이 안 좋다.</li>\n</ul>\n</li>\n<li>효율성을 높이려면?\n<ul>\n<li>데이터베이스 읽고 쓰기는 임계 구역 안에서 발생한다.</li>\n<li>그러므로 Writers은 당연히 상호 배타 해야한다.</li>\n<li>그러나 Reader1이 DB 읽고 있으면 Reader2도 읽을 수 있게 해줘야 효율성에 좋다!</li>\n</ul>\n</li>\n<li>변종\n<ul>\n<li>The first R/W problem (readers-preference) : 항상 readers에게 우선권을 주는 것. 예) 현재 Reader1이 DB를 읽고 있다고 가정해보자. Writer1의 경우는 상호 배타되어서 접근할 수 없다. 잠시 후 Reader2가 접근하면 Reader2는 늦게 왔음에도 불구하고 DB에 접근할 수 있다.</li>\n<li>The second R/W problem (writers-preference) : writers에게 우선권 주는 것</li>\n<li>The Third R/W problem : 우선권 아예 안 주는 것</li>\n</ul>\n</li>\n</ul>\n<h2>Dining Philosopher Problem</h2>\n<p><img src=\"/assets/images/2020-01-14-img/1.png\" alt=\"process tree\"><br/></p>\n<blockquote>\n<p>5명의 철학자가 원탁에 앉아 있고 각자의 앞에는 스파게티가 있다. 그리고 양 옆에는 젓가락이 하나씩 있다. 각각의 철학자는 스파게티를 먹으려면 젓가락을 2개를 사용해야 하며, 다른 철학자에게 말을 걸 수 없고 젓가락을 빼앗을 수도 없다.\n<br/><br/> 이제 5명의 철학자 모두가 갑자기 배가 고파서 동시에 왼쪽 젓가락을 집어든다고 생각해보자. 철학자들은 젓가락을 공유할 수 없고 자신의 오른쪽에 앉은 철학자가 젓가락을 놓을 때까지 기다린다. 오른쪽 젓가락을 빼앗을 방법도 없어서 철학자들의 계속 대기만 한다…</p>\n</blockquote>\n<ul>\n<li>식사하는 철학자 문제\n<ul>\n<li>5명의 철학자, 5개의 젓가락, 생각 → 식사 → 생각 → 식사</li>\n<li>식사하려면 2개의 젓가락 필요</li>\n</ul>\n</li>\n<li>프로그래밍\n<ul>\n<li>젓가락: 세마포 (# of permit = 1) -&gt; 젓가락을 기준으로 2명 중 1명만 사용할 수 있으니깐 1로 한다.</li>\n<li>젓가락과 세마포에 일련번호: 0 ~ 4</li>\n<li>왼쪽 젓가락 → 오른쪽 젓가락</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/*********철학자*********/</span>\n<span class=\"hljs-keyword\">import</span> java.util.concurrent.Semaphore;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Philosopher</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Thread</span> </span>{\n  <span class=\"hljs-keyword\">int</span> id; <span class=\"hljs-comment\">// philosopher id</span>\n  Semaphore lstick, rstick; <span class=\"hljs-comment\">// left, right chopsticks</span>\n  Philosopher(<span class=\"hljs-keyword\">int</span> id, Semaphore lstick, Semaphore rstick) {\n    <span class=\"hljs-keyword\">this</span>.id = id;\n    <span class=\"hljs-keyword\">this</span>.lstick = lstick;\n    <span class=\"hljs-keyword\">this</span>.rstick = rstick;\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">try</span> {\n      <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-keyword\">true</span>) {\n        lstick.acquire();\n        rstick.acquire();\n        eating();\n        lstick.release();\n        rstick.release();\n        thinking();\n      }\n    }<span class=\"hljs-keyword\">catch</span> (InterruptedException e) { }\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">eating</span><span class=\"hljs-params\">()</span> </span>{\n    System.out.println(<span class=\"hljs-string\">\"[\"</span> + id + <span class=\"hljs-string\">\"] eating\"</span>);\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">thinking</span><span class=\"hljs-params\">()</span> </span>{\n    System.out.println(<span class=\"hljs-string\">\"[\"</span> + id + <span class=\"hljs-string\">\"] thinking\"</span>);\n  }\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/*********메인*********/</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>{\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> num = <span class=\"hljs-number\">5</span>; <span class=\"hljs-comment\">// number of philosphers &amp; chopsticks</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n    <span class=\"hljs-keyword\">int</span> i;\n    <span class=\"hljs-comment\">/* chopsticks */</span>\n    Semaphore[] stick = <span class=\"hljs-keyword\">new</span> Semaphore[num];\n    <span class=\"hljs-keyword\">for</span> (i=<span class=\"hljs-number\">0</span>; i&lt;num; i++)\n      stick[i] = <span class=\"hljs-keyword\">new</span> Semaphore(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-comment\">/* philosophers */</span>\n    Philosopher[] phil = <span class=\"hljs-keyword\">new</span> Philosopher[num];\n    <span class=\"hljs-keyword\">for</span> (i=<span class=\"hljs-number\">0</span>; i&lt;num; i++)\n      phil[i] = <span class=\"hljs-keyword\">new</span> Philosopher(i, stick[i], stick[(i+<span class=\"hljs-number\">1</span>)%num]);\n    <span class=\"hljs-comment\">/* let philosophers eat and think */</span>\n    <span class=\"hljs-keyword\">for</span> (i=<span class=\"hljs-number\">0</span>; i&lt;num; i++)\n      phil[i].start();\n  }\n}\n</code></pre>\n<ul>\n<li>위 코드는 프로그램이 돌다가 멈춘다… 왜!!!\n<ul>\n<li>잘못된 결과: starvation -&gt; 모든 철학자가 식사를 하지 못해 굶어 죽는 상황</li>\n<li>이유 = <span class=\"clr-note\">교착상태 (deadlock)</span></li>\n</ul>\n</li>\n</ul>\n","updatedAt":"2020-01-22T18:18:24.657Z"}