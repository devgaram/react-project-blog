{"layout":"post-content","title":"안드로이드 LiveData 대해 알아보자","date":"2019-01-09T00:00:00.000Z","tags":["android","livedata","mvvm"],"category":["android"],"body":"<p>LiveData 클래스를 통해 데이터 변경을 감지해보자.</p>\n<hr>\n<p><a href=\"https://developer.android.com/topic/libraries/architecture/livedata#java\">안드로이드 개발문서-LiveData</a>.</p>\n<h1>LiveData는 LifecycleOwner의 라이프사이클을 알고있다.</h1>\n<p>LiveData 객체는 <code class=\"codetainer\">observe()</code> 메서드를 통해 <code class=\"codetainer\">LifecycleOwner</code>와 <code class=\"codetainer\">Observer</code>객체를 페어로 등록한다.<br>\nObserver 객체는 페어인 LifecycleOwner가 활성상태(<code class=\"codetainer\">STARTED</code> 또는 <code class=\"codetainer\">RESUMED</code>)일 때, 데이터 변화을 관측할 수 있다.\n반대로, LiveData 객체는 LifecycleOwner가 비활성 상태면 LiveData의 변화를 Observer에게 전달하지 않으며, LifecycleOwner가 <code class=\"codetainer\">DESTROYED</code> 상태라면 자동으로 제거된다.\n이러한 LiveData의 라이프사이클의 인지는 메모리 누수에 대한 걱정을 덜어주며, UI 컴포넌트(액티비티, 프래그먼트)를 사용할 때 유용하다.<br>\n<span class=\"clr-grey\"><strong>Note:</strong> LifecycleOwner의 비활성 상태 예시) 액티비티가 백 스택에 올라가있을 때 </span></p>\n<h1>LiveData 사용시 이점</h1>\n<p><span class=\"li-icon\">일반적인 Observable과 달리, LifecycleOwner가 활성 상태일 때, LiveData의 변화를 Observer 객체에 전달함</span>\n<span class=\"li-icon\">충돌방지 : 액티비티가 백스택(비활성)에 있을 때, LiveData의 변화 이벤트를 Observer에게 전달하지 않음</span>\n<span class=\"li-icon\">메모리누수방지 : <code class=\"codetainer\">DESTROYED</code> 시, LiveData 제거</span>\n<span class=\"li-icon\">생명주기 수동으로 관리할 필요 없음</span>\n<span class=\"li-icon\">항상 최신 데이터 유지 가능 : 액티비티가 다시 활성상태로 돌아온 즉시 최신 데이터를 받는다.</span>\n<span class=\"li-icon\">환경변화(예,화면회전)로 UI 컴포넌트 재생성 시, 즉시 최신 데이터를 받는다.</span>\n<span class=\"li-icon\">LiveData를 상속받아 앱에서 자원 공유 가능</span></p>\n<h1>LiveData 사용하기</h1>\n<p><a href=\"/android/android-mvvm/#LiveData\">예제로 바로가기</a>.</p>\n<h2>1. LiveData 객체 생성하기</h2>\n<p>LiveData는 보통 <code class=\"codetainer\">Collections</code> 인터페이스를 구현한 클래스(List, Map, Set)를 사용하며, <code class=\"codetainer\">ViewMoodel</code> 객체 안에 저장된다.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NameViewModel</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ViewModel</span> </span>{\n  <span class=\"hljs-comment\">// String 타입의 LiveData 생성</span>\n  <span class=\"hljs-keyword\">private</span> MutableLiveData&lt;String&gt; mCurrentName;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> MutableLiveData&lt;String&gt; <span class=\"hljs-title\">getCurrentName</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (mCurrentName == <span class=\"hljs-keyword\">null</span>) {\n            mCurrentName = <span class=\"hljs-keyword\">new</span> MutableLiveData&lt;String&gt;();\n        }\n        <span class=\"hljs-keyword\">return</span> mCurrentName;\n    }\n\n<span class=\"hljs-comment\">// ..생략</span>\n}\n</code></pre>\n<h2>2. LiveData 객체 관찰하기</h2>\n<p><code class=\"codetainer\">onCreate()</code> 메서드에서 LiveData 관찰을 시작하는 것이 좋다.\n<span class=\"li-icon\"><code class=\"codetainer\">onResume()</code> 메서드에서 사용 시 중복 호출이 발생된다.</span>\n<span class=\"li-icon\"><code class=\"codetainer\">STARTED</code> 상태가 되자마자 LiveData 객체의 최신 데이터를 받을 수 있다.</span></p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NameActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AppCompatActivity</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> NameViewModel mModel;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCreate</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>.onCreate(savedInstanceState);\n\n        <span class=\"hljs-comment\">// ..생략</span>\n\n        <span class=\"hljs-comment\">// ViewModel 얻기</span>\n        mModel = ViewModelProviders.of(<span class=\"hljs-keyword\">this</span>).get(NameViewModel<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n\n\n        <span class=\"hljs-comment\">// 옵저버 생성</span>\n        <span class=\"hljs-keyword\">final</span> Observer&lt;String&gt; nameObserver = <span class=\"hljs-keyword\">new</span> Observer&lt;String&gt;() {\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onChanged</span><span class=\"hljs-params\">(@Nullable <span class=\"hljs-keyword\">final</span> String newName)</span> </span>{\n                <span class=\"hljs-comment\">// Update the UI, in this case, a TextView.</span>\n                mNameTextView.setText(newName);\n            }\n        };\n\n        <span class=\"hljs-comment\">// LiveData 관찰 시작</span>\n        mModel.getCurrentName().observe(<span class=\"hljs-keyword\">this</span>, nameObserver);\n    }\n}\n</code></pre>\n<h2>3. LiveData 객체 업데이트하기</h2>\n<p>LiveData는 데이터를 업데이트 하는 publid 메서드를 가지고 있지 않으므로, LiveData를 상속받은 <code class=\"codetainer\">MutableLiveData</code>를 사용해야한다.\n<code class=\"codetainer\">MutableLiveData</code>는 <code class=\"codetainer\">public setValue(T)</code>와 <code class=\"codetainer\">public postValue(T)</code> 메서드를 가지고 있어서 이를 통해 데이터를 변경할 수 있다.</p>\n<pre><code class=\"language-java\">mButton.setOnClickListener(<span class=\"hljs-keyword\">new</span> OnClickListener() {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onClick</span><span class=\"hljs-params\">(View v)</span> </span>{\n        String anotherName = <span class=\"hljs-string\">\"John Doe\"</span>;\n        mModel.getCurrentName().setValue(anotherName);\n    }\n});\n</code></pre>\n<p><code class=\"codetainer\">setValue(T)</code>와 <code class=\"codetainer\">postValue(T)</code>는 호출 시 Observer의 <code class=\"codetainer\">onChanged()</code> 메서드가 호출되어 UI가 업데이트 된다.</p>\n","updatedAt":"2020-01-22T18:23:54.171Z"}