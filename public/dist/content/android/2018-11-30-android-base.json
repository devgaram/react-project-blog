{"layout":"post-content","title":"(안드로이드) 시작하기 앞서 기초 학습","date":"2018-11-30T00:00:00.000Z","tags":["android"],"category":["android"],"body":"<p>안드로이드 학습을 시작하기 전에 간단히 자바 기본 개념을 정리했습니다.</p>\n<h1>안드로이드 기초</h1>\n<hr>\n<h2>안드로이드 4대 구성요소</h2>\n<ul>\n<li>액티비티<br>\n화면 하나당 하나의 액티비티 가짐. 여러개의 액티비티 중 하나가 메인 액티비티가 되며 manifest에 정의된다.</li>\n<li>리시버<br>\n전화&amp;문자 수신, 배터리 부족 등의 브로드캐스트를 수신하는 객체</li>\n<li>프로바이더<br>\n데이터베이스나 파일 등의 정보를 외부의 앱에 공개하기 위한 객체. ContentProvider 클래스를 상속받아 구현</li>\n<li>서비스<br>\n백그라운드(음악재생, 파일다운로드)에서 오래 수행되어야 하는 앱. 화면 없음</li>\n</ul>\n<h2>액티비티끼리 데이터를 주고받는 과정</h2>\n<ol>\n<li>A 액티비티에서 startActivityForResult()로 B 액티비티 시작</li>\n<li>B 액티비티에서 setResult()로 결과를 A 액티비티로 전달</li>\n<li>A 액티비티의 onActivityResult()에서 B 액티비티에서 전달받은 데이터 처리</li>\n</ol>\n<h1>자바 기초 개념</h1>\n<hr>\n<h2>자바 상속과 인터페이스 개념 정리 <a href=\"http://nyebo.net/2016/01/just-java-summary/\">출처</a></h2>\n<ol>\n<li>상속</li>\n</ol>\n<ul>\n<li>어떤 클래스보다 내용이 구체적인 새로운 클래스가 필요할 때 기존 클래스에서 물려받아 새로운 부분만 추가하거나 수정하려고 만든 개념이다.</li>\n<li>상속을 이용하면 슈퍼 클래스(부모)의 필드, 메서드를 상속받으며 서브 클래스(자식)에서 자신만의 필드나 메서드를 추가하여 구체화할 수 있다.\n물론 상속받은 메서드를 재정의(오버라이딩)하는 것도 가능하다.</li>\n<li>상속은 클래스를 선언할 때 extends 키워드를 사용하여 정의한다.</li>\n<li>다른 객체지향 언어와 달리 다중 상속을 지원하지 않는다.</li>\n<li>다형성 : 슈퍼클래스가 같은 서브 클래스들이 동일한 요청(메서드)을 다르게 처리할 수 있는 특징을 말한다. 메서드를 오버라이딩(재정의)하여 구현한다.</li>\n</ul>\n<ol start=\"2\">\n<li>클래스의 기본 구조</li>\n</ol>\n<ul>\n<li>패키지 : 자바 클래스들을 같은 성격으로 묶어서 관리하는 디렉토리 개념</li>\n<li>클래스 : 자바 프로그램의 기본 단위</li>\n<li>인스턴스 : 객체지향개념에 따라 클래스는 바로 사용할 수 없고 인스턴스로 사용해야한다. 인스턴스를 이용하여 메서드 호출 등 필요한 작업을 처리한다.</li>\n<li>생성자 : 클래스를 생성할 때 제일 먼저 실행되는 특수한 형태의 메서드, 리턴값이 없으며(데이터형 입력하면 안됨) 메서드 이름은 반드시 클래스 이름과 일치해야 한다.</li>\n</ul>\n<ol start=\"3\">\n<li>접근 한정자의 종류와 접근 범위</li>\n</ol>\n<ul>\n<li>public : 클래스 내부, 동일 패키지, 하위클래스, 그 외의 영역에서 접근 가능</li>\n<li>protected : 클래스 내부, 동일 패키지, 하위클래스에서 접근 가능</li>\n<li>default : 클래스 내부, 동일 패키지에서 접근 가능</li>\n<li>private : 클래스 내부에서만 접근 가능</li>\n</ul>\n<ol start=\"4\">\n<li>일반 한정자의 종류</li>\n</ol>\n<ul>\n<li>static : 클래스 메서드와 클래스 변수를 선언하는 데 사용한다.\n자바의 정적 영역에 할당되는 리소스를 선언하는 데 사용.\n동일한 가상머신 상에서 실행 중인 모든 클래스에서 공유한다.\n인스턴스를 생성하지 않고도 클래스의 메서드나 멤버에 접근할 수 있다.</li>\n<li>final : 더 이상 변경할 수 없도록 선언하는 한정자. 클래스에서 사용하면 서브 클래스를 만들 수 없다. 메서드에서 사용하면 오버라이딩을 할 수 없다.\n변수에 사용하면 저장된 값은 변할 수 없으므로 상수의 역할을 한다.</li>\n<li>abstract : 추상 클래스를 선언하는 데 사용하는 한정사</li>\n</ul>\n<ol start=\"5\">\n<li>인스턴스 변수와 클래스 변수</li>\n</ol>\n<ul>\n<li>인스턴스 변수는 클래스의 인스턴스로만 접근 가능한 변수(일반적인 멤버 변수), 클래스 외부에서 접근 차단하려고 private 키워드를 사용하기도 함.</li>\n<li>동일 클래스의 인스턴스라 해도 각 인스턴스의 변수는 값이 서로 다르고 서로에 영향을 주지 않는다.</li>\n<li>클래스 변수는 모든 클래스의 인스턴스로 공유되는 변수, static 키워드를 사용하여 선언한다.</li>\n</ul>\n<ol start=\"6\">\n<li>자바 가상머신의 메모리 구조</li>\n</ol>\n<ul>\n<li>Heap 영역 : 자바 객체, 인스턴스 변수</li>\n<li>Stack 영역 : 메서드 파라미터, 지역 변수</li>\n<li>Method 영역 : 메서드 바이트 코드, 클래스(static) 변수</li>\n</ul>\n<ol start=\"7\">\n<li>추상 클래스와 인터페이스</li>\n</ol>\n<ul>\n<li>추상클래스\n<ul>\n<li>추상 메서드(정의만 한 메서드)를 하나 이상 포함한다, 추상 메서드가 포함된 클래스는 반드시 추상 클래스로 정의해야 한다.</li>\n<li>그 자체를 인스턴스화(객체 생성)에 사용할 수 없다. 추상 클래스를 상속받는 클래스를 만든 후 추상클래스에 선언된 모든 추상 메서드를 오버라이딩해서 구현해야 한다.</li>\n</ul>\n</li>\n</ul>\n<ol start=\"8\">\n<li>인터페이스</li>\n</ol>\n<ul>\n<li>모두 추상 메서드로만 구성해야 한다.</li>\n<li>일반 멤버 필드는 없고, public, static, final로 선언한 상수만 있다.</li>\n<li>그 자체를 인스턴스화(객체 생성) 불가. 다른 클래스로 구현할 때는 implements 키워드로 구현을 선언해야한다.</li>\n<li>다중 상속 개념 지원하는 형태로 사용 가능</li>\n</ul>\n<ol start=\"9\">\n<li>캡슐화</li>\n</ol>\n<ul>\n<li>외부에서 변수에 직접 접근할 수 없도록 하는 객체지향 프로그래밍 방법이다.</li>\n<li>캡슐화된 변수에 접근하려면 getter, setter 메서드를 만들어서 접근해야한다.</li>\n</ul>\n","updatedAt":"2020-01-22T18:23:44.561Z"}