{"layout":"post-content","title":"(안드로이드) fragment를 사용하자","date":"2018-12-07T00:00:00.000Z","tags":["android"],"category":["android"],"body":"<p>[될 때까지 안드로이드]의 fragment 파트를 정리한 내용입니다.</p>\n<p><a href=\"https://github.com/devgaram/androidExample/tree/master/fragmentexam\">기본 프래그먼트 구현 예제</a>.<br>\n<a href=\"https://github.com/devgaram/androidExample/tree/master/exitdialogfragment\">다이얼로그 프래그먼트 구현 예제</a>.<br>\n<a href=\"https://github.com/devgaram/androidExample/tree/master/callbackexam\">콜백 구현 예제</a>.</p>\n<p>여러 개의 프래그먼트를 하나의 액티비티에 조합하여 창이 여러 개인 UI를 구축할 때 사용할 수 있다.</p>\n<ul>\n<li>하나의 프래그먼트를 여러 액티비티에서 재사용할 수 있으며,동적으로 추가, 삭제, 교체가 쉽다.</li>\n<li>프래그먼트는 자체 수명 주기를 가진다.</li>\n<li>프래그먼트는 부모-자식 관계를 가질 수 있다.</li>\n</ul>\n<hr>\n<h1>생명주기 (소속 액티비티가 실행 중일 때)</h1>\n<p>최소한 다음과 같은 수명 주기 메서드를 구현해야한다.</p>\n<p><strong>onCreate()</strong><br>\n프래그먼트를 생성할 때 호출되는 콜백 메서드<br>\n프래그먼트가 일시정지되거나 중지되었다가 재개되었을 때 유지하고자 하는 것을 초기화하는 부분</p>\n<p><strong>onCreateView()</strong><br>\n액티비티는 <code class=\"codetainer\">onCreate()</code> 콜백 메서드에서 <code class=\"codetainer\">setContentView()</code> 메서드를 호출하여 View 객체(레이아웃)을 가져온다.<br>\n프래그먼트는 <code class=\"codetainer\">onCreateView()</code> 콜백 메서드에서 LayoutInflater를 통해 레이아웃을 가져온다.</p>\n<p><strong>onPause()</strong><br>\n시스템이 이 메서드를 호출하는 것은 사용자가 프래그먼트를 떠난다는 첫 번째 신호.<br>\n현재 사용자 세션을 넘어서 지속되어야 하는 변경 사항을 저장하는 부분</p>\n<p>프래그먼트 추가<br>\nonAttach() -&gt; onCreate() -&gt; onCreateView() -&gt; onActivityCreated() -&gt; onStart() -&gt; onResume()</p>\n<p>프래그먼트 소멸<br>\nonPause() -&gt; onStop() -&gt; onDestroyView() -&gt; onDestroy() -&gt; onDetach()</p>\n<h1>실습</h1>\n<h2>프래그먼트의 생성자</h2>\n<p>생성자를 오버로드할 수 없으며, 생성자를 통해 파라미터 전달을 금지하고 있다.<br>\n재생성 시에 정보를 자동으로 저장 및 복원하기 위한 설계가 이미 되어 있고 그것을 따르기 위한 제약이다.\n프래그먼트의 생성과 동시에 파라미터를 전달하는 방법은 <strong>Bundle 객체</strong>를 활용한다.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ColorFragment</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Fragment</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ColorFragment</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// Required empty public constructor</span>\n    }\n    \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> View <span class=\"hljs-title\">onCreateView</span><span class=\"hljs-params\">(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState)</span> </span>{\n        <span class=\"hljs-comment\">// Inflate the layout for this fragment</span>\n        <span class=\"hljs-keyword\">return</span> inflater.inflate(R.layout.fragment_color, container, <span class=\"hljs-keyword\">false</span>);\n    }\n}\n</code></pre>\n<h2>프래그먼트 매니저</h2>\n<p>프래그먼트 조작을 위해 프래그먼트 매니저가 필요하다.<br>\n프래그먼트 매니저는 액티비티 처럼 백스택을 가지고 있음.</p>\n<ul>\n<li>액티비티 내 XML에 포함된 프래그먼트를 <code class=\"codetainer\">findFragmentById()</code> 메서드로 가져오기 또는 <code class=\"codetainer\">findFragmentByTag()</code>로 가져오기</li>\n<li>액티비티 백스택에서 프래그먼트를 <code class=\"codetainer\">popBackStack()</code>메서드로 빠져나오게 하여 액티비티의 뒤로 가기와 같은 효과를 냄 ( <code class=\"codetainer\">addToBackStack()</code> : 프래그먼트 매니저의 백스택에 프래그먼트 추가하는 메서드 )</li>\n</ul>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AppCompatActivity</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCreate</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span> </span>{\n      ...생략...\n        FragmentManager fragmentManager = getSupportFragmentManager();\n        ColorFragment colorFragment = (ColorFragment) fragmentManager.findFragmentById(R.id.color_fragment);\n        colorFragment.setColor(Color.BLUE);\n    }\n}\n</code></pre>\n<h2>프래그먼트에서 액티비티에 접근하는 방법</h2>\n<pre><code class=\"language-java\">View listView = getActivity().findViewById(R.id.list);\n</code></pre>\n<h2>프래그먼트 교체, 삭제, 추가</h2>\n<p>프래그먼트를 교체하기 위해서는 &lt;fragment<fragment>&gt;를 &lt;FrameLayout<FrameLayout>&gt;과 같은 레이아웃으로 감싸줘야한다.<br>\n<strong>프래그먼트 트랜지션 수행</strong> add(), remove(), replace() 같은 메서드를 사용하고 commit()을 수행하면 트랜지션이 적용된다.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AppCompatActivity</span> </span>{\n\n  ...생략....\n  \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">change</span><span class=\"hljs-params\">(View view)</span> </span>{\n        ColorFragment fragment = <span class=\"hljs-keyword\">new</span> ColorFragment();\n        <span class=\"hljs-keyword\">int</span> red = <span class=\"hljs-keyword\">new</span> Random().nextInt(<span class=\"hljs-number\">256</span>);\n        <span class=\"hljs-keyword\">int</span> green = <span class=\"hljs-keyword\">new</span> Random().nextInt(<span class=\"hljs-number\">256</span>);\n        <span class=\"hljs-keyword\">int</span> blue = <span class=\"hljs-keyword\">new</span> Random().nextInt(<span class=\"hljs-number\">256</span>);\n        fragment.setColor(Color.rgb(red, green, blue));\n        getSupportFragmentManager()\n                .beginTransaction()\n                .replace(R.id.container, fragment)\n                .commit();\n    }\n}\n</code></pre>\n<h2>프래그먼트와 액티비티 간의 통신</h2>\n<p>일반적으로 액티비티에서 프래그먼트나 다른 뷰들의 인스턴스를 가지고 있어서 이들의 메서드를 호출하는 식이다. 따라서 프래그먼트의 상태가 변했을 때 액티비티에서 이것을 알아차리려면 계속해서 프래그먼트의 상태 값을 알아내는 메서드를 호출해야한다.</p>\n<p>그러나 콜백 인터페이스를 사용하여 프래그먼트의 상태가 변할 때마다 자동으로 액티비티에게 알려줄 수 있다.\nButton의 <code class=\"codetainer\">onClick()</code> 이벤트나 액티비티의 <code class=\"codetainer\">onCreate()</code>가 대표적인 콜백 메서드이며, 호출자 입장에서는 피호출자의 변화를 감시하다가 알아채기 때문에 리스너(Listener) 라고도 불른다.</p>\n","updatedAt":"2020-01-22T18:23:44.568Z"}