[
	{
		"layout": "post-content",
		"title": "(안드로이드) 시작하기 앞서 기초 학습",
		"date": "2018-11-30T00:00:00.000Z",
		"tags": [
			"android"
		],
		"category": [
			"android"
		],
		"body": "<p>안드로이드 학습을 시작하기 전에 간단히 자바 기본 개념을 정리했습니다.</p>\n<h1>안드로이드 기초</h1>\n<hr>\n<h2>안드로이드 4대 구성요소</h2>\n<ul>\n<li>액티비티<br>\n화면 하나당 하나의 액티비티 가짐. 여러개의 액티비티 중 하나가 메인 액티비티가 되며 manifest에 정의된다.</li>\n<li>리시버<br>\n전화&amp;문자 수신, 배터리 부족 등의 브로드캐스트를 수신하는 객체</li>\n<li>프로바이더<br>\n데이터베이스나 파일 등의 정보를 외부의 앱에 공개하기 위한 객체. ContentProvider 클래스를 상속받아 구현</li>\n<li>서비스<br>\n백그라운드(음악재생, 파일다운로드)에서 오래 수행되어야 하는 앱. 화면 없음</li>\n</ul>\n<h2>액티비티끼리 데이터를 주고받는 과정</h2>\n<ol>\n<li>A 액티비티에서 startActivityForResult()로 B 액티비티 시작</li>\n<li>B 액티비티에서 setResult()로 결과를 A 액티비티로 전달</li>\n<li>A 액티비티의 onActivityResult()에서 B 액티비티에서 전달받은 데이터 처리</li>\n</ol>\n<h1>자바 기초 개념</h1>\n<hr>\n<h2>자바 상속과 인터페이스 개념 정리 <a href=\"http://nyebo.net/2016/01/just-java-summary/\">출처</a></h2>\n<ol>\n<li>상속</li>\n</ol>\n<ul>\n<li>어떤 클래스보다 내용이 구체적인 새로운 클래스가 필요할 때 기존 클래스에서 물려받아 새로운 부분만 추가하거나 수정하려고 만든 개념이다.</li>\n<li>상속을 이용하면 슈퍼 클래스(부모)의 필드, 메서드를 상속받으며 서브 클래스(자식)에서 자신만의 필드나 메서드를 추가하여 구체화할 수 있다.\n물론 상속받은 메서드를 재정의(오버라이딩)하는 것도 가능하다.</li>\n<li>상속은 클래스를 선언할 때 extends 키워드를 사용하여 정의한다.</li>\n<li>다른 객체지향 언어와 달리 다중 상속을 지원하지 않는다.</li>\n<li>다형성 : 슈퍼클래스가 같은 서브 클래스들이 동일한 요청(메서드)을 다르게 처리할 수 있는 특징을 말한다. 메서드를 오버라이딩(재정의)하여 구현한다.</li>\n</ul>\n<ol start=\"2\">\n<li>클래스의 기본 구조</li>\n</ol>\n<ul>\n<li>패키지 : 자바 클래스들을 같은 성격으로 묶어서 관리하는 디렉토리 개념</li>\n<li>클래스 : 자바 프로그램의 기본 단위</li>\n<li>인스턴스 : 객체지향개념에 따라 클래스는 바로 사용할 수 없고 인스턴스로 사용해야한다. 인스턴스를 이용하여 메서드 호출 등 필요한 작업을 처리한다.</li>\n<li>생성자 : 클래스를 생성할 때 제일 먼저 실행되는 특수한 형태의 메서드, 리턴값이 없으며(데이터형 입력하면 안됨) 메서드 이름은 반드시 클래스 이름과 일치해야 한다.</li>\n</ul>\n<ol start=\"3\">\n<li>접근 한정자의 종류와 접근 범위</li>\n</ol>\n<ul>\n<li>public : 클래스 내부, 동일 패키지, 하위클래스, 그 외의 영역에서 접근 가능</li>\n<li>protected : 클래스 내부, 동일 패키지, 하위클래스에서 접근 가능</li>\n<li>default : 클래스 내부, 동일 패키지에서 접근 가능</li>\n<li>private : 클래스 내부에서만 접근 가능</li>\n</ul>\n<ol start=\"4\">\n<li>일반 한정자의 종류</li>\n</ol>\n<ul>\n<li>static : 클래스 메서드와 클래스 변수를 선언하는 데 사용한다.\n자바의 정적 영역에 할당되는 리소스를 선언하는 데 사용.\n동일한 가상머신 상에서 실행 중인 모든 클래스에서 공유한다.\n인스턴스를 생성하지 않고도 클래스의 메서드나 멤버에 접근할 수 있다.</li>\n<li>final : 더 이상 변경할 수 없도록 선언하는 한정자. 클래스에서 사용하면 서브 클래스를 만들 수 없다. 메서드에서 사용하면 오버라이딩을 할 수 없다.\n변수에 사용하면 저장된 값은 변할 수 없으므로 상수의 역할을 한다.</li>\n<li>abstract : 추상 클래스를 선언하는 데 사용하는 한정사</li>\n</ul>\n<ol start=\"5\">\n<li>인스턴스 변수와 클래스 변수</li>\n</ol>\n<ul>\n<li>인스턴스 변수는 클래스의 인스턴스로만 접근 가능한 변수(일반적인 멤버 변수), 클래스 외부에서 접근 차단하려고 private 키워드를 사용하기도 함.</li>\n<li>동일 클래스의 인스턴스라 해도 각 인스턴스의 변수는 값이 서로 다르고 서로에 영향을 주지 않는다.</li>\n<li>클래스 변수는 모든 클래스의 인스턴스로 공유되는 변수, static 키워드를 사용하여 선언한다.</li>\n</ul>\n<ol start=\"6\">\n<li>자바 가상머신의 메모리 구조</li>\n</ol>\n<ul>\n<li>Heap 영역 : 자바 객체, 인스턴스 변수</li>\n<li>Stack 영역 : 메서드 파라미터, 지역 변수</li>\n<li>Method 영역 : 메서드 바이트 코드, 클래스(static) 변수</li>\n</ul>\n<ol start=\"7\">\n<li>추상 클래스와 인터페이스</li>\n</ol>\n<ul>\n<li>추상클래스\n<ul>\n<li>추상 메서드(정의만 한 메서드)를 하나 이상 포함한다, 추상 메서드가 포함된 클래스는 반드시 추상 클래스로 정의해야 한다.</li>\n<li>그 자체를 인스턴스화(객체 생성)에 사용할 수 없다. 추상 클래스를 상속받는 클래스를 만든 후 추상클래스에 선언된 모든 추상 메서드를 오버라이딩해서 구현해야 한다.</li>\n</ul>\n</li>\n</ul>\n<ol start=\"8\">\n<li>인터페이스</li>\n</ol>\n<ul>\n<li>모두 추상 메서드로만 구성해야 한다.</li>\n<li>일반 멤버 필드는 없고, public, static, final로 선언한 상수만 있다.</li>\n<li>그 자체를 인스턴스화(객체 생성) 불가. 다른 클래스로 구현할 때는 implements 키워드로 구현을 선언해야한다.</li>\n<li>다중 상속 개념 지원하는 형태로 사용 가능</li>\n</ul>\n<ol start=\"9\">\n<li>캡슐화</li>\n</ol>\n<ul>\n<li>외부에서 변수에 직접 접근할 수 없도록 하는 객체지향 프로그래밍 방법이다.</li>\n<li>캡슐화된 변수에 접근하려면 getter, setter 메서드를 만들어서 접근해야한다.</li>\n</ul>\n",
		"updatedAt": "2020-01-22T18:23:44.561Z",
		"id": "2018-11-30-android-base",
		"filename": "android\\2018-11-30-android-base.json"
	},
	{
		"layout": "post-content",
		"title": "(안드로이드) 어댑터뷰를 사용해보자",
		"date": "2018-12-02T00:00:00.000Z",
		"tags": [
			"android"
		],
		"category": [
			"android"
		],
		"body": "<p>[될때까지 안드로이드] 어댑터뷰 파트의 내용을 정리한 글입니다.</p>\n<p>ListView 와 GridView</p>\n<ul>\n<li>반복되고 양이 많은 데이터를 표시하고 싶을 때</li>\n<li>이미지와 같이 메모리를 차지하는 리소스를 표시하고 싶을 때</li>\n<li>모두 AdapterView 추상클래스를 상속받아 어댑터 패턴을 사용하여 데이터를 뷰에 표시한다.</li>\n<li>ScrollView의 경우 한번에 모든 컨텐츠를 로드하므로 컨텐츠가 메모리를 많이 사용할 경우 메모리 부족으로 앱이 종료될 수 있다.</li>\n</ul>\n<h1>AdapterView</h1>\n<hr>\n<p>AdapterView를 상속받은 뷰들은 화면에 보이는 내용만 로드하는 기법을 사용한다.</p>\n<h2>1. AdapterView의 구현</h2>\n<p>데이터 준비하기</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">//MainActivity.java</span>\nArrayList&lt;Weather&gt; data = <span class=\"hljs-keyword\">new</span> ArrayList&lt;Weather&gt;()\ndata.add(<span class=\"hljs-keyword\">new</span> Weather(<span class=\"hljs-string\">\"수원\"</span>, <span class=\"hljs-string\">\"25도\"</span>, <span class=\"hljs-string\">\"맑음\"</span>));\ndata.add(<span class=\"hljs-keyword\">new</span> Weather(<span class=\"hljs-string\">\"안양\"</span>, <span class=\"hljs-string\">\"22도\"</span>, <span class=\"hljs-string\">\"비\"</span>));\ndata.add(<span class=\"hljs-keyword\">new</span> Weather(<span class=\"hljs-string\">\"부천\"</span>, <span class=\"hljs-string\">\"22도\"</span>, <span class=\"hljs-string\">\"구름\"</span>));\ndata.add(<span class=\"hljs-keyword\">new</span> Weather(<span class=\"hljs-string\">\"성남\"</span>, <span class=\"hljs-string\">\"24도\"</span>, <span class=\"hljs-string\">\"맑음\"</span>));\ndata.add(<span class=\"hljs-keyword\">new</span> Weather(<span class=\"hljs-string\">\"서울\"</span>, <span class=\"hljs-string\">\"28도\"</span>, <span class=\"hljs-string\">\"구름\"</span>));\ndata.add(<span class=\"hljs-keyword\">new</span> Weather(<span class=\"hljs-string\">\"광주\"</span>, <span class=\"hljs-string\">\"30도\"</span>, <span class=\"hljs-string\">\"비\"</span>));\ndata.add(<span class=\"hljs-keyword\">new</span> Weather(<span class=\"hljs-string\">\"부산\"</span>, <span class=\"hljs-string\">\"20도\"</span>, <span class=\"hljs-string\">\"비\"</span>));\n</code></pre>\n<p>데이터를 뷰에 연결해 줄 어댑터를 준비한다.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">//MainActivity.java</span>\nMyFirstAdapter adapter = <span class=\"hljs-keyword\">new</span> MyFirstAdapter(data);\n</code></pre>\n<p>뷰에 어댑터를 붙인다.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">//MainActivity.java</span>\nListView listView = (ListView) findViewById(R.id.list_view);\nlistView.setAdapter(adapter);\n</code></pre>\n<h2>2. 클릭 이벤트 구현</h2>\n<p>public static interface AdapterView.OnItemClickListener<br>\n<span class=\"clr-grey\">android.widget.AdapterView.OnItemClickListener : 어댑터뷰의 아이템 클릭시 호출되는 콜백 메서드를 정의한 인터페이스</span></p>\n<p>public abstract void onItemClick (AdapterView&lt;?&gt; parent, View view, int position, long id)<br>\n<span class=\"clr-grey\">\nparent : 클릭이 일어난 AdapterView<br>\nview : AdapterView 안의 클릭된 View = 클릭된 아이템 뷰<br>\nposition : 클릭된 아이템 뷰의 위치<br>\nid : 클릭된 아이템 뷰의 row ID\n</span></p>\n<pre><code class=\"language-java\">listView.setOnItemClickListener(<span class=\"hljs-keyword\">new</span> AdapterView.OnItemClickListener() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onItemClick</span><span class=\"hljs-params\">(AdapterView&lt;?&gt; parent, View view, <span class=\"hljs-keyword\">int</span> position, <span class=\"hljs-keyword\">long</span> id)</span> </span>{\n    Toast.makeText(MainActivity.<span class=\"hljs-keyword\">this</span>, position + <span class=\"hljs-string\">\" 번째 아이템 선택\"</span>, Toast.LENGTH_SHORT).show();\n   }\n});\n</code></pre>\n<h2>3. 예제 구성</h2>\n<ol>\n<li>\n<p>Weather.java\n날씨를 표현하는 모델클래스<br>\n<span class=\"clr-grey\"> toString() : 모든 클래스가 가지고 있는 기본메서디로 디버깅이나 로그에서 정보 확인을 위해 toString() 메서드 재정의한다. </span></p>\n</li>\n<li>\n<p>MyFirstAdapter.java<br>\n추상클래스인 BaseAdapter를 상속받는 클래스로 추상 메서드들을 구현해야 한다.<br>\n<span class=\"clr-grey\"> Note: BaseAdapter는 어댑터의 기능을 추상화해 둔 추상 클래스, 각 메서드 재정의 필요 </span></p>\n</li>\n</ol>\n<pre><code class=\"language-java\"> <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> View <span class=\"hljs-title\">getView</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> position, View convertView, ViewGroup parent)</span> </span>{\n        <span class=\"hljs-comment\">/**\n         * LayoutInflater 클래스란?\n         * Activity 이외의 클래스에서 Context를 통해 XML로 정의한 레이아웃을 로드하여 View로 반환해주는 클래스\n         */</span>\n        ViewHolder holder;\n        <span class=\"hljs-keyword\">if</span> (convertView == <span class=\"hljs-keyword\">null</span>) {\n            holder = <span class=\"hljs-keyword\">new</span> ViewHolder();\n            convertView = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_weather, parent, <span class=\"hljs-keyword\">false</span>);\n            ImageView weatherImage = (ImageView) convertView.findViewById(R.id.weather_image);\n            TextView cityText = (TextView) convertView.findViewById(R.id.city_text);\n            TextView tempText = (TextView) convertView.findViewById(R.id.temp_text);\n            holder.cityText = cityText;\n            holder.tempText = tempText;\n            holder.weatherImage = weatherImage;\n            convertView.setTag(holder);\n        } <span class=\"hljs-keyword\">else</span> {\n            holder = (ViewHolder) convertView.getTag();\n        }\n\n        Weather weather = mData.get(position);\n        holder.cityText.setText(weather.getCity());\n        holder.tempText.setText(weather.getTemp());\n        holder.weatherImage.setImageResource(mWeatherImageMap.get(weather.getWeather()));\n        <span class=\"hljs-keyword\">return</span> convertView;\n    }\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ViewHolder</span> </span>{\n        ImageView weatherImage;\n        TextView cityText;\n        TextView tempText;\n    }\n</code></pre>\n<ul>\n<li>핵심메서드 getView() 작성\n<ul>\n<li>각 아이템이 화면에 표시될 때마다 호출되며, 여기서 화면에 표시할 레이아웃과 데이터를 모두 작성해야한다.</li>\n<li>ListView의 각 아이템에 해당되는 View는 화면에 보이는 만큼만 생성되고 스크롤 시에 안쓰이는 아이템은 새로 보이는 아이템의 View로 재사용된다.<br>\n<span class=\"clr-grey\"> Note: 두번째 파라미터인 convertView가 재사용 시에 이전에 생성되었던 getView()가 반환했던 View </span></li>\n</ul>\n</li>\n<li>LayoutInflater 추상 클래스\n<ul>\n<li>Activity 이외의 클래스에서 Context를 통해 XML로 정의한 레이아웃을 로드하여 View로 반환해주는 클래스</li>\n<li>레이아웃 XML 파일을 View 객체로 반환한다.</li>\n<li>LayoutInflater 인스턴스 받는 법 : <strong>Activity.getLayoutInflater()</strong> or <strong>Context.getSystemService(Class)</strong></li>\n<li>Public methods<br>\n<span class=\"clr-grey\">\n-LayoutInflater.from(parent.getContext())<br>\n현재 Context로부터 LayoutInflater 인스턴스를 반환받는다.<em>static LayoutInflater</em><br>\n-LayoutInflater.from(parent.getContext()).inflate(R.layout.item_weather, parent, false);<br>\ninflate(int resource, ViewGroup root, boolean attachToRoot)<br>\nxml파일 item_weather을 View 객체 형태로 반환한다.\n</span></li>\n</ul>\n</li>\n<li>ViewHolder\n자주 사용하는 뷰를 한번 로드하면 재사용하고 표시할 내용만 교체하기 위한 패턴\n<ul>\n<li>View 안에 여러 데이터를 담고 싶을 때, getTag(), setTag()를 사용한다.<br>\n<span class=\"clr-grey\">android.view.View, Tag는 Object 타입이라 다양한 용도로 사용가능</span></li>\n</ul>\n</li>\n</ul>\n",
		"updatedAt": "2020-01-22T18:23:44.561Z",
		"id": "2018-12-02-android-adapter",
		"filename": "android\\2018-12-02-android-adapter.json"
	},
	{
		"layout": "post-content",
		"title": "(안드로이드) RecyclerView를 사용하자",
		"date": "2018-12-05T00:00:00.000Z",
		"tags": [
			"android"
		],
		"category": [
			"android"
		],
		"body": "<p>[될 때까지 안드로이드]의 RecyclerView 파트를 정리한 내용입니다.</p>\n<p>어댑터 뷰의 성능을 개선한 컴포넌트로 애니메이션을 지원하고 뷰홀더 패턴을 강제한다.<br>\n대신 이벤트 리스너와 커서를 지원하지 않는 단점이 있다.</p>\n<hr>\n<h2>어댑터 뷰의 단점</h2>\n<ol>\n<li>빠르게 스크롤 할 때 성능문제와 불필요한 지연 문제가 있다.</li>\n<li>데이터 목록이 변경되었을 때, <code class=\"codetainer\">notifyDataSetChanged()</code> 메서드를 빈번하게 호출하여 전체 아이템을 갱신하는 데 비용이 많이 든다. 이 메서드는 항상 전체 항목을 새로 로드한다.</li>\n</ol>\n<h2>리사이클러 뷰 vs 어댑터 뷰</h2>\n<ul>\n<li>상속 받는 클래스 : RecyclerView.Adapter vs BaseAdapter</li>\n<li>리사이클러 뷰는 레이아웃 매니저를 지정해줘야 한다.</li>\n<li>리사이클러 뷰는 뷰홀더 패턴을 반드시 구현해야한다.</li>\n</ul>\n<h2>리사이클러 뷰 관련 클래스</h2>\n<ol>\n<li>\n<p>RecyclerView.Adapter : 어댑터 역할</p>\n</li>\n<li>\n<p>RecyclerView.ViewHolder : 뷰홀더 클래스가 상속받아야 할 클래스</p>\n</li>\n<li>\n<p>LayoutManager : 아이템을 어떻게 배치할 것 인가</p>\n<ul>\n<li>LinearLayoutManager</li>\n<li>GridLayoutManager</li>\n<li>StaggeredGridLayoutManager</li>\n</ul>\n</li>\n<li>\n<p>RecyclerView.ItemAnimator : 아이템이 추가, 삭제, 재정렬 시 애니메이션 어떻게 할 것인가</p>\n</li>\n<li>\n<p>RecyclerView.ItemDecoration : 아이템을 세부적으로 어떻게 꾸밀 것인가</p>\n</li>\n</ol>\n<h2>리사이클러 통지 메서드</h2>\n<ul>\n<li><code class=\"codetainer\">notifyItemInserted(int position)</code> : position 위치의 아이템이 삽입된 것을 통지</li>\n<li><code class=\"codetainer\">notifyItemRemoved(int position)</code> : position 위치의 아이템이 삭제된 것을 통지</li>\n</ul>\n<h2>관련 메서드</h2>\n<ul>\n<li><code class=\"codetainer\">void setHasFixedSize (boolean hasFixedSize)</code> : 각 아이템의 변화가 리사이클러 뷰의 전체 크기에 영향을 끼치지 않는다면 true를 사용한다.</li>\n</ul>\n",
		"updatedAt": "2020-01-22T18:23:44.567Z",
		"id": "2018-12-05-android-recycler",
		"filename": "android\\2018-12-05-android-recycler.json"
	},
	{
		"layout": "post-content",
		"title": "(안드로이드) fragment를 사용하자",
		"date": "2018-12-07T00:00:00.000Z",
		"tags": [
			"android"
		],
		"category": [
			"android"
		],
		"body": "<p>[될 때까지 안드로이드]의 fragment 파트를 정리한 내용입니다.</p>\n<p><a href=\"https://github.com/devgaram/androidExample/tree/master/fragmentexam\">기본 프래그먼트 구현 예제</a>.<br>\n<a href=\"https://github.com/devgaram/androidExample/tree/master/exitdialogfragment\">다이얼로그 프래그먼트 구현 예제</a>.<br>\n<a href=\"https://github.com/devgaram/androidExample/tree/master/callbackexam\">콜백 구현 예제</a>.</p>\n<p>여러 개의 프래그먼트를 하나의 액티비티에 조합하여 창이 여러 개인 UI를 구축할 때 사용할 수 있다.</p>\n<ul>\n<li>하나의 프래그먼트를 여러 액티비티에서 재사용할 수 있으며,동적으로 추가, 삭제, 교체가 쉽다.</li>\n<li>프래그먼트는 자체 수명 주기를 가진다.</li>\n<li>프래그먼트는 부모-자식 관계를 가질 수 있다.</li>\n</ul>\n<hr>\n<h1>생명주기 (소속 액티비티가 실행 중일 때)</h1>\n<p>최소한 다음과 같은 수명 주기 메서드를 구현해야한다.</p>\n<p><strong>onCreate()</strong><br>\n프래그먼트를 생성할 때 호출되는 콜백 메서드<br>\n프래그먼트가 일시정지되거나 중지되었다가 재개되었을 때 유지하고자 하는 것을 초기화하는 부분</p>\n<p><strong>onCreateView()</strong><br>\n액티비티는 <code class=\"codetainer\">onCreate()</code> 콜백 메서드에서 <code class=\"codetainer\">setContentView()</code> 메서드를 호출하여 View 객체(레이아웃)을 가져온다.<br>\n프래그먼트는 <code class=\"codetainer\">onCreateView()</code> 콜백 메서드에서 LayoutInflater를 통해 레이아웃을 가져온다.</p>\n<p><strong>onPause()</strong><br>\n시스템이 이 메서드를 호출하는 것은 사용자가 프래그먼트를 떠난다는 첫 번째 신호.<br>\n현재 사용자 세션을 넘어서 지속되어야 하는 변경 사항을 저장하는 부분</p>\n<p>프래그먼트 추가<br>\nonAttach() -&gt; onCreate() -&gt; onCreateView() -&gt; onActivityCreated() -&gt; onStart() -&gt; onResume()</p>\n<p>프래그먼트 소멸<br>\nonPause() -&gt; onStop() -&gt; onDestroyView() -&gt; onDestroy() -&gt; onDetach()</p>\n<h1>실습</h1>\n<h2>프래그먼트의 생성자</h2>\n<p>생성자를 오버로드할 수 없으며, 생성자를 통해 파라미터 전달을 금지하고 있다.<br>\n재생성 시에 정보를 자동으로 저장 및 복원하기 위한 설계가 이미 되어 있고 그것을 따르기 위한 제약이다.\n프래그먼트의 생성과 동시에 파라미터를 전달하는 방법은 <strong>Bundle 객체</strong>를 활용한다.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ColorFragment</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Fragment</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ColorFragment</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// Required empty public constructor</span>\n    }\n    \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> View <span class=\"hljs-title\">onCreateView</span><span class=\"hljs-params\">(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState)</span> </span>{\n        <span class=\"hljs-comment\">// Inflate the layout for this fragment</span>\n        <span class=\"hljs-keyword\">return</span> inflater.inflate(R.layout.fragment_color, container, <span class=\"hljs-keyword\">false</span>);\n    }\n}\n</code></pre>\n<h2>프래그먼트 매니저</h2>\n<p>프래그먼트 조작을 위해 프래그먼트 매니저가 필요하다.<br>\n프래그먼트 매니저는 액티비티 처럼 백스택을 가지고 있음.</p>\n<ul>\n<li>액티비티 내 XML에 포함된 프래그먼트를 <code class=\"codetainer\">findFragmentById()</code> 메서드로 가져오기 또는 <code class=\"codetainer\">findFragmentByTag()</code>로 가져오기</li>\n<li>액티비티 백스택에서 프래그먼트를 <code class=\"codetainer\">popBackStack()</code>메서드로 빠져나오게 하여 액티비티의 뒤로 가기와 같은 효과를 냄 ( <code class=\"codetainer\">addToBackStack()</code> : 프래그먼트 매니저의 백스택에 프래그먼트 추가하는 메서드 )</li>\n</ul>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AppCompatActivity</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCreate</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span> </span>{\n      ...생략...\n        FragmentManager fragmentManager = getSupportFragmentManager();\n        ColorFragment colorFragment = (ColorFragment) fragmentManager.findFragmentById(R.id.color_fragment);\n        colorFragment.setColor(Color.BLUE);\n    }\n}\n</code></pre>\n<h2>프래그먼트에서 액티비티에 접근하는 방법</h2>\n<pre><code class=\"language-java\">View listView = getActivity().findViewById(R.id.list);\n</code></pre>\n<h2>프래그먼트 교체, 삭제, 추가</h2>\n<p>프래그먼트를 교체하기 위해서는 &lt;fragment<fragment>&gt;를 &lt;FrameLayout<FrameLayout>&gt;과 같은 레이아웃으로 감싸줘야한다.<br>\n<strong>프래그먼트 트랜지션 수행</strong> add(), remove(), replace() 같은 메서드를 사용하고 commit()을 수행하면 트랜지션이 적용된다.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AppCompatActivity</span> </span>{\n\n  ...생략....\n  \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">change</span><span class=\"hljs-params\">(View view)</span> </span>{\n        ColorFragment fragment = <span class=\"hljs-keyword\">new</span> ColorFragment();\n        <span class=\"hljs-keyword\">int</span> red = <span class=\"hljs-keyword\">new</span> Random().nextInt(<span class=\"hljs-number\">256</span>);\n        <span class=\"hljs-keyword\">int</span> green = <span class=\"hljs-keyword\">new</span> Random().nextInt(<span class=\"hljs-number\">256</span>);\n        <span class=\"hljs-keyword\">int</span> blue = <span class=\"hljs-keyword\">new</span> Random().nextInt(<span class=\"hljs-number\">256</span>);\n        fragment.setColor(Color.rgb(red, green, blue));\n        getSupportFragmentManager()\n                .beginTransaction()\n                .replace(R.id.container, fragment)\n                .commit();\n    }\n}\n</code></pre>\n<h2>프래그먼트와 액티비티 간의 통신</h2>\n<p>일반적으로 액티비티에서 프래그먼트나 다른 뷰들의 인스턴스를 가지고 있어서 이들의 메서드를 호출하는 식이다. 따라서 프래그먼트의 상태가 변했을 때 액티비티에서 이것을 알아차리려면 계속해서 프래그먼트의 상태 값을 알아내는 메서드를 호출해야한다.</p>\n<p>그러나 콜백 인터페이스를 사용하여 프래그먼트의 상태가 변할 때마다 자동으로 액티비티에게 알려줄 수 있다.\nButton의 <code class=\"codetainer\">onClick()</code> 이벤트나 액티비티의 <code class=\"codetainer\">onCreate()</code>가 대표적인 콜백 메서드이며, 호출자 입장에서는 피호출자의 변화를 감시하다가 알아채기 때문에 리스너(Listener) 라고도 불른다.</p>\n",
		"updatedAt": "2020-01-22T18:23:44.568Z",
		"id": "2018-12-07-android-fragment",
		"filename": "android\\2018-12-07-android-fragment.json"
	},
	{
		"layout": "post-content",
		"title": "안드로이드 MVVM에 대해 알아보자1",
		"date": "2019-01-07T00:00:00.000Z",
		"tags": [
			"android",
			"mvvm"
		],
		"category": [
			"android"
		],
		"body": "<p>Coding in Flow의  Room + ViewModel + LiveData + RecyclerView (MVVM) 튜토리얼을 정리했습니다.</p>\n<hr>\n<h1>파일 구성</h1>\n<ul>\n<li>MainActivity.java</li>\n<li>Note.java</li>\n<li>NoteAdapter.java</li>\n<li>NoteDao.interface</li>\n<li>NoteDatabase.java</li>\n<li>NoteRepository.java</li>\n<li>NoteViewModel.java</li>\n</ul>\n<h1>MVVM - VIEW와 VIEWMODEL</h1>\n<p><span class=\"li-icon\">MainActivity.class : 앱의 시작점으로 RecyclerView 설정 및 ViewModel 생성하는 부분 </span>\n<span class=\"li-icon\">NoteViewModel.class : UI 컴포넌트와 UI 데이터의 분리</span>\n<span class=\"li-icon\">NoteAdapter.class : 리사이클러뷰 어댑터</span>\n<span class=\"li-icon\">NoteRepository.class : 저장소, 도메인과 모델 사이의 중간체 역할?</span></p>\n<h2>1. 리사이클러뷰 구현</h2>\n<pre><code class=\"language-java\">RecyclerView recyclerView = findViewById(R.id.recycler_view);\nrecyclerView.setLayoutManager(<span class=\"hljs-keyword\">new</span> LinearLayoutManager(<span class=\"hljs-keyword\">this</span>));   <span class=\"hljs-comment\">// 1)</span>\nrecyclerView.setHasFixedSize(<span class=\"hljs-keyword\">true</span>); <span class=\"hljs-comment\">// 2)</span>\n\n<span class=\"hljs-keyword\">final</span> NoteAdapter adapter = <span class=\"hljs-keyword\">new</span> NoteAdapter();  <span class=\"hljs-comment\">// 3)</span>\nrecyclerView.setAdapter(adapter);   <span class=\"hljs-comment\">// 3-1)</span>\n</code></pre>\n<ol>\n<li>\n<p>LayoutManager 클래스, 아이템을 어떻게 배치할 것인가를 결정한다.<br>\n<span class=\"clr-grey\">LinearLayoutManager 클래스 : 가로/세로 형태로 아이템을 배열한다.</span></p>\n</li>\n<li>\n<p>각 아이템의 변화가 리사이클러 뷰의 전체 크기에 영향을 끼치지 않는다면 true를 사용한다.</p>\n</li>\n<li>\n<p>데이터를 리사이클러뷰에 연결해 줄 어댑터 객체 생성</p>\n</li>\n</ol>\n<p>3-1) 3)에서 생성한 어댑터 객체를 리사이클러뷰에 붙인다.</p>\n<p><span id=\"viewModel\"></span></p>\n<h2>2. ViewModel과 LiveData</h2>\n<p><a href=\"/android/android-viewModel/\">뷰모델 개념 익히러가기</a>.</p>\n<pre><code class=\"language-java\">noteViewModel = ViewModelProviders.of(<span class=\"hljs-keyword\">this</span>).get(NoteViewModel<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n</code></pre>\n<p><strong>ViewModel 객체 요청</strong><br>\n보통 ViewModel 생성 요청은 <code class=\"codetainer\">onCreate()</code> 메서드에서 이루어지며, <strong>ViewModelProvider 클래스</strong>를 통해서 ViewModel 객체를 생성한다.\nViewModelProviders 클래스의 <code class=\"codetainer\">of(this)</code> 를 통해 this(UI 컨트롤러) 스코프를 가진 ViewModelProvider 인스턴스가 반환된다.\n리턴된 ViewModelProvider 객체의 메서드 <code class=\"codetainer\">get(NoteViewModel.class)</code> 를 통해 NoteViewModel 인스턴스가 생성된다.</p>\n<p><span class=\"clr-grey\"><strong>NOTE:</strong> get()은 이미 ViewModel 객체가 생성되었을 경우, 그 객체를 리턴한다. </span></p>\n<p><span id=\"LiveData\"></span>\n<strong>LiveData 사용</strong><br>\n<a href=\"/android/android-LiveData/\">LiveData 개념 익히러가기</a>.</p>\n<p>noteViewModel.java</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NoteViewModel</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AndroidViewModel</span> </span>{\n    <span class=\"hljs-comment\">// ...생략</span>\n    <span class=\"hljs-keyword\">private</span> LiveData&lt;List&lt;Note&gt;&gt; allNotes;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">NoteViewModel</span><span class=\"hljs-params\">(@NonNull Application application)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(application);\n        repository = <span class=\"hljs-keyword\">new</span> NoteRepository(application);\n        allNotes = repository.getAllNotes();\n    }\n\n    <span class=\"hljs-comment\">// ...생략</span>\n    <span class=\"hljs-keyword\">public</span> LiveData&lt;List&lt;Note&gt;&gt; getAllNotes() {\n        <span class=\"hljs-keyword\">return</span> allNotes;\n    }\n}\n</code></pre>\n<p>LiveData는 보통 ViewModel 내에서 함께 쓰인다.</p>\n<p>MainActivity.java</p>\n<pre><code class=\"language-java\">noteViewModel.getAllNotes().observe(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-keyword\">new</span> Observer&lt;List&lt;Note&gt;&gt;() {  <span class=\"hljs-comment\">// 1) LifeCycleOwner, Observer</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onChanged</span><span class=\"hljs-params\">(@Nullable List&lt;Note&gt; notes)</span> </span>{ <span class=\"hljs-comment\">// 2)</span>\n        <span class=\"hljs-comment\">// update RecyclerView</span>\n        <span class=\"hljs-comment\">// Toast.makeText(MainActivity.this, \"onchanged\", Toast.LENGTH_SHORT).show();</span>\n        adapter.setNotes(notes);\n    }\n});\n</code></pre>\n<ol>\n<li>\n<p><code class=\"codetainer\">noteViewModel.getAllNotes()</code>를 통해 LiveData를 리턴받고 <code class=\"codetainer\">observe()</code> 메서드를 통해 Observer를 붙여 감지를 시작한다.\n<span class=\"clr-grey\">보통 Observer는 프래그먼트나 액티비티 같은 UI 컨트롤러에서 만든다.</span><br>\n<span class=\"clr-note\">LiveData의 data가 변경될 때 LifeCycleOwner가 활성화 되어있는 한 등록된 모든 Observer들 에게 이벤트를 보낸다.</span></p>\n</li>\n<li>\n<p>Observer는 <code class=\"codetainer\">onChanged()</code> 메서드를 반드시 오버라이드해야하며, <code class=\"codetainer\">onChanged()</code> 메서드에서 UI 업데이트를 한다.</p>\n</li>\n</ol>\n<h1>MVVM - MODEL</h1>\n<p><span class=\"li-icon\">NoteDatabase.class</span>\n<span class=\"li-icon\">NoteDao.interface</span>\n<span class=\"li-icon\">Note.class</span></p>\n<p>Room은 SQLite 추상계층을 감싸고 있으며, 쉽게 데이터베이스에 접근하여 SQLite를 자유롭게 사용할 수 있다. Room에는 세가지 주요한 컴포넌트가 있다.</p>\n<h2>1. Database (NoteDatabase.class)</h2>\n<p>데이터베이스 홀더를 포함하고, 관계형 데이터베이스에 접근할 수 있는 액세스 포인트를 제공한다.</p>\n<pre><code class=\"language-java\">@Database(entities = {Note.class}, version = 1, exportSchema = false)   // 1)\npublic abstract class NoteDatabase extends RoomDatabase {\n\n    private static NoteDatabase instance;\n\n    public abstract NoteDao noteDao();  // 3)\n\n    public static synchronized NoteDatabase getInstance(Context context) {\n        if (instance == null) {\n            instance = Room.databaseBuilder(context.getApplicationContext(),    // 4)\n                    NoteDatabase.class, \"note_database\")\n                    .fallbackToDestructiveMigration()\n                    .addCallback(roomCallback) \n                    .build();\n        }\n        return instance;\n    }\n    // ..생략\n}\n</code></pre>\n<ol>\n<li>@Database 애노테이션을 클래스에 달아야하며, 데이터베이스와 관련된 Entity들은 애노테이션 인자값으로 포함해야한다.</li>\n<li>RoomDatabase를 상속한 abstract class여야 한다.</li>\n<li>abstract method 포함해야하는데, 이 메소드에는 인자가 0개이고 reture되는 클래스가 @Dao 애노테이션을 달고 있어야한다.</li>\n<li>런타임때에는 Room.databaseBuilder() 또는 Room.inMemoryDatabaseBuilder()를 통해 Database의 객체를 얻어 낼 수 있다.</li>\n</ol>\n<p><span class=\"clr-grey\"><strong>Note:</strong> RoomDatabase 객체를 인스턴스화 하는 비용은 매우 크므로 인스턴스를 얻는 작업을 싱글톤패턴으로 만드는 게 좋다.</span></p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Database</span>(entities = {Note<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>}, <span class=\"hljs-title\">version</span> </span>= <span class=\"hljs-number\">1</span>, exportSchema = <span class=\"hljs-keyword\">false</span>)   <span class=\"hljs-comment\">// 1)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NoteDatabase</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">RoomDatabase</span> </span>{\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> NoteDatabase instance;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> NoteDao <span class=\"hljs-title\">noteDao</span><span class=\"hljs-params\">()</span></span>;\n    <span class=\"hljs-comment\">// ..생략</span>\n    \n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> RoomDatabase.Callback roomCallback = <span class=\"hljs-keyword\">new</span> RoomDatabase.Callback() {\n\n        <span class=\"hljs-comment\">// 데이터베이스가 처음 생성될 때 호출됨, 모든 테이블이 생성된 후 호출됨.   </span>\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCreate</span><span class=\"hljs-params\">(@NonNull SupportSQLiteDatabase db)</span> </span>{ \n            <span class=\"hljs-keyword\">super</span>.onCreate(db);\n            <span class=\"hljs-keyword\">new</span> PopulateDbAsyncTask(instance).execute(); <span class=\"hljs-comment\">// AsyncTask 실행</span>\n        }\n    };\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PopulateDbAsyncTask</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AsyncTask</span>&lt;<span class=\"hljs-title\">Void</span>, <span class=\"hljs-title\">Void</span>, <span class=\"hljs-title\">Void</span>&gt; </span>{\n        <span class=\"hljs-keyword\">private</span> NoteDao noteDao;\n\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">PopulateDbAsyncTask</span><span class=\"hljs-params\">(NoteDatabase db)</span> </span>{\n            noteDao = db.noteDao();\n        }\n\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Void <span class=\"hljs-title\">doInBackground</span><span class=\"hljs-params\">(Void... voids)</span> </span>{\n            noteDao.insert(<span class=\"hljs-keyword\">new</span> Note(<span class=\"hljs-string\">\"Title 1\"</span>, <span class=\"hljs-string\">\"Description 1\"</span>, <span class=\"hljs-number\">1</span>));\n            noteDao.insert(<span class=\"hljs-keyword\">new</span> Note(<span class=\"hljs-string\">\"Title 2\"</span>, <span class=\"hljs-string\">\"Description 2\"</span>, <span class=\"hljs-number\">2</span>));\n            noteDao.insert(<span class=\"hljs-keyword\">new</span> Note(<span class=\"hljs-string\">\"Title 3\"</span>, <span class=\"hljs-string\">\"Description 3\"</span>, <span class=\"hljs-number\">3</span>));\n\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n        }\n    }\n}\n</code></pre>\n<p><strong>AsyncTask클래스</strong><br>\n비즈니스 로직과 UI 컴포넌트 조작이 동시에 일어나야 할 때 유용하며, 비교적 오래 걸리지 않는 작업에 적합하다. 또한, task 캔슬이 용이하다.</p>\n<p>AsyncTask &lt;Params, Progress, Result&gt; 제너릭 타입\n<span class=\"li-icon\">Params: doInBackground 파라미타 타입이며, execute 메소드의 인자 값이 된다.</span>\n<span class=\"li-icon\">Progress: doInBakcgroud 작업 시 진행 단위의 타입으로 onProgressUpdate 파라미터의 타입이다.</span>\n<span class=\"li-icon\">doInBackground 리턴값으로 onPostExecute 파라미터 타입이다.</span></p>\n<p><span class=\"clr-grey\"><strong>제네릭스(Generics):</strong> 객체 생성시 타입을 선언하므로 캐스팅할 필요가 없으며, 다른 타입을 할당할 경우 컴파일 단계에서 예외처리가 된다. <T>는 객체(Object) 타입이다.</span></p>\n<h2>2. Entity (Note.class)</h2>\n<p>Entity를 사용하여 데이터 구조를 정의하고, 데이터베이스 테이블을 표현한다.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Entity</span>(tableName = <span class=\"hljs-string\">\"note_table\"</span>)   <span class=\"hljs-comment\">// tableName 속성 : 테이블명을 Note로 사용하고 싶지 않을 때</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Note</span> </span>{\n\n    <span class=\"hljs-meta\">@PrimaryKey</span>(autoGenerate = <span class=\"hljs-keyword\">true</span>)    <span class=\"hljs-comment\">// 기본키 정의 필수</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> id;\n    <span class=\"hljs-meta\">@ColumnInfo</span>(name = <span class=\"hljs-string\">\"Notetitle\"</span>) <span class=\"hljs-comment\">// name 속성 : 필드명을 다르게 지정하고 싶을 때</span>\n    <span class=\"hljs-keyword\">private</span> String title;\n    <span class=\"hljs-keyword\">private</span> String description;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> priority;\n    <span class=\"hljs-meta\">@Ignore</span> <span class=\"hljs-comment\">// 데이터베이스에서 칼럼으로 생성되기를 원치 않을 때</span>\n    Bitmap picture;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Note</span><span class=\"hljs-params\">(String title, String description, <span class=\"hljs-keyword\">int</span> priority)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.title = title;\n        <span class=\"hljs-keyword\">this</span>.description = description;\n        <span class=\"hljs-keyword\">this</span>.priority = priority;\n    }\n\n    <span class=\"hljs-comment\">// ..생략 (반드시, getter setter 필요)</span>\n}\n</code></pre>\n<h2>3. DAO (NoteDao.interface)</h2>\n<p>데이터베이스의 데이터에 접근하기 위해서는 DAO가 필요하다. 직접적인 쿼리를 작성하는 대신 DAO 클래스를 사용하여 데이터베이스에 추상적으로 접근한다. <span class=\"clr-note\">DAO는 interface나 abstract class가 되야한다.</span></p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Dao</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">NoteDao</span> </span>{\n\n    <span class=\"hljs-meta\">@Insert</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(Note note)</span></span>;\n\n    <span class=\"hljs-meta\">@Update</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">update</span><span class=\"hljs-params\">(Note note)</span></span>;\n\n    <span class=\"hljs-meta\">@Delete</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">delete</span><span class=\"hljs-params\">(Note note)</span></span>;\n\n    <span class=\"hljs-meta\">@Query</span>(<span class=\"hljs-string\">\"DELETE FROM note_table\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">deleteAllNotes</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-meta\">@Query</span>(<span class=\"hljs-string\">\"SELECT * FROM note_table ORDER BY priority DESC\"</span>)\n    LiveData&lt;List&lt;Note&gt;&gt; getAllNotes();\n}\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:23:54.163Z",
		"id": "2019-01-07-android-mvvm",
		"filename": "android\\2019-01-07-android-mvvm.json"
	},
	{
		"layout": "post-content",
		"title": "안드로이드 ViewModel에 대해 알아보자",
		"date": "2019-01-07T00:00:00.000Z",
		"tags": [
			"android",
			"viewmodel",
			"mvvm"
		],
		"category": [
			"android"
		],
		"body": "<p>안드로이드 아키텍쳐 중 ViewModel 클래스에 대한 내용입니다.</p>\n<hr>\n<p>안드로이드 프레임워크는 액티비티와 프래그먼트와 같은 UI 컨트롤러의 라이프 사이클을 관리한다.</p>\n<p><img src=\"/assets/images/viewmodel-lifecycle.png\" alt=\"액티비티가 회전을 거쳐 끝날 때까지의 라이프 사이클\"><br>\n[ UI 컨트롤러 라이프 사이클과 ViewModel 스코프]</p>\n<p>아래와 같은 구성 변경 발생 시, 안드로이드는 UI 컨트롤러를 종료하거나 재생성한다.</p>\n<ul>\n<li>런타임에 화면 방향이 전환되는 경우</li>\n<li>언어, 글꼴 배율과 같은 기기 구성이 변경되는 경우</li>\n</ul>\n<p>이 때 두가지 문제가 발생한다.</p>\n<h2>1) UI에 종속된 데이터 손실</h2>\n<p>해결1 - 적은 데이터의 경우 <code class=\"codetainer\">OnCreate()</code>에서 <code class=\"codetainer\">onSaveInstanceState()</code> 메서드를 사용하여 번들에서 해당 데이터를 복원할 수 있다.\n<span class=\"clr-grey\">많은 데이터와 비트맵에는 부적절하다.</span><br>\n해결2 - UI가 없는 워커 프래그먼트에 UI에 필요한 데이터를 관리하고 프래그먼트를 <code class=\"codetainer\">SetRetainInstance(true)</code>로 설정함으로써 프래그먼트를 메모리에 유지(유보)시킨다.</p>\n<h2>2) 메모리 누수, 리소스 낭비</h2>\n<p>UI 컨트롤러 재생성 시 다시 데이터를 로드하므로 리소스가 낭비되며, UI 컨트롤러가 비동기 호출을 하고 콜백을 받을 때 해당 컨트롤러가 파괴되었다면 에러가 발생하거나 메모리 누수가 날 수도 있다.</p>\n<h2>문제해결방법</h2>\n<p>UI 컨트롤러는 아래와 같은 작업을 다루는 경향이 있다.</p>\n<ul>\n<li>UI 데이터 표시</li>\n<li>사용자 행동에 반응</li>\n<li>권한 요청</li>\n</ul>\n<p>그러므로 데이터베이스 또는 네트워크에서 데이터를 요청하고 로드하는 작업은 다른 클래스에 위임하여 UI 컨트롤러 로직에서 뷰 데이터에 대한 소유권을 분리하는 것이 효율적이다.</p>\n<h1>ViewModel 클래스 구현</h1>\n<p><a href=\"/android/android-mvvm/#viewModel\">예제로 바로가기</a>.</p>\n<p>Architecture Components는 ViewModel 클래스를 제공한다.<br>\n<strong>ViewModel 클래스의 인스턴스(객체)는 구성 변경에도 데이터를 유지하며, ViewModel 인스턴스는 재생성된 액티비티에서 즉시 사용될 수 있다.</strong>\n소유자가 액티비티를 끝낼 때, 안드로이드는 ViewModel 객체의 <code class=\"codetainer\">onCleared()</code> 메서드를 호출하여 리소스를 정리한다.</p>\n<span class=\"clr-note\">\nViewModel 사용 시 ViewModel에 액티비티, 프래그먼트, 뷰에 대한 컨텍스트를 저장해서는 안된다.     \n</span> \n<p><span class=\"clr-grey\">액티비티가 재생성 될 때, ViewModel은 액티비티 생명주기 외부에 존재하기 때문에 UI 컨텍스트를 ViewModel에 저장하면 메모리 락을 발생시키는 직접적인 원인이 된다. 단, Application 컨텍스트(전체 앱의 수명주기)를 저장하는 것은 괜찮다. Application 컨텐스트는 AndroidViewModel 클래스를 통해 받을 수 있다.</p>\n",
		"updatedAt": "2020-01-22T18:23:54.163Z",
		"id": "2019-01-07-android-viewModel",
		"filename": "android\\2019-01-07-android-viewModel.json"
	},
	{
		"layout": "post-content",
		"title": "안드로이드 LiveData 대해 알아보자",
		"date": "2019-01-09T00:00:00.000Z",
		"tags": [
			"android",
			"livedata",
			"mvvm"
		],
		"category": [
			"android"
		],
		"body": "<p>LiveData 클래스를 통해 데이터 변경을 감지해보자.</p>\n<hr>\n<p><a href=\"https://developer.android.com/topic/libraries/architecture/livedata#java\">안드로이드 개발문서-LiveData</a>.</p>\n<h1>LiveData는 LifecycleOwner의 라이프사이클을 알고있다.</h1>\n<p>LiveData 객체는 <code class=\"codetainer\">observe()</code> 메서드를 통해 <code class=\"codetainer\">LifecycleOwner</code>와 <code class=\"codetainer\">Observer</code>객체를 페어로 등록한다.<br>\nObserver 객체는 페어인 LifecycleOwner가 활성상태(<code class=\"codetainer\">STARTED</code> 또는 <code class=\"codetainer\">RESUMED</code>)일 때, 데이터 변화을 관측할 수 있다.\n반대로, LiveData 객체는 LifecycleOwner가 비활성 상태면 LiveData의 변화를 Observer에게 전달하지 않으며, LifecycleOwner가 <code class=\"codetainer\">DESTROYED</code> 상태라면 자동으로 제거된다.\n이러한 LiveData의 라이프사이클의 인지는 메모리 누수에 대한 걱정을 덜어주며, UI 컴포넌트(액티비티, 프래그먼트)를 사용할 때 유용하다.<br>\n<span class=\"clr-grey\"><strong>Note:</strong> LifecycleOwner의 비활성 상태 예시) 액티비티가 백 스택에 올라가있을 때 </span></p>\n<h1>LiveData 사용시 이점</h1>\n<p><span class=\"li-icon\">일반적인 Observable과 달리, LifecycleOwner가 활성 상태일 때, LiveData의 변화를 Observer 객체에 전달함</span>\n<span class=\"li-icon\">충돌방지 : 액티비티가 백스택(비활성)에 있을 때, LiveData의 변화 이벤트를 Observer에게 전달하지 않음</span>\n<span class=\"li-icon\">메모리누수방지 : <code class=\"codetainer\">DESTROYED</code> 시, LiveData 제거</span>\n<span class=\"li-icon\">생명주기 수동으로 관리할 필요 없음</span>\n<span class=\"li-icon\">항상 최신 데이터 유지 가능 : 액티비티가 다시 활성상태로 돌아온 즉시 최신 데이터를 받는다.</span>\n<span class=\"li-icon\">환경변화(예,화면회전)로 UI 컴포넌트 재생성 시, 즉시 최신 데이터를 받는다.</span>\n<span class=\"li-icon\">LiveData를 상속받아 앱에서 자원 공유 가능</span></p>\n<h1>LiveData 사용하기</h1>\n<p><a href=\"/android/android-mvvm/#LiveData\">예제로 바로가기</a>.</p>\n<h2>1. LiveData 객체 생성하기</h2>\n<p>LiveData는 보통 <code class=\"codetainer\">Collections</code> 인터페이스를 구현한 클래스(List, Map, Set)를 사용하며, <code class=\"codetainer\">ViewMoodel</code> 객체 안에 저장된다.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NameViewModel</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ViewModel</span> </span>{\n  <span class=\"hljs-comment\">// String 타입의 LiveData 생성</span>\n  <span class=\"hljs-keyword\">private</span> MutableLiveData&lt;String&gt; mCurrentName;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> MutableLiveData&lt;String&gt; <span class=\"hljs-title\">getCurrentName</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (mCurrentName == <span class=\"hljs-keyword\">null</span>) {\n            mCurrentName = <span class=\"hljs-keyword\">new</span> MutableLiveData&lt;String&gt;();\n        }\n        <span class=\"hljs-keyword\">return</span> mCurrentName;\n    }\n\n<span class=\"hljs-comment\">// ..생략</span>\n}\n</code></pre>\n<h2>2. LiveData 객체 관찰하기</h2>\n<p><code class=\"codetainer\">onCreate()</code> 메서드에서 LiveData 관찰을 시작하는 것이 좋다.\n<span class=\"li-icon\"><code class=\"codetainer\">onResume()</code> 메서드에서 사용 시 중복 호출이 발생된다.</span>\n<span class=\"li-icon\"><code class=\"codetainer\">STARTED</code> 상태가 되자마자 LiveData 객체의 최신 데이터를 받을 수 있다.</span></p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NameActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AppCompatActivity</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> NameViewModel mModel;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCreate</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>.onCreate(savedInstanceState);\n\n        <span class=\"hljs-comment\">// ..생략</span>\n\n        <span class=\"hljs-comment\">// ViewModel 얻기</span>\n        mModel = ViewModelProviders.of(<span class=\"hljs-keyword\">this</span>).get(NameViewModel<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n\n\n        <span class=\"hljs-comment\">// 옵저버 생성</span>\n        <span class=\"hljs-keyword\">final</span> Observer&lt;String&gt; nameObserver = <span class=\"hljs-keyword\">new</span> Observer&lt;String&gt;() {\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onChanged</span><span class=\"hljs-params\">(@Nullable <span class=\"hljs-keyword\">final</span> String newName)</span> </span>{\n                <span class=\"hljs-comment\">// Update the UI, in this case, a TextView.</span>\n                mNameTextView.setText(newName);\n            }\n        };\n\n        <span class=\"hljs-comment\">// LiveData 관찰 시작</span>\n        mModel.getCurrentName().observe(<span class=\"hljs-keyword\">this</span>, nameObserver);\n    }\n}\n</code></pre>\n<h2>3. LiveData 객체 업데이트하기</h2>\n<p>LiveData는 데이터를 업데이트 하는 publid 메서드를 가지고 있지 않으므로, LiveData를 상속받은 <code class=\"codetainer\">MutableLiveData</code>를 사용해야한다.\n<code class=\"codetainer\">MutableLiveData</code>는 <code class=\"codetainer\">public setValue(T)</code>와 <code class=\"codetainer\">public postValue(T)</code> 메서드를 가지고 있어서 이를 통해 데이터를 변경할 수 있다.</p>\n<pre><code class=\"language-java\">mButton.setOnClickListener(<span class=\"hljs-keyword\">new</span> OnClickListener() {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onClick</span><span class=\"hljs-params\">(View v)</span> </span>{\n        String anotherName = <span class=\"hljs-string\">\"John Doe\"</span>;\n        mModel.getCurrentName().setValue(anotherName);\n    }\n});\n</code></pre>\n<p><code class=\"codetainer\">setValue(T)</code>와 <code class=\"codetainer\">postValue(T)</code>는 호출 시 Observer의 <code class=\"codetainer\">onChanged()</code> 메서드가 호출되어 UI가 업데이트 된다.</p>\n",
		"updatedAt": "2020-01-22T18:23:54.171Z",
		"id": "2019-01-09-android-LiveData",
		"filename": "android\\2019-01-09-android-LiveData.json"
	},
	{
		"layout": "post-content",
		"title": "안드로이드 MVVM에 대해 알아보자2 - 추가/수정/삭제",
		"date": "2019-01-07T00:00:00.000Z",
		"tags": [
			"android",
			"mvvm"
		],
		"category": [
			"android"
		],
		"body": "<p>Coding in Flow의  Room + ViewModel + LiveData + RecyclerView (MVVM) 튜토리얼 중 추가/수정/삭제 부분을 정리했습니다.</p>\n<hr>\n<p><a href=\"/android/android-mvvm/\">안드로이드 MVVM에 대해 알아보자1</a>.에 이어지는 내용으로 노트 추가/수정/삭제를 다룬다.</p>\n<h1>노트 추가해보자.</h1>\n",
		"updatedAt": "2020-01-22T18:23:54.163Z",
		"id": "2019-01-11-android-mvvm-part2",
		"filename": "android\\2019-01-11-android-mvvm-part2.json"
	},
	{
		"layout": "post-content",
		"title": "(Drawable 리소스) LayerDrawable과 ShapeDrawable을 이용해 둥근모서리와 그림자 있는 배경 만들기.",
		"date": "2019-01-16T00:00:00.000Z",
		"tags": [
			"android",
			"resource"
		],
		"category": [
			"android"
		],
		"body": "<p>LayerDrawable과 ShapeDrawable을 이용해 둥근모서리+그림자+투명배경이 있는 디자인을 다른 XML 리소스의 background로 적용하는 방법입니다.</p>\n<hr>\n<p><a href=\"https://developer.android.com/guide/topics/resources/drawable-resource?hl=ko\">안드로이드 개발문서-Drawable 바로가기</a></p>\n<h2>드로어블(Drawable) 리소스</h2>\n<p>앱 화면에 그리고 싶은 것을 XML 파일로 미리 정의할 수 있으며, <code class=\"codetainer\">getDrawable(int)</code>와 같은 API를 사용하여 가져오거나\n<code class=\"codetainer\">android:drawable</code> 및 <code class=\"codetainer\">android:icon</code>과 같은 속성을 사용하여 다른 XML 리소스에 적용할 수 있다.<br>\n<span class=\"clr-grey\"><strong>Example)</strong> android:background=&quot;@drawable/custom_layer_resource&quot;</span></p>\n<h1>LayerDrawable</h1>\n<p>각 <code>&lt;item&gt;</code> 요소는 순서대로 그려지므로, 맨 마지막 <code>&lt;item&gt;</code>이 맨 위에 보이게 된다.</p>\n<p><span class=\"li-nonicon\">위치 : res/drawable/filename.xml</span>\n<span class=\"li-nonicon\">Java 리소스 참조 : R.drawable.filename</span>\n<span class=\"li-nonicon\">XML 리소스 참조 : @[package:]drawable/filename</span></p>\n<pre><code class=\"language-xml\"><span class=\"hljs-meta\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">layer-list</span>\n    <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">\"http://schemas.android.com/apk/res/android\"</span> &gt;</span><span class=\"hljs-comment\">&lt;!-- XML 네임스페이스 정의 필수 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span>\n        <span class=\"hljs-attr\">android:drawable</span>=<span class=\"hljs-string\">\"@[package:]drawable/drawable_resource\"</span>\n        <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">\"@[+][package:]id/resource_name\"</span>\n        <span class=\"hljs-attr\">android:top</span>=<span class=\"hljs-string\">\"dimension\"</span>\n        <span class=\"hljs-attr\">android:right</span>=<span class=\"hljs-string\">\"dimension\"</span>\n        <span class=\"hljs-attr\">android:bottom</span>=<span class=\"hljs-string\">\"dimension\"</span>\n        <span class=\"hljs-attr\">android:left</span>=<span class=\"hljs-string\">\"dimension\"</span> /&gt;</span> \n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">layer-list</span>&gt;</span>\n</code></pre>\n<p><span class=\"li-icon\"><code class=\"codetainer\">android:top=“dimension”</code> top에서 dimension 값만큼 padding</span></p>\n<h1>ShapeDrawable</h1>\n<p><span class=\"li-nonicon\">위치 : res/drawable/filename.xml</span>\n<span class=\"li-nonicon\">Java 리소스 참조 : R.drawable.filename</span>\n<span class=\"li-nonicon\">XML 리소스 참조 : @[package:]drawable/filename</span></p>\n<pre><code class=\"language-xml\"><span class=\"hljs-meta\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">shape</span>\n    <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">\"http://schemas.android.com/apk/res/android\"</span>\n    <span class=\"hljs-attr\">android:shape</span>=<span class=\"hljs-string\">[</span>\"<span class=\"hljs-attr\">rectangle</span>\" | \"<span class=\"hljs-attr\">oval</span>\" | \"<span class=\"hljs-attr\">line</span>\" | \"<span class=\"hljs-attr\">ring</span>\"] &gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">corners</span>\n        <span class=\"hljs-attr\">android:radius</span>=<span class=\"hljs-string\">\"integer\"</span>\n        <span class=\"hljs-attr\">android:topLeftRadius</span>=<span class=\"hljs-string\">\"integer\"</span>\n        <span class=\"hljs-attr\">android:topRightRadius</span>=<span class=\"hljs-string\">\"integer\"</span>\n        <span class=\"hljs-attr\">android:bottomLeftRadius</span>=<span class=\"hljs-string\">\"integer\"</span>\n        <span class=\"hljs-attr\">android:bottomRightRadius</span>=<span class=\"hljs-string\">\"integer\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">gradient</span>\n        <span class=\"hljs-attr\">android:angle</span>=<span class=\"hljs-string\">\"integer\"</span>\n        <span class=\"hljs-attr\">android:centerX</span>=<span class=\"hljs-string\">\"float\"</span>\n        <span class=\"hljs-attr\">android:centerY</span>=<span class=\"hljs-string\">\"float\"</span>\n        <span class=\"hljs-attr\">android:centerColor</span>=<span class=\"hljs-string\">\"integer\"</span>\n        <span class=\"hljs-attr\">android:endColor</span>=<span class=\"hljs-string\">\"color\"</span>\n        <span class=\"hljs-attr\">android:gradientRadius</span>=<span class=\"hljs-string\">\"integer\"</span>\n        <span class=\"hljs-attr\">android:startColor</span>=<span class=\"hljs-string\">\"color\"</span>\n        <span class=\"hljs-attr\">android:type</span>=<span class=\"hljs-string\">[</span>\"<span class=\"hljs-attr\">linear</span>\" | \"<span class=\"hljs-attr\">radial</span>\" | \"<span class=\"hljs-attr\">sweep</span>\"]\n        <span class=\"hljs-attr\">android:useLevel</span>=<span class=\"hljs-string\">[</span>\"<span class=\"hljs-attr\">true</span>\" | \"<span class=\"hljs-attr\">false</span>\"] /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">padding</span>\n        <span class=\"hljs-attr\">android:left</span>=<span class=\"hljs-string\">\"integer\"</span>\n        <span class=\"hljs-attr\">android:top</span>=<span class=\"hljs-string\">\"integer\"</span>\n        <span class=\"hljs-attr\">android:right</span>=<span class=\"hljs-string\">\"integer\"</span>\n        <span class=\"hljs-attr\">android:bottom</span>=<span class=\"hljs-string\">\"integer\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">size</span>\n        <span class=\"hljs-attr\">android:width</span>=<span class=\"hljs-string\">\"integer\"</span>\n        <span class=\"hljs-attr\">android:height</span>=<span class=\"hljs-string\">\"integer\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">solid</span>\n        <span class=\"hljs-attr\">android:color</span>=<span class=\"hljs-string\">\"color\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stroke</span>\n        <span class=\"hljs-attr\">android:width</span>=<span class=\"hljs-string\">\"integer\"</span>\n        <span class=\"hljs-attr\">android:color</span>=<span class=\"hljs-string\">\"color\"</span>\n        <span class=\"hljs-attr\">android:dashWidth</span>=<span class=\"hljs-string\">\"integer\"</span>\n        <span class=\"hljs-attr\">android:dashGap</span>=<span class=\"hljs-string\">\"integer\"</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">shape</span>&gt;</span>\n</code></pre>\n<p><span class=\"li-icon\"><code class=\"codetainer\">corners : </code>둥근모서리</span>\n<span class=\"li-icon\"><code class=\"codetainer\">gradient : </code>그라데이션 색상</span>\n<span class=\"li-icon\"><code class=\"codetainer\">padding : </code>shape가 아닌 view 요소에 적용할 패딩</span>\n<span class=\"li-icon\"><code class=\"codetainer\">size : </code>shape 크기</span>\n<span class=\"li-icon\"><code class=\"codetainer\">solid : </code>채우기 색상</span>\n<span class=\"li-icon\"><code class=\"codetainer\">stroke : </code>선 속성</span></p>\n<h1>실전예제</h1>\n<ol>\n<li>둥근모서리+그림자+투명배경 드로어블 생성하기</li>\n</ol>\n<p>res/drawable/round_border.xml</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-meta\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">layer-list</span> <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">\"http://schemas.android.com/apk/res/android\"</span> &gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">shape</span> <span class=\"hljs-attr\">android:shape</span>=<span class=\"hljs-string\">\"rectangle\"</span> &gt;</span>            \n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">solid</span> <span class=\"hljs-attr\">android:color</span>=<span class=\"hljs-string\">\"@android:color/darker_gray\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">shape</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">item</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span>\n        <span class=\"hljs-attr\">android:bottom</span>=<span class=\"hljs-string\">\"-2dp\"</span>\n        <span class=\"hljs-attr\">android:left</span>=<span class=\"hljs-string\">\"2dp\"</span>\n        <span class=\"hljs-attr\">android:right</span>=<span class=\"hljs-string\">\"2dp\"</span>\n        <span class=\"hljs-attr\">android:top</span>=<span class=\"hljs-string\">\"2dp\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">shape</span> <span class=\"hljs-attr\">android:shape</span>=<span class=\"hljs-string\">\"rectangle\"</span> &gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stroke</span>\n                <span class=\"hljs-attr\">android:width</span>=<span class=\"hljs-string\">\"0.75dp\"</span>\n                <span class=\"hljs-attr\">android:color</span>=<span class=\"hljs-string\">\"#f5f5f5\"</span> /&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">corners</span>\n                <span class=\"hljs-attr\">android:topLeftRadius</span>=<span class=\"hljs-string\">\"10dp\"</span>\n                <span class=\"hljs-attr\">android:topRightRadius</span>=<span class=\"hljs-string\">\"10dp\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">solid</span> <span class=\"hljs-attr\">android:color</span>=<span class=\"hljs-string\">\"#3cffffff\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">shape</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">item</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">layer-list</span>&gt;</span>\n</code></pre>\n<ol start=\"2\">\n<li>round_border를 LinearLayout의 배경으로 적용하기</li>\n</ol>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LinearLayout</span>\n        <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">\"match_parent\"</span>\n        <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">\"10dp\"</span>\n        <span class=\"hljs-attr\">android:background</span>=<span class=\"hljs-string\">\"@drawable/round_border\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">LinearLayout</span>&gt;</span>\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:23:54.379Z",
		"id": "2019-01-16-android-drawable",
		"filename": "android\\2019-01-16-android-drawable.json"
	},
	{
		"layout": "post-content",
		"title": "안드로이드에서 이미지 애니메이션 구현 방법",
		"date": "2019-01-21T00:00:00.000Z",
		"tags": [
			"android",
			"animation"
		],
		"category": [
			"android"
		],
		"body": "<p>이미지 애니메이션 구현 방법에는 다음과 같이 1)Animation Drawable과 2)Animated vector Drawable 두가지 옵션이 있다.</p>\n<hr>\n<p><a href=\"https://developer.android.com/guide/topics/graphics/drawable-animation?hl=ko\">안드로이드 개발문서-Animate drwable graphics 바로가기</a>\n<a href=\"https://www.androiddesignpatterns.com/2016/11/introduction-to-icon-animation-techniques.html\">Icon Animation 참고 문서</a></p>\n<p><strong>Animation Drawable</strong> : 몇 개의 정적 drawable 파일들을 순차적으로 보여주는 방식으로 애니메이션을 구현하고 싶을 때(프레임 애니메이션)<br>\n<strong>AnimatedVectorDrawable</strong> : 하나의 아이콘이 다른 이미지로 서서히 변화되는(morph) 애니메이션을 구현하고 싶을 때</p>\n<h1>AnimationDrawable 사용하기</h1>\n<p>프레임 애니메이션 구현 <a href=\"https://github.com/devgaram/AndroidBudgeter/blob/master/app/src/main/res/drawable/ani_emotion.xml\">예제</a></p>\n<p>res/drawable/ani_emotion.xml</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">animation-list</span> <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">\"http://schemas.android.com/apk/res/android\"</span>\n    <span class=\"hljs-attr\">android:oneshot</span>=<span class=\"hljs-string\">\"false\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span> <span class=\"hljs-attr\">android:drawable</span>=<span class=\"hljs-string\">\"@drawable/emotion_mouth_1\"</span> <span class=\"hljs-attr\">android:duration</span>=<span class=\"hljs-string\">\"5000\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span> <span class=\"hljs-attr\">android:drawable</span>=<span class=\"hljs-string\">\"@drawable/emotion_mouth_2\"</span> <span class=\"hljs-attr\">android:duration</span>=<span class=\"hljs-string\">\"5000\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span> <span class=\"hljs-attr\">android:drawable</span>=<span class=\"hljs-string\">\"@drawable/emotion_mouth_3\"</span> <span class=\"hljs-attr\">android:duration</span>=<span class=\"hljs-string\">\"5000\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span> <span class=\"hljs-attr\">android:drawable</span>=<span class=\"hljs-string\">\"@drawable/emotion_mouth_4\"</span> <span class=\"hljs-attr\">android:duration</span>=<span class=\"hljs-string\">\"5000\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span> <span class=\"hljs-attr\">android:drawable</span>=<span class=\"hljs-string\">\"@drawable/emotion_mouth_5\"</span> <span class=\"hljs-attr\">android:duration</span>=<span class=\"hljs-string\">\"5000\"</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">animation-list</span>&gt;</span>\n</code></pre>\n<p><span class=\"li-icon\"><code class=\"codetainer\">android:oneshot</code> : true 한번만, false 반복</span></p>\n<p>res/drawable/emotion_mouth_1.xml</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-meta\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">layer-list</span> <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">\"http://schemas.android.com/apk/res/android\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span>\n        <span class=\"hljs-attr\">android:top</span>=<span class=\"hljs-string\">\"@dimen/mb_l\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">shape</span>\n            <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">\"http://schemas.android.com/apk/res/android\"</span>\n            <span class=\"hljs-attr\">android:shape</span>=<span class=\"hljs-string\">\"rectangle\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">size</span>\n                <span class=\"hljs-attr\">android:width</span>=<span class=\"hljs-string\">\"120dp\"</span>\n                <span class=\"hljs-attr\">android:height</span>=<span class=\"hljs-string\">\"60dp\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">size</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">solid</span> <span class=\"hljs-attr\">android:color</span>=<span class=\"hljs-string\">\"@color/colorDefaultFont\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">corners</span>\n                <span class=\"hljs-attr\">android:topRightRadius</span>=<span class=\"hljs-string\">\"60dp\"</span>\n                <span class=\"hljs-attr\">android:topLeftRadius</span>=<span class=\"hljs-string\">\"60dp\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">corners</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">shape</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">item</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">layer-list</span>&gt;</span>\n</code></pre>\n<p><span class=\"li-icon\">ShapeDrawable로 입모양 그린 XML 파일</span></p>\n<p>res/drawable/activity_main.xml</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ImageView</span>\n            <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">\"@+id/emotion_mouth\"</span>\n            <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">\"wrap_content\"</span>\n            <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">\"wrap_content\"</span>\n            <span class=\"hljs-attr\">android:layout_gravity</span>=<span class=\"hljs-string\">\"center\"</span>\n            <span class=\"hljs-attr\">android:src</span>=<span class=\"hljs-string\">\"@drawable/ani_emotion\"</span> /&gt;</span>\n</code></pre>\n<p>MainActivity.java</p>\n<pre><code class=\"language-java\">AnimationDrawable emotionAnimation;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCreate</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span> </span>{\n  <span class=\"hljs-keyword\">super</span>.onCreate(savedInstanceState);\n  setContentView(R.layout.main);\n\n  ImageView emotionImage  = (ImageView) findViewById(R.id.emotion_mouth);\n  emotionImage.setImageResource(R.drawable.ani_emotion);\n  emotionAnimation = (AnimationDrawable) emotionImage.getDrawable();\n\n  emotionImage.setOnClickListener(<span class=\"hljs-keyword\">new</span> View.OnClickListener() {\n      <span class=\"hljs-meta\">@Override</span>\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onClick</span><span class=\"hljs-params\">(View view)</span> </span>{\n        emotionAnimation.start();\n      }\n  });\n}\n</code></pre>\n<p><span class=\"clr-note\"><strong>Note:</strong> </span><span class=\"clr-grey\"><code class=\"codetainer\">onCreate()</code> 메서드에선 <code class=\"codetainer\">AnimationDrawable</code>가 완전히 로드되지 않으므로 <code class=\"codetainer\">start()</code> 메서드를 사용할 수 없고,\n만약 애니메이션 즉시 실행을 원한다면 액티비티의 <code class=\"codetainer\">onStart()</code> 메서드에서 <code class=\"codetainer\">start()</code> 메서드를 호출해야한다.</span></p>\n<h1>AnimatedVectorDrawable 사용하기</h1>\n<p><a href=\"https://developer.android.com/reference/android/graphics/drawable/AnimatedVectorDrawable?hl=ko\">안드로이드 개발문서-AnimatedVectorDrawable 바로가기</a></p>\n<p>vectorDrawable은 흐려지거나 픽셀화되는 현상 없이 확장가능한 드로어블 타입이다.<br>\nvectorDrawable 애니메이션을 구현하기 위해서는 3개의 xml 파일이 필요하다.</p>\n<h2>1) vectorDrawable</h2>\n<table>\n<thead>\n<tr>\n<th>Element Name</th>\n<th>Animatable attribute name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&lt;vector&gt;</code></td>\n<td>alpha</td>\n</tr>\n<tr>\n<td><code>&lt;group&gt;</code></td>\n<td>rotation, pivotX, pivotY, scaleX, scaleY, translateX, translateY</td>\n</tr>\n<tr>\n<td><code>&lt;path&gt;</code></td>\n<td>pathData, fillColor, strokeColor, strokeColor, strokeWidth, strokeAlpha, fillAlpha, trimPathStart, trimPathEnd, trimPathOffset</td>\n</tr>\n<tr>\n<td><code>&lt;clip-path&gt;</code></td>\n<td>pathData</td>\n</tr>\n</tbody>\n</table>\n<pre><code class=\"language-xml\"> <span class=\"hljs-comment\">&lt;!--res/drawable/vectordrawable.xml--&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">\"http://schemas.android.com/apk/res/android\"</span>\n     <span class=\"hljs-attr\">android:height</span>=<span class=\"hljs-string\">\"64dp\"</span>\n     <span class=\"hljs-attr\">android:width</span>=<span class=\"hljs-string\">\"64dp\"</span>\n     <span class=\"hljs-attr\">android:viewportHeight</span>=<span class=\"hljs-string\">\"600\"</span>\n     <span class=\"hljs-attr\">android:viewportWidth</span>=<span class=\"hljs-string\">\"600\"</span> &gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">group</span>\n         <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">\"rotationGroup\"</span>\n         <span class=\"hljs-attr\">android:pivotX</span>=<span class=\"hljs-string\">\"300.0\"</span>\n         <span class=\"hljs-attr\">android:pivotY</span>=<span class=\"hljs-string\">\"300.0\"</span>\n         <span class=\"hljs-attr\">android:rotation</span>=<span class=\"hljs-string\">\"45.0\"</span> &gt;</span>\n         <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span>\n             <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">\"v\"</span>\n             <span class=\"hljs-attr\">android:fillColor</span>=<span class=\"hljs-string\">\"#000000\"</span>\n             <span class=\"hljs-attr\">android:pathData</span>=<span class=\"hljs-string\">\"M300,70 l 0,-70 70,70 0,0 -70,70z\"</span> /&gt;</span>\n     <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">group</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n</code></pre>\n<h2>2) AnimatedVectorDrawable</h2>\n<p><span class=\"li-nonicon\">한 개의 <code>android:drawable</code> 속성과 하나 이상의 <code>&lt;target&gt;</code>을 가진다.</span>\n<span class=\"li-nonicon\"><code>&lt;target&gt;</code> 은 <code>android:name</code> 속성으로 <code>ObjectAnimator</code> 또는 <code>AnimatorSet</code>의 타겟이 되는 <code>vectorDrawable</code>을 명시한다.\n<span class=\"clr-grey\"><strong>Note:</strong> 타겟은 vectorDrawable의 group element 또는 path element가 될 수 있다.</span></span></p>\n<pre><code class=\"language-xml\"><span class=\"hljs-comment\">&lt;!--res/drawable/animatedVector.xml--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">animated-vector</span> <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">\"http://schemas.android.com/apk/res/android\"</span>\n     <span class=\"hljs-attr\">android:drawable</span>=<span class=\"hljs-string\">\"@drawable/vectordrawable\"</span> &gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">target</span>\n         <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">\"rotationGroup\"</span>\n         <span class=\"hljs-attr\">android:animation</span>=<span class=\"hljs-string\">\"@animator/rotation\"</span> /&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">target</span>\n         <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">\"v\"</span>\n         <span class=\"hljs-attr\">android:animation</span>=<span class=\"hljs-string\">\"@animator/path_morph\"</span> /&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">animated-vector</span>&gt;</span>\n</code></pre>\n<p><span class=\"li-icon\">vectorDrawable에서 rotationGroup 이름 속성을 가진 <code>&lt;group&gt;</code> 엘리먼트에 rotation 애니메이션을 적용</span>\n<span class=\"li-icon\">vectorDrawable에서 v 이름 속성을 가진 <code>&lt;path&gt;</code> 엘리먼트에 path_morph 애니메이션을 적용</span></p>\n<h2>3) ObjectAnimator or AnimatorSet 애니메이션 정의</h2>\n<p>애니메이션은 <code>ObjectAnimator</code> 와 <code>AnimatorSet</code>으로 정의할 수 있다.</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-comment\">&lt;!-- res/animator/rotation.xml --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">objectAnimator</span>\n    <span class=\"hljs-attr\">android:duration</span>=<span class=\"hljs-string\">\"6000\"</span>\n    <span class=\"hljs-attr\">android:propertyName</span>=<span class=\"hljs-string\">\"rotation\"</span>\n    <span class=\"hljs-attr\">android:valueFrom</span>=<span class=\"hljs-string\">\"0\"</span>\n    <span class=\"hljs-attr\">android:valueTo</span>=<span class=\"hljs-string\">\"360\"</span> /&gt;</span>\n</code></pre>\n<p>6초동안 360도 회전하는 애니메이션</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-comment\">&lt;!-- res/animator/path_morph.xml --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">set</span> <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">\"http://schemas.android.com/apk/res/android\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">objectAnimator</span>\n        <span class=\"hljs-attr\">android:duration</span>=<span class=\"hljs-string\">\"3000\"</span>\n        <span class=\"hljs-attr\">android:propertyName</span>=<span class=\"hljs-string\">\"pathData\"</span>\n        <span class=\"hljs-attr\">android:valueFrom</span>=<span class=\"hljs-string\">\"M300,70 l 0,-70 70,70 0,0   -70,70z\"</span>\n        <span class=\"hljs-attr\">android:valueTo</span>=<span class=\"hljs-string\">\"M300,70 l 0,-70 70,0  0,140 -70,0 z\"</span>\n        <span class=\"hljs-attr\">android:valueType</span>=<span class=\"hljs-string\">\"pathType\"</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">set</span>&gt;</span>\n</code></pre>\n<p>3초동안 모양 바뀌는 애니메이션(morph)<br>\n<span class=\"clr-note\"><strong>Note:</strong> <code>android:valueFrom</code> 과 <code>android:valueTo</code>의 명령 순서와 파라미터 값은 동일해야한다.</span><br>\n<span class=\"clr-grey\"><strong>Note:</strong>  path 값은 string 리소스에 저장하는 것을 추천한다.</span></p>\n<h2>4) 3개의 xml을 AAPT 툴의 지원으로 하나의 xml에 정의할 수 있다.</h2>\n<pre><code class=\"language-xml\"> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">animated-vector</span> <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">\"http://schemas.android.com/apk/res/android\"</span>\n                  <span class=\"hljs-attr\">xmlns:aapt</span>=<span class=\"hljs-string\">\"http://schemas.android.com/aapt\"</span> &gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aapt:attr</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"android:drawable\"</span>&gt;</span>\n         <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span>\n             <span class=\"hljs-attr\">android:height</span>=<span class=\"hljs-string\">\"64dp\"</span>\n             <span class=\"hljs-attr\">android:width</span>=<span class=\"hljs-string\">\"64dp\"</span>\n             <span class=\"hljs-attr\">android:viewportHeight</span>=<span class=\"hljs-string\">\"600\"</span>\n             <span class=\"hljs-attr\">android:viewportWidth</span>=<span class=\"hljs-string\">\"600\"</span> &gt;</span>\n             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">group</span>\n                 <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">\"rotationGroup\"</span>\n                 <span class=\"hljs-attr\">android:pivotX</span>=<span class=\"hljs-string\">\"300.0\"</span>\n                 <span class=\"hljs-attr\">android:pivotY</span>=<span class=\"hljs-string\">\"300.0\"</span>\n                 <span class=\"hljs-attr\">android:rotation</span>=<span class=\"hljs-string\">\"45.0\"</span> &gt;</span>\n                 <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span>\n                     <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">\"v\"</span>\n                     <span class=\"hljs-attr\">android:fillColor</span>=<span class=\"hljs-string\">\"#000000\"</span>\n                     <span class=\"hljs-attr\">android:pathData</span>=<span class=\"hljs-string\">\"M300,70 l 0,-70 70,70 0,0 -70,70z\"</span> /&gt;</span>\n             <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">group</span>&gt;</span>\n         <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">aapt:attr</span>&gt;</span>\n\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">target</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">\"rotationGroup\"</span>&gt;</span> *\n         <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aapt:attr</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"android:animation\"</span>&gt;</span>\n             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">objectAnimator</span>\n             <span class=\"hljs-attr\">android:duration</span>=<span class=\"hljs-string\">\"6000\"</span>\n             <span class=\"hljs-attr\">android:propertyName</span>=<span class=\"hljs-string\">\"rotation\"</span>\n             <span class=\"hljs-attr\">android:valueFrom</span>=<span class=\"hljs-string\">\"0\"</span>\n             <span class=\"hljs-attr\">android:valueTo</span>=<span class=\"hljs-string\">\"360\"</span> /&gt;</span>\n         <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">aapt:attr</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">target</span>&gt;</span>\n\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">target</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">\"v\"</span> &gt;</span>\n         <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aapt:attr</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"android:animation\"</span>&gt;</span>\n             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">set</span>&gt;</span>\n                 <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">objectAnimator</span>\n                     <span class=\"hljs-attr\">android:duration</span>=<span class=\"hljs-string\">\"3000\"</span>\n                     <span class=\"hljs-attr\">android:propertyName</span>=<span class=\"hljs-string\">\"pathData\"</span>\n                     <span class=\"hljs-attr\">android:valueFrom</span>=<span class=\"hljs-string\">\"M300,70 l 0,-70 70,70 0,0 -70,70z\"</span>\n                     <span class=\"hljs-attr\">android:valueTo</span>=<span class=\"hljs-string\">\"M300,70 l 0,-70 70,0  0,140 -70,0 z\"</span>\n                     <span class=\"hljs-attr\">android:valueType</span>=<span class=\"hljs-string\">\"pathType\"</span>/&gt;</span>\n             <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">set</span>&gt;</span>\n         <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">aapt:attr</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">target</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">animated-vector</span>&gt;</span>\n</code></pre>\n<h2>5) 정의한 애니메이션 적용하기</h2>\n<p>res/drawable/activity_main.xml</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ImageView</span>\n            <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">\"@+id/emotion_mouth\"</span>\n            <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">\"wrap_content\"</span>\n            <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">\"wrap_content\"</span>\n            <span class=\"hljs-attr\">android:layout_gravity</span>=<span class=\"hljs-string\">\"center\"</span>\n            <span class=\"hljs-attr\">android:src</span>=<span class=\"hljs-string\">\"@drawable/animatedVector\"</span> /&gt;</span>\n</code></pre>\n<p>MainActivity.java</p>\n<pre><code class=\"language-java\"> ImageView emotionImage;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCreate</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span> </span>{\n  <span class=\"hljs-keyword\">super</span>.onCreate(savedInstanceState);\n  setContentView(R.layout.main);\n\n  emotionImage  = (ImageView) findViewById(R.id.emotion_mouth);\n  \n  emotionImage.setOnClickListener(<span class=\"hljs-keyword\">new</span> View.OnClickListener() {\n      <span class=\"hljs-meta\">@Override</span>\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onClick</span><span class=\"hljs-params\">(View view)</span> </span>{\n        Drawable drawable = emotionImage.getDrawable();\n            <span class=\"hljs-keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {\n                <span class=\"hljs-keyword\">if</span> (drawable <span class=\"hljs-keyword\">instanceof</span> AnimatedVectorDrawable) {\n                    AnimatedVectorDrawable animatedVectorDrawable = (AnimatedVectorDrawable) drawable;\n                    animatedVectorDrawable.start();\n                }\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-keyword\">if</span> (drawable <span class=\"hljs-keyword\">instanceof</span> AnimatedVectorDrawableCompat) {\n                    AnimatedVectorDrawableCompat animatedVectorDrawableCompat = (AnimatedVectorDrawableCompat) drawable;\n                    animatedVectorDrawableCompat.start();\n                }\n            }\n      }\n  });\n  \n}\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:23:54.379Z",
		"id": "2019-01-21-android-animate",
		"filename": "android\\2019-01-21-android-animate.json"
	},
	{
		"layout": "post-content",
		"title": "안드로이드 에러 - setText의 파라미터로 숫자를 전달했을 때",
		"date": "2019-03-10T00:00:00.000Z",
		"tags": [
			"android",
			"error"
		],
		"category": [
			"android"
		],
		"body": "<p>setText의 파라미터로 숫자를 전달했을 때 발생되는 에러로그</p>\n<hr>\n<p>에러로그</p>\n<pre><code>android.content.res.Resources$NotFoundException: String resource ID #0x1f40\nat android.content.res.Resources.getText(Resources.java:354)\nat android.widget.TextView.setText(TextView.java:6133)\nat org.androidtown.mybudgeter.pager.ExpenditureRecyclerAdapter.onBindViewHolder(ExpenditureRecyclerAdapter.java:30)\nat org.androidtown.mybudgeter.pager.ExpenditureRecyclerAdapter.onBindViewHolder(ExpenditureRecyclerAdapter.java:16)\n....      \n</code></pre>\n<pre><code class=\"language-java\">expenditureAmount.setText(currentExpenditure.getAmount());\n</code></pre>\n<p>에러로그는 위와 같은 코드에서 발생된 것으로, setText에 Integer 값을 전달했을 때 경우이다.<br>\nInteger값을 String으로 변환해주면 에러가 수정된다.</p>\n<pre><code class=\"language-java\">expenditureAmount.setText(Integer.toString(currentExpenditure.getAmount()));\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:24:37.656Z",
		"id": "2019-03-10-android-error-1",
		"filename": "android\\2019-03-10-android-error-1.json"
	},
	{
		"layout": "post-content",
		"title": "(코딩인터뷰) 시스템 설계 및 규모 확장성 이론",
		"date": "2019-08-28T00:00:00.000Z",
		"categories": [
			"codinginterview"
		],
		"body": "<p>(코딩인터뷰 완전분석) 책의 ‘시스템 설계 및 규모 확장성’ 파트를 정리한 글입니다.<br>\n이런 류의 질문에는 실제로 어떻게 행동할 것인지를 답하면 됩니다.</p>\n<hr>\n<h1>문제를 다루는 방법</h1>\n<ul>\n<li>면접관과 소통하기</li>\n<li>처음에는 포괄적으로 접근하기</li>\n<li>화이트보드에 제안하는 설계를 그리며 설명하기</li>\n<li>면접관이 짚은 문제점을 인정하고 적절히 수정하기</li>\n<li>가정을 할 때 주의하기</li>\n<li>가정을 할 때 그것을 면접관에게 알리기</li>\n<li>필요하다면 어림잡아 보기 예) 공간</li>\n<li>계속해서 깊이 파고들고 질문하기</li>\n</ul>\n<h1>시스템 설계 : 단계별 접근법</h1>\n<p>면접관 : TinyUrl과 같은 시스템을 설계해보세요.<br>\n지원자 : ???</p>\n<h2>1단계 : 문제의 범위를 한정하라</h2>\n<p>지원자 : 정확히 무엇을 구현해야 하는거지?..</p>\n<p>지원자는 위와 같은 물음이 생기기 마련이다.<br>\n질문을 통해 물음을 해결하지 않으면 지원자가 만들 시스템과 면접관이 원하는 것이 다를 수 있다.<br>\n아래와 같은 질문을 던지면서 문제의 범위를 한정해나가는 게 필요하다.</p>\n<ul>\n<li>개개인이 원하는 대로 축약된 URL을 만들 수 있어야 하나? 아니면 축약된 URL이 항상 자동으로 생성되는 건가?</li>\n<li>클릭에 관한 통계 정보를 기록할 필요가 있나?</li>\n<li>한번 설정된 URL은 영원히 없어지지 않는건가? 아니면 일정 시간이 지나면 삭제되는건가?</li>\n</ul>\n<h2>2단계 : 필요하다면 가정을 세워라, 단 합당해야 한다.</h2>\n<p>이러한 가정은 합당하지 않다.</p>\n<ul>\n<li>시스템이 하루에 100명의 사용자를 처리할 수 있으면 된다.</li>\n<li>메모리에 제약이 없다.</li>\n<li>URL이 제대로 동작하기까지 10분 걸린다.</li>\n</ul>\n<p>이러한 가정은 합당하다.</p>\n<ul>\n<li>하루에 최대 백만 개의 URL을 생성한다.</li>\n<li>최근 데이터에 대해 최대 10분 정도 오차가 있다.</li>\n</ul>\n<h2>3단계 : 중요한 부분을 먼저 그려라</h2>\n<p>화이트보드에 시스템의 주요 부분을 다이어그램으로 그린다.</p>\n<p>예시</p>\n<ul>\n<li>여러 개의 프론트엔드 서버가 백엔드에서 데이터를 받아 오는 시스템</li>\n<li>한 서버군은 크롤링, 다른 서버군은 크롤링 데이터를 분석하는 시스템</li>\n</ul>\n<p>예를 들어 TinyURL을 설계한다면</p>\n<p>지원자 : (사용자가 URL을 입력했을 때 어떤 식으로 진행되는 지 그린다) …</p>\n<h2>4단계 : 핵심 문제점을 찾아라</h2>\n<ul>\n<li>어느 부분이 병목지점일까?</li>\n<li>이 시스템이 풀어야 할 주된 문제는 무엇인가?</li>\n</ul>\n<p>예를 들어 TinyURL을 설계한다면 아래와 같은 문제점을 찾아내야한다.</p>\n<p>지원자 : 어떤 URL은 드물게 사용되는 반면 특정 URL의 사용량이 갑자기 치솟는 상황이라면…\n시스템이 끊임없이 데이터베이스를 읽어오면 안될텐데…</p>\n<h2>5단계 : 핵심 문제점을 해결할 수 있도록 다시 설계하라</h2>\n<p>핵심 문제에 맞게 설계를 수정한다. 전체를 갈아 엎을 수도 있고 자잘한 부분만 수정해서 해결할 수도 있다.</p>\n<p>지원자 : 캐시를 사용해서 해결하면 되려나…</p>\n<h1>규모 확장을 위한 알고리즘 : 단계별 접근법</h1>\n<p>면접관 : 시스템의 한 부분 혹은 알고리즘을 설계해보세요</p>\n<h2>1단계 : 질문하라</h2>\n<p>질문을 통해 문제를 확실히 이해해야한다.</p>\n<h2>2단계 : 현실적 제약을 무시하라</h2>\n<p>메모리 제약 없고, 컴퓨터 한 대에서 모든 데이터를 다 처리할 수 있다고 가정해서 풀어본다.</p>\n<h2>3단계 : 현실로 돌아오라</h2>\n<ul>\n<li>컴퓨터 한 대에 저장할 수 있는 데이터 크기에 대해 생각하기</li>\n<li>데이터를 여러 조각으로 쪼갰을 때 어떤 문제가 발생할지 생각하기</li>\n<li>데이터를 여러 조각으로 쪼갤 때 어떤 논리로 데이터를 나눌 것인지 생각하기</li>\n<li>데이터를 여러 조각으로 쪼갤 때 특정 컴퓨터가 어느 데이터 조각을 사용했는지 어떻게 알 수 있을 것인지</li>\n</ul>\n<h2>4단계 : 문제를 풀어라</h2>\n<p>순환적 접근법을 이용한다.</p>\n<h1>시스템 설계의 핵심 개념</h1>\n<h2>수평적 vs 수직적 규모 확장</h2>\n<ul>\n<li>수직적 규모 확장 : 특정 노드의 자원의 양을 늘리는 방법 예) 서버에 메모리 추가</li>\n<li>수평적 규모 확장 : 노드의 개수를 늘리는 방법 예) 서버를 추가해서 서버 한 대가 다루는 부하를 줄인다.</li>\n</ul>\n<h2>서버 부하 분산 장치(load balancer)</h2>\n<p>일반적으로 규모 확장성이 있는 웹사이트의 프론트엔드 부분은 서버 부하 분산 장치를 통해서 제공된다.<br>\n이렇게 해야 서버에 걸리는 부하를 여러 대의 서버에 균일하게 분신시킬 수 있고 서버 한대 때문에 전체 시스템이 죽거나\n다운되는 상황을 방지할 수 있다.<br>\n물론 서버 여러 대가 근본적으로 똑같은 코드와 데이터를 사용하도록 하는 네트워크를 구현해놔야 한다.</p>\n<h2>데이터베이스 역정규화(denormalization)와 NoSQL</h2>\n<p>SQL 같은 RDMS의 조인 연산은 시스템이 커질수록 굉장히 느려지므로 가능하면 피해야 한다.</p>\n<p>역정규화란?<br>\n데이터베이스에 여분의 정보를 추가해서 읽기 연산 속도를 향상시킨 것을 의미한다.</p>\n<p>예를 들어, 한 프로젝트가 여러 과제를 수행하도록 설계된 데이터베이스를 생각해보자.<br>\n이 데이터베이스에서 프로젝트 이름이랑 과제 정보를 함께 알고 싶은 경우에 두 테이블을 조인하기보단\n애초에 과제 테이블에 프로젝트 이름 정보를 추가로 저장해 놓으면 더 빠르게 작업을 수행할 수 있다.</p>\n<p>혹은, NoSQL 데이터베이스를 이용하면 된다.\nNoSQL은 초고용량 데이터 처리 등 성능에 특화된 목적을 위해, 비관계형 데이터 저장소에, 비구조적인 데이터를 저장하기 위한 분산 저장 시스템이다.<br>\n저장되는 데이터 구조는 주로 Key-Value 형태이다.<br>\n예) 몽고DB<br>\nNoSQL의 특징</p>\n<ul>\n<li>관계형 모델을 사용하지 않으며 테이블간의 조인 기능 없음</li>\n<li>직접 프로그래밍을 하는 등의 비SQL 인터페이스를 통한 데이터 액세스</li>\n<li>대부분 여러 대의 데이터베이스 서버를 묶어서(클러스터링) 하나의 데이터베이스를 구성</li>\n<li>관계형 데이터베이스에서는 지원하는 Data처리 완결성(Transaction ACID 지원) 미보장</li>\n<li>데이터의 스키마와 속성들을 다양하게 수용 및 동적 정의 (Schema-less)</li>\n<li>데이터베이스의 중단 없는 서비스와 자동 복구 기능지원</li>\n<li>다수가 Open Source로 제공</li>\n<li>확장성, 가용성, 높은 성능</li>\n</ul>\n<h1>데이터베이스 분할(샤딩)</h1>\n<p>샤딩(sharding)은 데이터를 여러 컴퓨터에 나눠서 저장하는 동시에 어떤 데이터가 어떤 컴퓨터에 저장되어 있는지 알 수 있는 방식을 말한다.</p>\n<ul>\n<li>수직적 분할 : 자료의 특성별로 분할 예) SNS를 만든다면, 개인정보 부분과 메시지 부분으로 자료를 분할 (특정 테이블의 크기가 일정 수준 이상으로 커질 수 있음)</li>\n<li>키 혹은 해시 기반 분할 : mod(key, n)의 값을 이용해서 N개의 서버에 분할 (서버의 개수가 고정되어 있어야 하며, 서버를 새로 추가할 때마다 모든 데이터를 재분배 해야함)</li>\n<li>디렉터리 기반 분할 : 데이터를 찾을 때 사용되는 조회 테이블(lookup table)을 유지하는 방법, 서버 추가하기는 쉬움 (조회 테이블이 *단일 장애 지점이 될 수 있음, 지속적으로 테이블 읽는 행위가 전체 성능에 영향을 미칠 수 있음)</li>\n</ul>\n<p><span class=\"clr-grey\">*단일 장애 지점 : 네트워크의 한 지점(노드)의 장애가 전체 네트워크(시스템)의 장애를 초래하는 것</span></p>\n<h2>캐싱(caching)</h2>\n<p>인메모리(in-memory) 캐시를 사용하면 결과를 빠르게 가져올 수 있다.</p>\n<ul>\n<li>KEY-VALUE 쌍의 구조</li>\n<li>애플리케이션과 데이터 저장소 사이에 자리잡고 있음</li>\n<li>쿼리와 그 결과를 캐시하는 경우가 많음</li>\n<li>특정 객체를 캐시에 저장할 수 있음</li>\n</ul>\n<p>애플리케이션이 어떤 자료를 요청 -&gt; 캐시를 먼저 확인 -&gt; 캐시가 해당 키 값을 갖고 있지 않음 -&gt; 데이터 저장소에서 자료 가져옴</p>\n<p>예) 웹 페이지의 어떤 부분을 렌더링한 결과나 블로그에 올라온 최근 포스팅 리스트를 캐시에 갖고 있음</p>\n<h2>비동기식 처리 &amp; 큐</h2>\n<p>이상적이라면, 속도가 느린 연산은 비동기식으로 처리해야 한다.<br>\n그렇지 않으면 해당 연산이 끝나기까지 하염없이 기다려야 할 수도 있기 때문이다.</p>\n<p>어떤 경우에는 연산을 미리 해 큐에 넣을 수도 있다.</p>\n<p>예) 포럼 웹사이트에서 큐에 들어 있는 작업 중 하나는 가장 최근의 글들과 몇가지 코멘트를 보여주는 페이지를 다시 만들어 주는 일이다.<br>\n새로운 코멘트 하나 때문에 캐시미스가 나서 웹사이트를 새로 불러오는 것보다 큐의 데이터를 이용해 약간 오래되어 덜 정확한 최신 글 리스트를\n보여주는 것이 낫다.</p>\n<h2>네트워크 성능 척도</h2>\n<ul>\n<li>대역폭(bandwidth) : 단위 시간에 전송할 수 있는 데이터의 최대치 (초당 몇 비트(혹은, 몇 기가 바이트)를 보낼 수 있는 가)</li>\n<li>처리량(throughput) : 단위 시간에 실제로 전송된 데이터의 양</li>\n<li>지연 속도(latency) : 데이터를 전송하는 데 걸리는 시간 (발송자가 데이터를 보낸 시점 - 수신자가 데이터를 받는 지점)</li>\n</ul>\n<h2>MapReduce</h2>\n<p>많은 과정을 병렬로 처리할 수 있게 도와주며 굉장히 커다란 데이터를 처리하는 데 사용</p>\n<ul>\n<li>Map은 데이터를 입력으로 받은 뒤 key-value 쌍을 반환한다.</li>\n<li>Reduce는 키와 관련된 값들을 입력으로 받은 뒤 나름의 처리 과정을 거친 뒤 새로운 키와 값을 반환하다.</li>\n</ul>\n<h1>시스템 설계 시 고려할 점</h1>\n<ul>\n<li>실패 : 실패에 대한 대비책</li>\n<li>가용성 및 신뢰성 : 가용성은 사용 가능한 시스템의 시간을 백분율로 나타낸 것, 신뢰성은 특정 단위 시간에 시스템이 사용 가능할 확률</li>\n<li>읽기 중심 vs 쓰기 중심 : 쓰는 연산이 많으면 큐를 사용하는 방법이 좋음, 읽는 연산이 많으면 캐시를 사용하는 것이 좋음</li>\n<li>보안</li>\n</ul>\n<h1>연습문제</h1>\n<p>수백만 개의 문서가 주어졌을 때, 특정 단어 리스트가 포함된 문서를 찾으려고 한다.<br>\n어떻게 할 수 있을까? 단어가 등장하는 순서는 중요하지 않지만, 해당 단어가 완벽하게 나타나야 한다.</p>\n<p>findwords를 같은 문서 집합에 대해서 여러 번 호출한다고 가정한다.</p>\n<h2>1단계</h2>\n<p>현실적 제약을 무시해보고 문서가 수십 개 있을 때로 가정하여 문제를 풀어본다.<br>\nfindWords를 어떻게 구현할까…?</p>\n<p>전처리 과정을 통해 모든 문서에 대한 해시테이블을 만든다.<br>\n해시테이블은 단어와 해당 단어를 포함하는 문서 리스트에 대한 정보를 담고 있다.</p>\n<p>“books” -&gt; {doc2, doc3, doc6, doc8}<br>\n“many” -&gt; {doc1, dod3, doc7, doc8, doc9}</p>\n<p>&quot;many books&quot;를 탐색한다면, &quot;books&quot;와 &quot;many&quot;의 교집합을 구하면 된다. {doc3, doc8}</p>\n<h2>2단계</h2>\n<p>현실로 돌아와 문서의 개수를 수백만 개로 늘려본다.<br>\n어떻게 해야할까?<br>\n일단, 문서를 여러 대의 컴퓨터로 나눠서 보내야 할 것이다.<br>\n또한 단어의 수나 출현 빈도 등 때문에 해시테이블조차도 한 컴퓨터에 온전히 보관할 수 없을 수 있다.</p>\n<p>실제로 해시테이블도 분할해서 저장해야 하는 상황이 벌어졌다고 가정해보자.<br>\n그러면 다음과 같은 고민을 해야한다.</p>\n<ul>\n<li>해시테이블은 어떻게 분할하지? 키워드에 따라? 문서에 따라?</li>\n<li>데이터를 분할하기로 결정하면, 어떤 컴퓨터에서는 문서를 처리하고 그 처리 결과를 다른 컴퓨터로 옮겨야 할텐데 어떻게 정의할 수 있을까?</li>\n<li>어떤 컴퓨터에 어떤 데이터가 보관되어 있는지 알 수 있어야 할텐데… 그리고 조회 테이블의 형태는? 조회 테이블은 어디에 두어야 되지?</li>\n</ul>\n<h2>3단계</h2>\n<p>문제점에 대한 해법을 찾아야 한다.\n한 가지 방법은 키워드를 알파벳 순서에 따라 분할하는 것이다.<br>\n즉, 한 컴퓨터가 특정한 범위의 단어들(예, after~apple)만 통제하게 하는 것이다.<br>\n키워드를 알파벳 순서로 돌면서 가능한 데이터를 저장하는 알고리즘은 쉽게 구현할 수 있다. 용량이 꽉 차면, 다른 컴퓨터로 옮겨 가야 한다.</p>\n<p>장점 : 조회 테이블을 작고 단순하게 만들 수 있음, 각 컴퓨터에 조회 테이블의 복사본을 저장할 수 있음<br>\n단점 : 새로운 문서나 단어 추가시 키워드를 굉장히 많이 이동시킴</p>\n<p>“after builds boat amaze banana”</p>\n<p>컴퓨터에 키워드가 알파벳 순서로 분할되어 있으니 문자열을 정렬한 후 요청을 보낸다.</p>\n<p>일번 컴퓨터는 “after~apple” 범위의 키워드가 있으니 after와 amaze에 대한 요청을 보내고, builds, boat, banana는 삼번 컴퓨터 범위에 해당되므로\n삼번 컴퓨터로 요청을 보낸다.<br>\n각 컴퓨터에서 요청 사항에 대한 교집합을 구하여 반환한다.<br>\n마지막으로, 초반에 전체 요청을 보낸 컴퓨터는 일번과 삼번의 컴퓨터로 부터 받은 결과의 교집합을 구하면 된다.</p>\n",
		"updatedAt": "2020-01-22T18:25:35.092Z",
		"id": "2019-08-28-coding-interview",
		"filename": "algorithm\\2019-08-28-coding-interview.json"
	},
	{
		"layout": "post-content",
		"title": "(코딩인터뷰) 시스템 설계 및 규모 확장성 문제 1 - 중복 URL",
		"date": "2019-08-30T00:00:00.000Z",
		"categories": [
			"codinginterview"
		],
		"body": "<p>코딩 인터뷰 완전분석 (CRACKING THE CODING INTERVIEW 6/E) / 게일 라크만 맥도웰 지음 / 인사이트</p>\n<hr>\n<h1>Q. 중복 URL : 100억 개의 URL이 있다. 중복된 문서를 찾으려면 어떻게 해야 하는가? 여기서 '중복’이란 '같은 URL’이라는 뜻이다.</h1>\n<h2>내풀이</h2>\n<p>만약 100억 개의 URL을 저장할 수 있는 충분한 공간이 있다면, 리스트를 정렬한 후 중복된 값 찾으면 될 것 같다.<br>\n아니면 100억 개의 URL을 해시테이블에 저장하는 전처리 과정을 하면 전처리 과정 중에도 중복된 문서를 찾을 수 있고\n그 후 데이터가 추가될 때도 쉽게 중복 여부를 확인할 수 있을 것 같다.</p>\n<h2>책풀이</h2>\n<h2>1단계 : 합당한 가정을 세운다.</h2>\n<p>책은 100억 개의 URL을 처리하기위한 공간을 계산하기위해 다음과 같은 합당한 가정을 세운다.</p>\n<ul>\n<li>각 URL이 평균적으로 100개의 문자로 구성되어 있고 각 문자는 4바이트라고 가정한다.</li>\n<li>100(문자) * 4(bytes) * 100억(url개수) = 4,000,000,000,000 bytes = 4 * 10<sup>12</sup> = 4TB</li>\n<li>즉, 100억 개의 URL을 처리하기위해서는 4TB 정도의 메모리 공간이 필요하다.</li>\n</ul>\n<h2>2단계 : 현실적 제약을 무시한다.</h2>\n<p>모든 데이터를 메모리에 보관할 수 있다고 가정한 후 문제에 접근한다.</p>\n<p>이미 살펴본 URL에 대해 true를 반환하는 해시테이블을 사용하여 문제를 해결할 수 있다.<br>\n리스트를 정렬하는 방식은 시간도 더 들고 장점도 없다.</p>\n<h2>3단계 : 현실로 돌아온다.</h2>\n<p>4TB의 데이터를 메모리(RAM)에 전부 올릴 수 없는 상황에서 어떻게 해야하는지 생각한다.</p>\n<p><strong>해법 #1 : 디스크 저장</strong></p>\n<p>각 URL을 .txt 파일에 저장한다.<br>\n.txt 파일의 크기는 1GB(10<sup>9</sup>)로 4TB URL을 저장하기위해서는 4000개의 파일이 필요하다.<br>\nx = hash(u) % 4000로 저장할 .txt 파일을 결정한다.<br>\n같은 해시값을 갖는 URL은 같은 파일에 저장된다.<br>\n각 파일을 메모리에 올려 URL의 해시테이블을 생성한 다음에 중복이 존재하는 지 확인하면 된다.</p>\n<p><strong>해법 #2 : 데이터를 여러 서버에 분할</strong></p>\n<p>본질적으로는 해법1과 같으나, 여러 서버를 사용한다는 차이가 있다.<br>\nURL을 .txt라는 파일에 저장하는 대신 서버 x에 전송하는 것이다.</p>\n<ul>\n<li>장점 : 병렬처리가능</li>\n<li>단점 : 4000개의 서버가 완벽 동작해야함(비현실적)</li>\n</ul>\n",
		"updatedAt": "2020-01-22T18:25:35.092Z",
		"id": "2019-08-30-coding-interview-question-1",
		"filename": "algorithm\\2019-08-30-coding-interview-question-1.json"
	},
	{
		"layout": "post-content",
		"title": "(코딩인터뷰) 시스템 설계 및 규모 확장성 문제 2 - 소셜네트워크",
		"date": "2019-08-30T00:00:00.000Z",
		"categories": [
			"codinginterview"
		],
		"body": "<p>코딩 인터뷰 완전분석 (CRACKING THE CODING INTERVIEW 6/E) / 게일 라크만 맥도웰 지음 / 인사이트</p>\n<hr>\n<h1>Q. 소셜 네트워크 : 페이스북이나 링크드인과 같은 대규모 소셜 네트워크를 위한 자료구조는 어떻게 설계하겠는가? 두 사람 사이의 최단 경로를 보여주는 알고리즘은 어떻게 설계하겠는가? (가령, 나-&gt;밥-&gt;수잔-&gt;제이슨-&gt;당신)</h1>\n<h2>내풀이</h2>\n<p>'나’를 기준으로 '나’의 친구들을 연결할 필요가 있고, '친구’의 친구들을 연결할 필요가 있다.<br>\n각 사용자를 '노드’로 정의하고 관계를 '에지’로 정의한다고 하면 자료구조로 그래프를 사용하는 게 적절하다고 생각한다.<br>\n사용자 간의 경로 탐색은 너비우선탐색(BFS)로 하는 것이 적절하다고 생각한다.\n'나’를 기준으로 동심원을 그리며 찾는 것이 깊이우선탐색(DFS)보다 낫다.\nDFS는 '노드’를 기준으로 방문하지않은 노드 끝까지 갔다가 돌아가는 식으로 탐색하므로 최단경로가 아닐 수도 있다.</p>\n<h2>책풀이</h2>\n<h2>단계1 : 문제를 단순화하기 - 수백만이 아닌 10명의 사용자로 생각해보기</h2>\n<p>각 사용자를 노드, 친구 관계를 간선으로 설정하여 하나의 그래프를 만들 수 있다.<br>\n두 사용자 간의 경로는 한 사용자에서 시작해서 너비 우선 탐색을 돌려보면된다.\n혹은 양방향 너비 우선 탐색을 할 수도 있다.<br>\n하나는 출발지에서, 나머지 하나는 도착지에서 시작해서 너비 우선 탐색 두 개를 동시에 돌리는 것을 말한다.<br>\n두 탐색이 어느 지점에서 충돌하는 순간 경로를 찾은 것이다.</p>\n<p><strong>깊이우선탐색을 사용하지 않는 이유는?</strong><br>\n깊이 우선 탐색은 단순히 경로 하나를 찾기 때문이고, 이 경로가 가장 짧은 경로가 아닐 수도 있다.<br>\n또한, 경로 하나를 찾는 과정도 비효율적이다. 두 사용자가 1촌 관계라 하더라도 하위 트리에 존재하는 수백만 개의 노드를 탐색하게 될 수 있기 때문이다.</p>\n<p><strong>구현방법</strong><br>\n<img src=\"/assets/images/2019-08-30-img/2-1.jpg\" alt=\"1\">    <br/>\n<img src=\"/assets/images/2019-08-30-img/2-2.jpg\" alt=\"2\">     <br/>\n<img src=\"/assets/images/2019-08-30-img/2-3.jpg\" alt=\"3\">     <br/>\n<img src=\"/assets/images/2019-08-30-img/2-4.jpg\" alt=\"4\">     <br/></p>\n<p>양방향 너비 우선 탐색이 일반 너비 우선 탐색보다 빠르다.<br>\nS와 D가 친구 C를 공유할 때, (각 사용자는 K명의 친구가 있다, q는 경로의 길이)</p>\n<ul>\n<li>일반적인 너비 우선 탐색으로 S -&gt; D로 가려면 대략 K + K*K개의 노드를 거쳐야 한다. = Q(K<sup>q</sup>)</li>\n<li>양방향 너비 우선 탐색은 S 친구 K, D친구 K로 2K 노드만 거치면 된다. = Q(K<sup>q/2</sup>)</li>\n</ul>\n<p>단, 양방향 너비 우선 탐색은 시작 지점과 도착 지점 모두 접근 가능할 때에나 사용 가능하다.</p>\n<h2>단계2 : 수백만 사용자의 처리</h2>\n<p>링크드인이나 페이스북 규모의 서비스를 만들 때에는 컴퓨터 하나만으로는 부족하다.<br>\n다시 말해 Person을 위와 같이 단순하게 설계해서는 제대로 동작하지 않을 것이라는 뜻이다.<br>\n우리가 찾는 '친구’는 같은 서버에 있지 않을 수도 있다.<br>\n따라서 ID로 구성되는 친구 리스트를 만들고, ID를 통해 해당 사용자 정보가 있는 컴퓨터 정보를 얻는다.<br>\n얻은 컴퓨터 정보 안에서 사용자 정보를 다시 탐색한다.<br>\n효율적 탐색을 위해서 해시테이블을 사용한다.</p>\n<p><strong>최적화하기</strong></p>\n<ul>\n<li>다른 서버에 대한 탐색을 줄인다.</li>\n<li>컴퓨터에 사용자 정보를 분배할 때, 무작위로 나누는 것이 아닌 사용자가 거주하는 나라나 시, 도, 군 등의 정보를 이용한다.</li>\n</ul>\n",
		"updatedAt": "2020-01-22T18:25:35.093Z",
		"id": "2019-08-30-coding-interview-question-2",
		"filename": "algorithm\\2019-08-30-coding-interview-question-2.json"
	},
	{
		"layout": "post-content",
		"title": "(코딩인터뷰) 시스템 설계 및 규모 확장성 문제 3 - 웹 크롤러",
		"date": "2019-08-30T00:00:00.000Z",
		"categories": [
			"codinginterview"
		],
		"body": "<p>코딩 인터뷰 완전분석 (CRACKING THE CODING INTERVIEW 6/E) / 게일 라크만 맥도웰 지음 / 인사이트</p>\n<hr>\n<h1>Q. 웹 크롤러 : 웹에 있는 데이터를 긁어 오는 크롤러를 설계할 때, 무한루프에 빠지는 일을 방지하려면 어떻게 해야 하는가?</h1>\n<h2>무한루프는 어떻게 발생하는가?</h2>\n<p>단순히 웹의 링크에 의해 만들어지는 그래프로 볼 경후, 사이클이 존재하면 무한루프가 발생할 수 있다.<br>\n따라서 무한루프를 막으려면 사이클을 탐지해야 한다.<br>\n그러기 위해선 해시테이블을 두고 이미 방문한 페이지 v의 hash[v] 값을 true로 바꿔줘야 한다.<br>\n이 해법은 웹을 너비 우선으로 탐색한다는 것을 의미한다.</p>\n<h2>페이지 v를 방문한다는 것의 의미</h2>\n<ol>\n<li>단순히 URL 기준으로 판단해야 할까?</li>\n<li>페이지 내용에 따라 방문 여부를 확인해야 할까?</li>\n</ol>\n<p>1번의 경우는 URL의 파라미타 값이 달라졌을 때 실제로 페이지는 달라지지 않을 때를 생각해야한다.<br>\n2번의 경우 같은 페이지라 할지라도 내용이 무작위로 생성된다면 다른 페이지라고 해야하는 지를 생각해봐야한다.<br>\n즉, 이 페이지가 저 페이지와 ‘다른’ 페이지인지 판단하는 완벽한 방법은 없는 셈이다.</p>\n<p>이 문제를 해결하는 방법은 페이지 내용과 URL을 토대로 페이지 간의 유사성을 가늠해 보는 것이다.</p>\n<ul>\n<li>크롤러가 탐색해야 하는 항목들을 데이터베이스에 저장해 둔다.</li>\n<li>탐색 우선순위가 가장 높은 페이지를 고른다.</li>\n<li>페이지를 열어 해당 페이지의 특정한 섹션과 URL을 토대로 시그니처를 생성한다.</li>\n<li>데이터베이스 쿼리를 통해 해당 시그니처의 페이지가 최근에 탐색된 적 있는지 살핀다.</li>\n<li>만일 해당 시그니처를 갖는 페이지가 최근에 탐색된 적이 있으면 해당 페이지의 우선순위를 낮춰서 데이터베이스에 추가한다.</li>\n<li>그렇지 않다면 해당 페이지를 탐색하고, 그 페이지에 연결된 링크를 데이터베이스에 추가한다.</li>\n</ul>\n",
		"updatedAt": "2020-01-22T18:25:35.106Z",
		"id": "2019-08-30-coding-interview-question-3",
		"filename": "algorithm\\2019-08-30-coding-interview-question-3.json"
	},
	{
		"layout": "post-content",
		"title": "(코딩인터뷰) 시스템 설계 및 규모 확장성 문제 4 - 캐시",
		"date": "2019-08-30T00:00:00.000Z",
		"categories": [
			"codinginterview"
		],
		"body": "<p>코딩 인터뷰 완전분석 (CRACKING THE CODING INTERVIEW 6/E) / 게일 라크만 맥도웰 지음 / 인사이트</p>\n<hr>\n<h1>Q. 캐시 : 간단한 검색 엔진으로 구현된 웹 서버를 생각해보자. 이 시스템에선 100개의 컴퓨터가 검색 요청을 처리하는 역할을 하고 있다. 예를 들어 하나의 컴퓨터 집단에 processSearch(string query)라는 요청을 보내면 그에 상응하는 검색 결과를 반환해 준다. 하지만 어떤 컴퓨터가 요청을 처리하게 될지는 그때그때 다르며, 따라서 같은 요청을 한다고 같은 컴퓨터가 처리할 거라고 장담할 수 없다. processSearch 메서드는 아주 고비용이다. 최근 검색 요청을 캐시에 저장하는 메커니즘을 설계하라. 데이터가 바뀌었을 때 어떻게 캐시를 갱신할 것인지 반드시 설명하라.</h1>\n<h2>가정을 통해 문제를 구체화하자</h2>\n<ul>\n<li>필요할 때 processSearch를 호출하는 것 이외에도, 모든 쿼리는 최초로 호출된 서버에서 처리된다.</li>\n<li>캐시하고자 하는 쿼리의 수는 굉장히 크다(수백만 개)</li>\n<li>서버 간 호출은 상대적으로 빨리 처리된다.</li>\n<li>쿼리의 결과는 정렬된 URL 리스티이다. 각 원소에는 최대 50글자의 제목과 200글자의 요약문이 따라 붙는다.</li>\n<li>가장 인기 있는 쿼리의 경우 항상 캐시에 보관되어 있다.</li>\n</ul>\n<h2>시스템 요구 사항을 정리하자</h2>\n<ol>\n<li>최근 검색 요청을 캐시에 저장해야 한다.</li>\n<li>캐시를 통해 빠른 탐색이 가능해야 한다.</li>\n<li>쿼리 결과가 변경될 경우 캐시를 변경하거나 삭제할 수 있어야 한다.</li>\n</ol>\n<h2>단순하게 생각하자 - 요구사항 1, 2번</h2>\n<p>단순하게 컴퓨터가 하나일 경우로 가정하여 설계해본다.</p>\n<p>빠른 탐색이 가능하려면 key-value 쌍의 자료구조인 해시맵을 사용하는 게 적절할 것 같다.<br>\n쿼리를 해시 처리하여 key값을 생성하고 쿼리의 결과 값을 value로 해서 해시맵에 저장하면 될 듯 싶다.</p>\n<p>첫번째 요구사항을 보면 캐시에 최신 검색 순으로 저장될 필요가 있다. 데이터를 순서대로 저장해야 한다.<br>\n하지만 해시맵은 데이터의 순서를 기억하기에는 적절치 못한 자료구조다.<br>\n순서를 위한 자료구조는 배열과 연결리스트가 있는데 최신 검색의 삽입과 오래된 검색의 삭제가 빈번하므로 연결리스트 자료구조가 적절하지 않을까?<br>\n그러나, 연결리스트는 탐색 시 Q(N) 시간이라 빠른 탐색이 힘들다…</p>\n<p>어떻게 할까?<br>\n두 자료구조를 합치면 어떨까?</p>\n<p>이는 LRU 캐시를 구현하라는 것과 같다.<br>\nLRU는 OS의 페이지 교체 알고리즘의 하나로 최근에 가장 오랫동안 사용되지 않은 페이지를 교체하는 기법이다.\n다음은 LRU 캐시 구현 그림이다.</p>\n<p><img src=\"/assets/images/2019-08-30-img/4-1.jpg\" alt=\"1\">    <br/></p>\n<h2>이제 현실로 돌아와서 생각하자 - 여러 서버로 확장</h2>\n<p><strong>방법1 - 각 서버에 별도의 캐시를 둔다</strong></p>\n<p>서버 1에 같은 쿼리를 2번 보내면, 두 번째 처리 결과는 캐시에서 가져온다.<br>\n그러나 서버 1에 보냈다가 서버 2에 보내면 서버 2는 해당 쿼리를 새로운 쿼리로 처리한다.</p>\n<ul>\n<li>장점 : 서버 간 통신이 필요없기에 상대적으로 빠르다.</li>\n<li>단점 : 같은 쿼리가 반복되도 새로운 쿼리로 인식하기 때문에 최적화를 위한 방법으로 부적절</li>\n</ul>\n<p><strong>방법2 - 각 서버에 캐시 복사본을 둔다</strong></p>\n<p>각 서버에 전체 캐시의 완전한 복사본을 유지하는 방법이다.<br>\n새로운 데이터가 캐시에 추가되는 순간 그 데이터는 모든 서버로 보내진다.<br>\n따라서 연결리스트와 해시테이블을 비롯한 모든 자료구조가 중복되어 저장된다.</p>\n<ul>\n<li>장점 : 어느 서버에서도 동일하게 존재하기 때문에 빈번하게 사용되는 쿼리와 실행 결과는 항상 캐시 내에 존재한다.</li>\n<li>단점1 : 캐시를 갱신할 때마다 데이터를 N개의 서로 다른 서버로 전송해야 한다는 점</li>\n<li>단점2 : 각 캐시를 저장하기 위해 N배 더 큰 공간이 필요하므로 캐시에 저장 가능한 항목의 수가 줄어든다.</li>\n</ul>\n<p><strong>방법3 - 각 서버에 캐시의 일부를 저장한다</strong></p>\n<p>캐시를 분할하여 각 서버에 그 일부만을 보관한다.<br>\n예를 들어, 서버 i가 어떤 쿼리에 대한 결과를 알고 싶다고 하자.</p>\n<p><img src=\"/assets/images/2019-08-30-img/4-2.jpg\" alt=\"1\">    <br/></p>\n<h2>요구 사항 3번을 해결하자</h2>\n<ul>\n<li>요구사항 3 : 쿼리 결과가 변경될 경우 캐시를 변경하거나 삭제할 수 있어야 한다.</li>\n</ul>\n<p>캐시가 충분히 클 경우 어떤 쿼리는 너무 빈번해서 항상 캐시에 남아 있을 수 있다.<br>\n따라서 주기적으로 혹은 어떤 쿼리 결과가 변경되었을 때마다 캐시에 보관된 결과를 갱신할 수 있는 방법이 필요하다.</p>\n<p>쿼리의 결과가 바뀌는 순간</p>\n<ol>\n<li>URL이 가리키는 페이지 내용이 바뀔 때(URL이 가리키는 페이지가 삭제되었을 때)</li>\n<li>페이지의 랭킹이 바뀌어서 결과의 순서가 변경될 때</li>\n<li>특정한 쿼리에 관련있는 새로운 페이지가 등장할 때</li>\n</ol>\n<p>방법</p>\n<ol>\n<li>데이터가 수정되었을 때 곧바로 캐시를 갱신할 필요가 없다. -&gt;각 서버에 저장된 캐시를 주기적으로 탐색한 뒤 갱신된 URL에 대해서는 캐시 결과를 비운다.</li>\n<li>X분이 지나면 자동으로 캐시가 버려지도록 한다.</li>\n</ol>\n<h2>관련문제</h2>\n<p><a href=\"https://tech.kakao.com/2017/09/27/kakao-blind-recruitment-round-1/\">카카오 코딩테스트 문제</a>.</p>\n<h2>캐시(난이도: 하)</h2>\n<p>지도개발팀에서 근무하는 제이지는 지도에서 도시 이름을 검색하면 해당 도시와 관련된 맛집 게시물들을 데이터베이스에서 읽어 보여주는 서비스를 개발하고 있다. <br/>\n이 프로그램의 테스팅 업무를 담당하고 있는 어피치는 서비스를 오픈하기 전 각 로직에 대한 성능 측정을 수행하였는데, 제이지가 작성한 부분 중 데이터베이스에서 게시물을 가져오는 부분의 실행시간이 너무 오래 걸린다는 것을 알게 되었다.<br/>\n어피치는 제이지에게 해당 로직을 개선하라고 닦달하기 시작하였고, 제이지는 DB 캐시를 적용하여 성능 개선을 시도하고 있지만 캐시 크기를 얼마로 해야 효율적인지 몰라 난감한 상황이다.<br/></p>\n<p>어피치에게 시달리는 제이지를 도와, DB 캐시를 적용할 때 캐시 크기에 따른 실행시간 측정 프로그램을 작성하시오.</p>\n<h3>입력 형식</h3>\n<ul>\n<li>캐시 크기(cacheSize)와 도시이름 배열(cities)을 입력받는다.</li>\n<li>cacheSize는 정수이며, 범위는 0 ≦ cacheSize ≦ 30 이다.</li>\n<li>cities는 도시 이름으로 이뤄진 문자열 배열로, 최대 도시 수는 100,000개이다.</li>\n<li>각 도시 이름은 공백, 숫자, 특수문자 등이 없는 영문자로 구성되며, 대소문자 구분을 하지 않는다. 도시 이름은 최대 20자로 이루어져 있다.</li>\n</ul>\n<h3>출력 형식</h3>\n<p>입력된 도시이름 배열을 순서대로 처리할 때, “총 실행시간”을 출력한다.</p>\n<h3>조건</h3>\n<ul>\n<li>캐시 교체 알고리즘은 LRU(Least Recently Used)를 사용한다.</li>\n<li>cache hit일 경우 실행시간은 1이다.</li>\n<li>cache miss일 경우 실행시간은 5이다.</li>\n</ul>\n<h3>입출력 예제</h3>\n<table>\n<thead>\n\t<tr><th>캐시크기</th><th>도시이름</th><th>실행시간</th></tr>\n</thead>\n<tbody>\n\t<tr>\n    <td>3\t</td><td>[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”]\t</td><td>50</td>\n    </tr>\n    <tr>\n<td>3\t</td><td>[“Jeju”, “Pangyo”, “Seoul”, “Jeju”, “Pangyo”, “Seoul”, “Jeju”, “Pangyo”, “Seoul”]</td>\t<td>21</td>\n</tr>\n<tr>\n<td>2\t</td><td>[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “SanFrancisco”, “Seoul”, “Rome”, “Paris”, “Jeju”, “NewYork”, “Rome”]</td><td>\t60</td>\n</tr>\n<tr>\n<td>5</td><td>\t[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “SanFrancisco”, “Seoul”, “Rome”, “Paris”, “Jeju”, “NewYork”, “Rome”]</td><td>\t52</td>\n</tr>\n<tr>\n<td>2</td><td>\t[“Jeju”, “Pangyo”, “NewYork”, “newyork”]</td>\t<td>16</td>\n</tr>\n<tr>\n<td>0\t</td><td>[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”]\t</td><td>25</td>\n</tr>\n</tbody>\n</table>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> java.util.*;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Cache</span> </span>{\n\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> cacheSize;\n\t<span class=\"hljs-keyword\">private</span> HashMap&lt;String, Node&gt; map;\n\t<span class=\"hljs-keyword\">private</span> LinkedList&lt;Node&gt; list;\n\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> time;\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Cache</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> cacheSize)</span> </span>{\n\t\t<span class=\"hljs-keyword\">this</span>.cacheSize = cacheSize;\n\t\tmap = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, Node&gt;();\n\t\tlist = <span class=\"hljs-keyword\">new</span> LinkedList&lt;Node&gt;();\n\t\ttime = <span class=\"hljs-number\">0</span>;\n\t}\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insertResults</span><span class=\"hljs-params\">(String city)</span> </span>{\n\t\tcity = city.toLowerCase();\n\t\t<span class=\"hljs-keyword\">if</span> (map.containsKey(city)) {\n\t\t\ttime+=<span class=\"hljs-number\">1</span>;\n\t\t\tNode node = map.get(city);\n\t\t\tlist.remove(node);\n\t\t\tlist.addFirst(node);\n\t\t\t<span class=\"hljs-keyword\">return</span>;\n\t\t}\n\t\t\n\t\ttime+=<span class=\"hljs-number\">5</span>;\n\t\tNode node = <span class=\"hljs-keyword\">new</span> Node(city);\n\t\tmap.put(city, node);\n\t\tlist.addFirst(node);\n\t\t\n\t\t<span class=\"hljs-keyword\">if</span> (list.size() &gt; cacheSize) {\n\t\t\tNode lastNode = list.removeLast();\n\t\t\tmap.remove(lastNode.cityName);\n\t\t}\n\t}\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">printCache</span><span class=\"hljs-params\">()</span> </span>{\n\t\tIterator&lt;Node&gt; i = list.iterator();\n\t\t<span class=\"hljs-keyword\">while</span> (i.hasNext()) {\n\t\t\tSystem.out.print(i.next().cityName + <span class=\"hljs-string\">\" \"</span>);\n\t\t}\n\t}\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getTime</span><span class=\"hljs-params\">()</span> </span>{\n\t\t<span class=\"hljs-keyword\">return</span> time;\n\t}\n\n\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Node</span> </span>{\n\t\tString cityName;\n\t\tNode next;\n\n\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Node</span><span class=\"hljs-params\">(String cityName)</span> </span>{\n\t\t\t<span class=\"hljs-keyword\">this</span>.cityName = cityName;\n\t\t\t<span class=\"hljs-keyword\">this</span>.next = <span class=\"hljs-keyword\">null</span>;\n\t\t}\n\t}\n\n\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LRUQuestion</span> </span>{\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n\t\t\n\t\tString[] cities1 = {<span class=\"hljs-string\">\"Jeju\"</span>, <span class=\"hljs-string\">\"Pangyo\"</span>, <span class=\"hljs-string\">\"Seoul\"</span>, <span class=\"hljs-string\">\"NewYork\"</span>, <span class=\"hljs-string\">\"LA\"</span>, <span class=\"hljs-string\">\"Jeju\"</span>, <span class=\"hljs-string\">\"Pangyo\"</span>, <span class=\"hljs-string\">\"Seoul\"</span>, <span class=\"hljs-string\">\"NewYork\"</span>, <span class=\"hljs-string\">\"LA\"</span>};\n\t\tSystem.out.println(<span class=\"hljs-string\">\"실행시간 : \"</span> + testCache(<span class=\"hljs-number\">3</span>,cities1));\n\t\tString[] cities2 = {<span class=\"hljs-string\">\"Jeju\"</span>, <span class=\"hljs-string\">\"Pangyo\"</span>, <span class=\"hljs-string\">\"Seoul\"</span>, <span class=\"hljs-string\">\"Jeju\"</span>, <span class=\"hljs-string\">\"Pangyo\"</span>, <span class=\"hljs-string\">\"Seoul\"</span>, <span class=\"hljs-string\">\"Jeju\"</span>, <span class=\"hljs-string\">\"Pangyo\"</span>, <span class=\"hljs-string\">\"Seoul\"</span>};\n\t\tSystem.out.println(<span class=\"hljs-string\">\"실행시간 : \"</span> + testCache(<span class=\"hljs-number\">3</span>,cities2));\n\t\tString[] cities3 = {<span class=\"hljs-string\">\"Jeju\"</span>, <span class=\"hljs-string\">\"Pangyo\"</span>, <span class=\"hljs-string\">\"Seoul\"</span>, <span class=\"hljs-string\">\"NewYork\"</span>, <span class=\"hljs-string\">\"LA\"</span>, <span class=\"hljs-string\">\"SanFrancisco\"</span>, <span class=\"hljs-string\">\"Seoul\"</span>, <span class=\"hljs-string\">\"Rome\"</span>, <span class=\"hljs-string\">\"Paris\"</span>, <span class=\"hljs-string\">\"Jeju\"</span>, <span class=\"hljs-string\">\"NewYork\"</span>, <span class=\"hljs-string\">\"Rome\"</span>};\n\t\tSystem.out.println(<span class=\"hljs-string\">\"실행시간 : \"</span> + testCache(<span class=\"hljs-number\">2</span>,cities3));\n\t\tString[] cities4 = {<span class=\"hljs-string\">\"Jeju\"</span>, <span class=\"hljs-string\">\"Pangyo\"</span>, <span class=\"hljs-string\">\"Seoul\"</span>, <span class=\"hljs-string\">\"NewYork\"</span>, <span class=\"hljs-string\">\"LA\"</span>, <span class=\"hljs-string\">\"SanFrancisco\"</span>, <span class=\"hljs-string\">\"Seoul\"</span>, <span class=\"hljs-string\">\"Rome\"</span>, <span class=\"hljs-string\">\"Paris\"</span>, <span class=\"hljs-string\">\"Jeju\"</span>, <span class=\"hljs-string\">\"NewYork\"</span>, <span class=\"hljs-string\">\"Rome\"</span>};\n\t\tSystem.out.println(<span class=\"hljs-string\">\"실행시간 : \"</span> + testCache(<span class=\"hljs-number\">5</span>,cities4));\n\t\tString[] cities5 = {<span class=\"hljs-string\">\"Jeju\"</span>, <span class=\"hljs-string\">\"Pangyo\"</span>, <span class=\"hljs-string\">\"NewYork\"</span>, <span class=\"hljs-string\">\"newyork\"</span>};\n\t\tSystem.out.println(<span class=\"hljs-string\">\"실행시간 : \"</span> + testCache(<span class=\"hljs-number\">2</span>,cities5));\n\t\tString[] cities6 = {<span class=\"hljs-string\">\"Jeju\"</span>, <span class=\"hljs-string\">\"Pangyo\"</span>, <span class=\"hljs-string\">\"Seoul\"</span>, <span class=\"hljs-string\">\"NewYork\"</span>, <span class=\"hljs-string\">\"LA\"</span>};\n\t\tSystem.out.println(<span class=\"hljs-string\">\"실행시간 : \"</span> + testCache(<span class=\"hljs-number\">0</span>,cities6));\n\t}\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">testCache</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> cacheSize, String[] cities)</span> </span>{\n\t\tCache cache = <span class=\"hljs-keyword\">new</span> Cache(cacheSize);\n\t\t<span class=\"hljs-keyword\">for</span> (String city : cities)\n\t\t\tcache.insertResults(city);\n\t\t\n\t\t<span class=\"hljs-keyword\">return</span> cache.getTime();\n\t}\n}\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:25:35.092Z",
		"id": "2019-08-30-coding-interview-question-4",
		"filename": "algorithm\\2019-08-30-coding-interview-question-4.json"
	},
	{
		"layout": "post-content",
		"title": "(코딩인터뷰) 시스템 설계 및 규모 확장성 문제 5 - 판매순위",
		"date": "2019-08-31T00:00:00.000Z",
		"categories": [
			"codinginterview"
		],
		"body": "<p>코딩 인터뷰 완전분석 (CRACKING THE CODING INTERVIEW 6/E) / 게일 라크만 맥도웰 지음 / 인사이트</p>\n<hr>\n<h1>Q. 판매순위 : 한 전자상거래 회사는 가장 잘 팔리는 제품의 리스트(전체에서 그리고 각 목록별로)를 알고 싶어 한다. 예를 들어, 어떤 제품은 전체 제품 중에서 1,506번째로 잘 팔리지만 운동 장비 중에서는 13번째로 잘 팔리고, 안전용품 중에서는 24번째로 잘 팔릴 수 있다. 이 시스템을 어떻게 설계할지 설명하라.</h1>\n<h2>내풀이</h2>\n<p>각 제품 정보에 판매수량을 저장을 하고 리스트 조회할 때마다 정렬하는 건 좀 그럴거 같긴한뎁,\n동시에 전체 중 ~위 운동 장비 중 ~위… 이런식으로 표현하게 되면 정렬을 넘 많이 하게 되는 듯싶은뎅\n구입할 때마다 리스트의 맨앞에…?음…\n매번 순위 조회할때마다 정렬해야되니깐 이건 좀 별루고\n아예 전체 연결리스트를 순서가 유지되게 하는 게 좋을 듯\n삽입 삭제가 빈번하니깐 연결리스트가 좋을거같고…</p>\n<h2>책풀이</h2>\n<p><strong>1단계 : 문제 범위를 한정하고 합리적인 가정을 하자</strong></p>\n<p>구현하려는 시스템을 다음과 같이 정의했다.</p>\n<ul>\n<li>잘 팔린다는 것은 판매량이 많다는 것을 의미한다.</li>\n<li>판매량은 평생/지난달/저번주 판매량인지 명확하게 정의할 것이다. 여기서는 저번주 판매량으로 한정한다.</li>\n<li>각 제품은 여러 목록에 포함될 수 있고 하위목록 개념은 없다고 가정한다.</li>\n</ul>\n<p>다음과 같은 합리적인 가정을 세웠다.</p>\n<ul>\n<li>통계 결과가 언제나 100% 최신 데이터가 아닐 수 있다고 가정할 것이다.</li>\n<li>인기 있는 제품의 경우 정확도가 중요하나 인기 없는 제품은 약간의 오차가 있어도 괜찮다.</li>\n<li>가장 인기 있는 제품의 경우 한 시간마다 갱신이 이루어진다고 가정할 것이다.</li>\n</ul>\n<p><strong>2단계 : 주요 구성요소 그리기</strong></p>\n<p><img src=\"/assets/images/2019-08-30-img/5-1.jpg\" alt=\"1\">    <br/></p>\n<p><strong>3단계 : 핵심문제 파악</strong></p>\n<ol>\n<li>분석은 비용이 비싸다.</li>\n<li>데이터베이스에 너무 자주 기록한다.</li>\n<li>join 비용이 비싸다</li>\n</ol>\n<p>2번 데이터베이스에 너무 자주 기록된다.<br>\n구매할 때마다 판매량 정보 테이블을 업데이트하기보다는 모아서 일괄적(batch)으로 한번에 데이터베이스에 쓰는 방법을 쓴다.<br>\n즉, 곧바로 데이터베이스에 자료를 집어넣기보단, 메모리 내의 캐시와 같은 저장소에 구매 정보와 백업용 로그 파일을 저장해 놓은 뒤 주기적으로 로그/캐시 데이터를 모아서 한 번에 데이터베이스에 넣는 것이다. (특정 시점까지의 자료만 데이터베이스에 넣는 식)</p>\n<p>3번 join 비용이 비싸다.<br>\n수천 개의 제품 목록을 제품 ID에 join 하는 작업은 고비용이다.</p>\n",
		"updatedAt": "2020-01-22T18:25:35.106Z",
		"id": "2019-08-31-coding-interview-question-5",
		"filename": "algorithm\\2019-08-31-coding-interview-question-5.json"
	},
	{
		"layout": "post-content",
		"title": "프로그래머스 모의고사 Javascript",
		"date": "2019-11-28T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<h1>문제 설명</h1>\n<p>수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다.      수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.</p>\n<p>1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, …<br>\n2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, …<br>\n3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, …</p>\n<p>1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.</p>\n<h1>제한 조건</h1>\n<ul>\n<li>시험은 최대 10,000 문제로 구성되어있습니다.</li>\n<li>문제의 정답은 1, 2, 3, 4, 5중 하나입니다.</li>\n<li>가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.</li>\n</ul>\n<h1>풀이</h1>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution</span>(<span class=\"hljs-params\">answers</span>) </span>{\n    <span class=\"hljs-keyword\">const</span> person_ans = [\n        [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>],\n        [<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">5</span>],\n        [<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">5</span>]\n    ]\n    \n    <span class=\"hljs-keyword\">const</span> scores = <span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">3</span>).fill(<span class=\"hljs-number\">0</span>);\n    \n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;answers.length; i++) {\n        <span class=\"hljs-keyword\">if</span> (person_ans[<span class=\"hljs-number\">0</span>][i%<span class=\"hljs-number\">5</span>] === answers[i]) scores[<span class=\"hljs-number\">0</span>]++;\n        <span class=\"hljs-keyword\">if</span> (person_ans[<span class=\"hljs-number\">1</span>][i%<span class=\"hljs-number\">8</span>] === answers[i]) scores[<span class=\"hljs-number\">1</span>]++;\n        <span class=\"hljs-keyword\">if</span> (person_ans[<span class=\"hljs-number\">2</span>][i%<span class=\"hljs-number\">10</span>] === answers[i]) scores[<span class=\"hljs-number\">2</span>]++;\n    }\n       \n    <span class=\"hljs-keyword\">let</span> max = <span class=\"hljs-built_in\">Math</span>.max(...scores);\n    \n    <span class=\"hljs-keyword\">let</span> answer = [];\n    \n    scores.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">element, index</span>) =&gt;</span> {\n        <span class=\"hljs-keyword\">if</span> (max == element) answer.push(index+<span class=\"hljs-number\">1</span>)\n    });\n    \n    <span class=\"hljs-keyword\">return</span> answer;\n}\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:26:22.700Z",
		"id": "2019-11-28-algorithm-1",
		"filename": "algorithm\\2019-11-28-algorithm-1.json"
	},
	{
		"layout": "post-content",
		"title": "프로그래머스 조이스틱 Javascript",
		"date": "2019-11-28T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<h1>문제 설명</h1>\n<p>조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.<br>\nex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA</p>\n<p>조이스틱을 각 방향으로 움직이면 아래와 같습니다.<br>\n▲ - 다음 알파벳<br>\n▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)<br>\n◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)<br>\n▶ - 커서를 오른쪽으로 이동</p>\n<p>예를 들어 아래의 방법으로 JAZ를 만들 수 있습니다.</p>\n<ul>\n<li>첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.</li>\n<li>조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.</li>\n<li>마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.</li>\n</ul>\n<p>따라서 11번 이동시켜 &quot;JAZ&quot;를 만들 수 있고, 이때가 최소 이동입니다.</p>\n<p>만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.</p>\n<h1>제한 사항</h1>\n<ul>\n<li>name은 알파벳 대문자로만 이루어져 있습니다.</li>\n<li>name의 길이는 1 이상 20 이하입니다.</li>\n</ul>\n<h1>풀이</h1>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution</span>(<span class=\"hljs-params\">name</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> arrName = <span class=\"hljs-built_in\">Array</span>(name.length).fill(<span class=\"hljs-string\">'A'</span>); <span class=\"hljs-comment\">// 초기값 'A...'로 셋팅해서 name과 같을 때까지 반복 돌림</span>\n    <span class=\"hljs-keyword\">var</span> index = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 조작할 인덱스 </span>\n    <span class=\"hljs-keyword\">var</span> answer = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 조작 횟수</span>\n    <span class=\"hljs-keyword\">while</span> (arrName.join(<span class=\"hljs-string\">''</span>) !== name) {\n        <span class=\"hljs-comment\">// 현재 인덱스의 알파벳 변경</span>\n        arrName[index] = name[index];\n        <span class=\"hljs-comment\">// 알파벳 조작 횟수</span>\n        answer += alpha(name[index]);\n        <span class=\"hljs-comment\">// 다음에 조작할 인덱스 찾기</span>\n        <span class=\"hljs-keyword\">let</span> obj = findPos(index, name, arrName);\n        <span class=\"hljs-keyword\">if</span> (obj !== <span class=\"hljs-literal\">null</span>) {\n          answer += obj.diff;\n          index = obj.index;\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> answer;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">findPos</span>(<span class=\"hljs-params\">index, name, arrName</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> nextRightIndex = (index + <span class=\"hljs-number\">1</span>) % name.length;\n    <span class=\"hljs-keyword\">var</span> nextLeftIndex = (index - <span class=\"hljs-number\">1</span> + name.length) % name.length;    \n    <span class=\"hljs-keyword\">var</span> moveSize = <span class=\"hljs-number\">1</span>;\n    \n    <span class=\"hljs-comment\">// 최소값을 찾는 거니깐 or로 해서 동시 탐색</span>\n    <span class=\"hljs-comment\">// 'A'가 아니면서 이미 변경처리한 알파벳이 아닌 인덱스 찾기</span>\n    <span class=\"hljs-keyword\">while</span> (nextRightIndex != index || nextLeftIndex != index ) {\n        <span class=\"hljs-keyword\">if</span> (name[nextRightIndex] !== <span class=\"hljs-string\">'A'</span> &amp;&amp; arrName[nextRightIndex] !== name[nextRightIndex]) {\n            <span class=\"hljs-keyword\">return</span> {\n                <span class=\"hljs-attr\">index</span>: nextRightIndex,\n                <span class=\"hljs-attr\">diff</span>: moveSize\n            }\n        }\n        <span class=\"hljs-keyword\">if</span> (name[nextLeftIndex] !== <span class=\"hljs-string\">'A'</span> &amp;&amp; arrName[nextLeftIndex] !== name[nextLeftIndex]) {\n            <span class=\"hljs-keyword\">return</span> {\n                <span class=\"hljs-attr\">index</span>: nextLeftIndex,\n                <span class=\"hljs-attr\">diff</span>: moveSize\n            }\n        }\n        nextRightIndex = (++nextRightIndex) % name.length;\n        nextLeftIndex = (--nextLeftIndex + name.length) % name.length;    \n        moveSize++;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n} \n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">alpha</span>(<span class=\"hljs-params\">n</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Math</span>.min(n.charCodeAt(<span class=\"hljs-number\">0</span>) - <span class=\"hljs-string\">'A'</span>.charCodeAt(<span class=\"hljs-number\">0</span>), <span class=\"hljs-string\">'Z'</span>.charCodeAt(<span class=\"hljs-number\">0</span>) - n.charCodeAt(<span class=\"hljs-number\">0</span>) + <span class=\"hljs-number\">1</span>);\n}\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:26:22.702Z",
		"id": "2019-11-28-algorithm-2",
		"filename": "algorithm\\2019-11-28-algorithm-2.json"
	},
	{
		"layout": "post-content",
		"title": "프로그래머스 [3차] n진수게임 Javascript",
		"date": "2019-11-28T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<h1>문제 설명</h1>\n<p>튜브가 활동하는 코딩 동아리에서는 전통적으로 해오는 게임이 있다. 이 게임은 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임인데, 규칙은 다음과 같다.</p>\n<p>숫자를 0부터 시작해서 차례대로 말한다. 첫 번째 사람은 0, 두 번째 사람은 1, … 열 번째 사람은 9를 말한다.<br>\n10 이상의 숫자부터는 한 자리씩 끊어서 말한다. 즉 열한 번째 사람은 10의 첫 자리인 1, 열두 번째 사람은 둘째 자리인 0을 말한다.<br>\n이렇게 게임을 진행할 경우,<br>\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, …<br>\n순으로 숫자를 말하면 된다.</p>\n<p>한편 코딩 동아리 일원들은 컴퓨터를 다루는 사람답게 이진수로 이 게임을 진행하기도 하는데, 이 경우에는<br>\n0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, …<br>\n순으로 숫자를 말하면 된다.</p>\n<p>이진수로 진행하는 게임에 익숙해져 질려가던 사람들은 좀 더 난이도를 높이기 위해 이진법에서 십육진법까지 모든 진법으로 게임을 진행해보기로 했다.<br>\n숫자 게임이 익숙하지 않은 튜브는 게임에 져서 벌칙을 받는 굴욕을 피하기 위해, 자신이 말해야 하는 숫자를 스마트폰에 미리 출력해주는 프로그램을 만들려고 한다.     튜브의 프로그램을 구현하라.</p>\n<h1>풀이</h1>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution</span>(<span class=\"hljs-params\">n, t, m, p</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> answer = <span class=\"hljs-string\">''</span>;\n    <span class=\"hljs-keyword\">var</span> game = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>();\n    <span class=\"hljs-keyword\">var</span> number = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">while</span> (game.length &lt; t*m) {\n        <span class=\"hljs-keyword\">let</span> tmp = number;       \n        <span class=\"hljs-keyword\">let</span> arrTmp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>();\n        <span class=\"hljs-keyword\">while</span> (tmp &gt;= n) {\n            arrTmp.unshift(tmp % n); <span class=\"hljs-comment\">// 배열 맨 앞에 삽입</span>\n            tmp = <span class=\"hljs-built_in\">Math</span>.floor(tmp / n); <span class=\"hljs-comment\">// Math.floor() 소숫점 내림</span>\n        }\n        arrTmp.unshift(tmp);\n        game.push(...arrTmp) <span class=\"hljs-comment\">// game.push.apply(game, arrTmp);와 같음 확장연산자(e6)</span>\n        <span class=\"hljs-comment\">//game = game.concat(arrTmp); // 배열 합치기 느리다.</span>\n        number++;\n    }\n    \n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=p<span class=\"hljs-number\">-1</span>; i&lt;game.length; i=i+m) {\n        answer += game[i].toString(n).toUpperCase(); <span class=\"hljs-comment\">// toString() number를 n진수 형태로 반환한다. abcdef를 소문자 형태로 반환해서 toUpperCase()를 사용했다.</span>\n        <span class=\"hljs-keyword\">if</span> (answer.length == t) <span class=\"hljs-keyword\">break</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> answer;\n}\n</code></pre>\n<h2>Number.prototype.toString([radix]]) 메서드</h2>\n<ul>\n<li>Number.prototype.toString() 은 Number 객체를 문자열로 반환하는 메서드다.</li>\n<li>radix는 진수를 나타내는 기수의 값으로 2~36 범위의 정수다. 이 범위를 벗어나는 radix가 주어지면 RangeError가 발생한다. (default는 10진수)</li>\n</ul>\n<p>Number 객체는 Object 객체의 toString() 메서드(<strong>Object.prototype.toString()</strong>)를 오버라이딩했다.\n그래서 Number 객체에서 toString() 메서드를 사용하면 특정 진수로 객체를 표현한 문자열을 리턴받을 수 있는 것이다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> number = <span class=\"hljs-number\">254</span>;\n<span class=\"hljs-built_in\">console</span>.log(number.toString(<span class=\"hljs-number\">16</span>)); <span class=\"hljs-comment\">// fe 출력</span>\n</code></pre>\n<h2>Array.prototype.unshift([…elementN])</h2>\n<p>새로운 요소를 배열의 맨 앞쪽에 추가하고, 배열의 길이를 리턴</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>];\narr.unshift(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// [0,1,2]</span>\narr.unshift(<span class=\"hljs-number\">-2</span>, <span class=\"hljs-number\">-1</span>); <span class=\"hljs-comment\">// [-2, -1, 0, 1, 2]</span>\n</code></pre>\n<h2>Array.prototype.push vs Array.prototype.concat</h2>\n<p>처음에는 <strong>game = game.concat(arrTmp)</strong> 식으로 배열을 합쳤다. 근데 시간이 너무 많이 소요되길래 <strong>game.push(…arrTmp)</strong> 이렇게 바꿨더니 효율성이 좀 좋아진 듯 하다. 왜 그럴까?..</p>\n<p><a href=\"https://dev.to/uilicious/javascript-array-push-is-945x-faster-than-array-concat-1oki\">https://dev.to/uilicious/javascript-array-push-is-945x-faster-than-array-concat-1oki</a> 이 글을 보면 알 수 있다.</p>\n<p>즉 concat은 .push로 원본 배열을 수정하면서 <strong>새 배열</strong>을 만들기때문에 느리고 push는 원본 배열의 뒤에 배열을 추가하며 원본 배열을 변경하기 때문에 concat 보다는 빠르다.</p>\n<h2>다른 사람 풀이</h2>\n<p>다른 사람 풀이를 봤더니 이렇게 간단하게도 풀 수 있다는 걸 알았다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution</span>(<span class=\"hljs-params\">n, t, m, p</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> answer = <span class=\"hljs-string\">''</span>,\n        numbers = [],\n        j = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = p; answer.length &lt; t; i += m) {\n        <span class=\"hljs-keyword\">let</span> order = i - <span class=\"hljs-number\">1</span>;\n\n        <span class=\"hljs-keyword\">while</span> (numbers[order] === <span class=\"hljs-literal\">undefined</span>) {\n            j.toString(n).toUpperCase().split(<span class=\"hljs-string\">''</span>).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> numbers.push(v));\n            j++;\n        }\n        answer += numbers[order];\n    }\n    <span class=\"hljs-keyword\">return</span> answer;\n}\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:26:22.703Z",
		"id": "2019-11-28-algorithm-3",
		"filename": "algorithm\\2019-11-28-algorithm-3.json"
	},
	{
		"layout": "post-content",
		"title": "프로그래머스 2xn 타일링 Javascript",
		"date": "2019-11-29T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<h1>문제 설명</h1>\n<p>가로 길이가 2이고 세로의 길이가 1인 직사각형모양의 타일이 있습니다. 이 직사각형 타일을 이용하여 세로의 길이가 2이고 가로의 길이가 n인 바닥을 가득 채우려고 합니다. 타일을 채울 때는 다음과 같이 2가지 방법이 있습니다.</p>\n<p>타일을 가로로 배치 하는 경우<br>\n타일을 세로로 배치 하는 경우</p>\n<p>직사각형의 가로의 길이 n이 매개변수로 주어질 때, 이 직사각형을 채우는 방법의 수를 return 하는 solution 함수를 완성해주세요.</p>\n<h1>제한 사항</h1>\n<ul>\n<li>가로의 길이 n은 60,000이하의 자연수 입니다.</li>\n<li>경우의 수가 많아 질 수 있으므로, 경우의 수를 1,000,000,007으로 나눈 나머지를 return해주세요.</li>\n</ul>\n<h1>풀이</h1>\n<p>문제를 보는 순간 규칙이 있을 거 같다는 생각을 했다.<br>\n근데 그 규칙 찾는 데 한참 걸렸다… ㅠ__ㅠ</p>\n<p>결론부터 말하자면, 이 문제의 점화식은 <strong>DP[N] = DP[N-1][N-2]</strong> 다. 그리고 n이 최대 60000 이므로 재귀를 쓰는 것보다 메모이제이션을 이용하는 게 낫다고 판단했다.</p>\n<p>아래는 점화식 도출 과정이다.</p>\n<ul>\n<li>n = 0, 1개</li>\n<li>n = 1, 1개</li>\n<li>n = 2, 2개 (DP[1] + DP[0])</li>\n<li>n = 3, 3개 (DP[2] + DP[1])</li>\n<li>n = 4, 4개 (DP[3] + DP[2])</li>\n<li>…</li>\n</ul>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution</span>(<span class=\"hljs-params\">n</span>) </span>{\n    <span class=\"hljs-keyword\">const</span> memo = <span class=\"hljs-built_in\">Array</span>(n+<span class=\"hljs-number\">1</span>).fill(<span class=\"hljs-number\">0</span>);\n    memo[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;\n    memo[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">2</span>; i&lt;n+<span class=\"hljs-number\">1</span>; i++) {\n        memo[i] = (memo[i<span class=\"hljs-number\">-1</span>] + memo[i<span class=\"hljs-number\">-2</span>]) % <span class=\"hljs-number\">1000000007</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> memo[n];    \n}\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:26:22.703Z",
		"id": "2019-11-29-algorithm-4",
		"filename": "algorithm\\2019-11-29-algorithm-4.json"
	},
	{
		"layout": "post-content",
		"title": "프로그래머스 2016년 Javascript",
		"date": "2019-11-29T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<h1>문제 설명</h1>\n<p>2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT 입니다.</p>\n<p>를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 TUE를 반환하세요.</p>\n<h1>제한 조건</h1>\n<ul>\n<li>2016년은 윤년입니다.</li>\n<li>2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다)</li>\n</ul>\n<h1>풀이</h1>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n    <span class=\"hljs-keyword\">const</span> month = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">29</span>, <span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">31</span>];\n    <span class=\"hljs-keyword\">const</span> day = [<span class=\"hljs-string\">'FRI'</span>,<span class=\"hljs-string\">'SAT'</span>,<span class=\"hljs-string\">'SUN'</span>,<span class=\"hljs-string\">'MON'</span>,<span class=\"hljs-string\">'TUE'</span>,<span class=\"hljs-string\">'WED'</span>,<span class=\"hljs-string\">'THU'</span>];\n    \n    <span class=\"hljs-keyword\">let</span> answer = b - <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">1</span>; i&lt;a; i++)\n        answer += month[i];\n    \n    <span class=\"hljs-keyword\">return</span> day[answer % <span class=\"hljs-number\">7</span>];\n}\n</code></pre>\n<p>쉬운 문제여서 금방 풀었지만, 뭔가 자바스크립트스럽지않아서 탐탁지않았다.<br>\n그래서 자바스크립트의 <strong>reduce</strong> 와 <strong>slice</strong> 메서드를 이용해서 다시 풀어보았다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n    <span class=\"hljs-keyword\">const</span> month = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">29</span>, <span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">31</span>];\n    <span class=\"hljs-keyword\">const</span> day = [<span class=\"hljs-string\">'FRI'</span>,<span class=\"hljs-string\">'SAT'</span>,<span class=\"hljs-string\">'SUN'</span>,<span class=\"hljs-string\">'MON'</span>,<span class=\"hljs-string\">'TUE'</span>,<span class=\"hljs-string\">'WED'</span>,<span class=\"hljs-string\">'THU'</span>];\n    \n    <span class=\"hljs-keyword\">let</span> answer = b - <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">if</span> (a &gt; <span class=\"hljs-number\">1</span>) {\n        answer += month.slice(<span class=\"hljs-number\">1</span>, a).reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">accumlator, currentValue</span>) =&gt;</span> {\n            <span class=\"hljs-keyword\">return</span> accumlator + currentValue;\n        });\n    }\n    \n    <span class=\"hljs-keyword\">return</span> day[answer % <span class=\"hljs-number\">7</span>];\n}\n</code></pre>\n<h1>Array.prototype.reduce()</h1>\n<p>reduce() 메서드는 배열의 각 요소에 reducer 함수를 실행하여 계산의 누적 결과값을 반환한다.</p>\n<pre><code class=\"language-javascript\">arr.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">accumulator, currentValue[,currentIndex, array][,initialValue]</span>) =&gt;</span> {\n <span class=\"hljs-comment\">// </span>\n <span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">//</span>\n});\n</code></pre>\n<p>리듀서 함수 인수</p>\n<ul>\n<li>\n<p>accumulator : 콜백(리듀서함수)의 반환값 누적</p>\n</li>\n<li>\n<p>currentValue : 처리할 현재 요소</p>\n</li>\n<li>\n<p>옵션 currentIndex : 처리할 현재 요소의 인덱스로 initialValue가 있으면 0, 아니면 1부터 시작</p>\n</li>\n<li>\n<p>옵션 array : reduce()를 호출한 배열</p>\n</li>\n<li>\n<p>initialValue : 리듀서 함수 최초 호출에서 첫번째 인수로 제공할 값, 제공안하면 배열의 첫번째 요소를 사용한다. 만약 빈 배열에서 초기값 없이 reduce() 호출하면 에러난다.</p>\n</li>\n</ul>\n",
		"updatedAt": "2020-01-22T18:26:22.703Z",
		"id": "2019-11-29-algorithm-5",
		"filename": "algorithm\\2019-11-29-algorithm-5.json"
	},
	{
		"layout": "post-content",
		"title": "프로그래머스 다음 큰 숫자 Javascript",
		"date": "2019-11-29T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<h1>문제 설명</h1>\n<p>자연수 n이 주어졌을 때, n의 다음 큰 숫자는 다음과 같이 정의 합니다.</p>\n<ul>\n<li>조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다.</li>\n<li>조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다.\n*조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다.</li>\n</ul>\n<p>예를 들어서 78(1001110)의 다음 큰 숫자는 83(1010011)입니다.</p>\n<p>자연수 n이 매개변수로 주어질 때, n의 다음 큰 숫자를 return 하는 solution 함수를 완성해주세요.</p>\n<h1>내 풀이</h1>\n<p>2진수 n의 1 비트 갯수와 같은 비트수를 가지는 숫자를 n+1부터 반복을 돌려서 찾으면 된다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution</span>(<span class=\"hljs-params\">n</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> nBit = getBitCount(n);\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n        <span class=\"hljs-keyword\">if</span> (getBitCount(++n) === nBit) <span class=\"hljs-keyword\">break</span>;\n    }    \n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getBitCount</span>(<span class=\"hljs-params\">number</span>) </span>{\n        <span class=\"hljs-keyword\">let</span> bitCount = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">while</span>(number &gt; <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">if</span> (number &amp; <span class=\"hljs-number\">1</span> === <span class=\"hljs-number\">1</span>) bitCount++;\n            number = number &gt;&gt;&gt; <span class=\"hljs-number\">1</span>;\n        }\n        <span class=\"hljs-keyword\">return</span> bitCount;\n    }\n    \n    <span class=\"hljs-keyword\">return</span> n;\n}\n</code></pre>\n<h1>다른 사람 풀이</h1>\n<p>풀고 다른 사람의 풀이를 보니 아이디어는 비슷했으나 비트 수를 세는 방법이 다양했다.</p>\n<ol>\n<li>String.prototype.match() 메서드와 정규 표현식 이용하기</li>\n</ol>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution</span>(<span class=\"hljs-params\">n</span>) </span>{\n    <span class=\"hljs-comment\">// console.log(n.toString(2).match(/1/g)) : [ '1', '1', '1', '1' ] 배열 형태로 반환    </span>\n    <span class=\"hljs-keyword\">let</span> nBit = n.toString(<span class=\"hljs-number\">2</span>).match(<span class=\"hljs-regexp\">/1/g</span>).length;    \n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) <span class=\"hljs-keyword\">if</span> ((++n).toString(<span class=\"hljs-number\">2</span>).match(<span class=\"hljs-regexp\">/1/g</span>).length === nBit) <span class=\"hljs-keyword\">return</span> n;\n}\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:26:23.101Z",
		"id": "2019-12-09-algorithm-6",
		"filename": "algorithm\\2019-12-09-algorithm-6.json"
	},
	{
		"layout": "post-content",
		"title": "(수학1) 설탕배달 - 백준 Java",
		"date": "2019-12-09T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<h1>문제 설명</h1>\n<p>상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.</p>\n<p>상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.</p>\n<p>상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.</p>\n<p><strong>입력</strong><br>\n첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)</p>\n<p><strong>출력</strong><br>\n상근이가 배달하는 봉지의 최소 개수를 출력한다. 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다.</p>\n<h1>내 풀이</h1>\n<p>최소 개수의 봉지를 구해야해서 5킬로그램 봉지부터 계산한다.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Main</span> </span>{\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n\t\tScanner sc = <span class=\"hljs-keyword\">new</span> Scanner(System.in);\n\t\t<span class=\"hljs-keyword\">int</span> N = sc.nextInt();\n\t\tSystem.out.println(Solution(N));\n\t}\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Solution</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> N)</span> </span>{\n\t\t<span class=\"hljs-keyword\">int</span> c = N / <span class=\"hljs-number\">5</span>;\n\t\t<span class=\"hljs-keyword\">int</span> r = N % <span class=\"hljs-number\">5</span>;\n\t\t<span class=\"hljs-keyword\">while</span> (c &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; r &gt; <span class=\"hljs-number\">0</span>) {\n\t\t\t<span class=\"hljs-keyword\">if</span> (r % <span class=\"hljs-number\">3</span> == <span class=\"hljs-number\">0</span>) {\n\t\t\t\tc += r/<span class=\"hljs-number\">3</span>;\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t}\n\t\t\tc--;\n\t\t\tr += <span class=\"hljs-number\">5</span>;\n\t\t}\n\t\t<span class=\"hljs-keyword\">if</span> (c &lt; <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n\t\t<span class=\"hljs-keyword\">return</span> c;\n\t}\n}\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:26:23.101Z",
		"id": "2019-12-09-algorithm-7",
		"filename": "algorithm\\2019-12-09-algorithm-7.json"
	},
	{
		"layout": "post-content",
		"title": "(수학1) 벌집 - 백준 Java",
		"date": "2019-12-09T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<h1>문제 설명</h1>\n<p>(<a href=\"https://www.acmicpc.net/problem/2292\">https://www.acmicpc.net/problem/2292</a>)[<a href=\"https://www.acmicpc.net/problem/2292\">https://www.acmicpc.net/problem/2292</a>]</p>\n<h1>내 풀이</h1>\n<p>규칙을 찾아보았다.</p>\n<ul>\n<li>1 (1개) =&gt; 1칸</li>\n<li>2 ~ 7 (6개) =&gt; 2칸</li>\n<li>8 ~ 19 (12개) =&gt; 3칸</li>\n<li>20 ~ 37 (18개) =&gt; 4칸</li>\n</ul>\n<p>즉, 방의 수를 1부터 6*count(1,2,3…) 값을 누적시켰을 때 방의 수가 N보다 크거나 같아지는 순간이 답이 된다.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Main</span> </span>{\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n\t\tScanner sc = <span class=\"hljs-keyword\">new</span> Scanner(System.in);\n\t\t<span class=\"hljs-keyword\">int</span> N = sc.nextInt();\n\t\tSystem.out.println(Solution(N));\n\t}\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Solution</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> N)</span> </span>{\n\t\t<span class=\"hljs-keyword\">int</span> room = <span class=\"hljs-number\">1</span>;\n\t\t<span class=\"hljs-keyword\">int</span> count = <span class=\"hljs-number\">1</span>;\n\t\t<span class=\"hljs-keyword\">while</span> (N &gt; room) {\n\t\t\troom += <span class=\"hljs-number\">6</span> * (count++);\n\t\t}\n\t\t<span class=\"hljs-keyword\">return</span> count;\n\t}\n}\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:26:23.102Z",
		"id": "2019-12-09-algorithm-8",
		"filename": "algorithm\\2019-12-09-algorithm-8.json"
	},
	{
		"layout": "post-content",
		"title": "(수학1) 분수찾기 백준",
		"date": "2019-12-10T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<h1>문제</h1>\n<p><a href=\"https://www.acmicpc.net/problem/1193\">분수찾기</a></p>\n<h1>내 풀이</h1>\n<p>자세히 살펴보면 다음과 같은 규칙이 있다.</p>\n<p>1/1 =&gt; 1 layer (이 라인에서 제일 큰 번호 : 1)<br>\n1/2 2/1 =&gt; 2 layer (이 라인에서 제일 큰 번호 : 3)<br>\n3/1 2/2 1/3 =&gt; 3 layer (이 라인에서 제일 큰 번호 : 6)<br>\n1/4 2/3 3/2 4/1 =&gt; 4 layer (이 라인에서 제일 큰 번호 : 10)<br>\n5/1 4/2 3/3 2/4 1/5 =&gt; 5 layer (이 라인에서 제일 큰 번호 : 15)</p>\n<ul>\n<li>x layer에는 x 개의 분수가 있다.</li>\n<li>x layer에서 제일 큰 번호는 1 + 2 + 3 + … + x 이다. 즉 x * (x + 1) / 2</li>\n<li>layer 번호가 짝수면, 제일 큰 번호의 분수를 기준으로 분자는 -1, 분모는 +1 을 한다.</li>\n<li>layer 번호가 홀수면, 제일 큰 번호의 분수를 기준으로 분자는 +1, 분모는 -1 을 한다.</li>\n</ul>\n<p>위의 규칙을 이용하여 입력 N이 있는 layer와 그 layer의 제일 큰 번호를 찾고 layer의 홀/짝 여부를 통해 분자, 분모를 1 빼거나 더하면 된다.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">P1193</span> </span>{\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n\t\tScanner sc = <span class=\"hljs-keyword\">new</span> Scanner(System.in);\n\t\t<span class=\"hljs-keyword\">int</span> N = sc.nextInt();\n\t\tSystem.out.println(Solution(N));\n\t}\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title\">Solution</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> N)</span> </span>{\n\t\t<span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">1</span>, b = <span class=\"hljs-number\">1</span>;\n\t\t<span class=\"hljs-keyword\">int</span> num = <span class=\"hljs-number\">1</span>, number = <span class=\"hljs-number\">1</span>;\n\t\t<span class=\"hljs-keyword\">int</span> r = <span class=\"hljs-number\">0</span>;\n\t\t<span class=\"hljs-keyword\">int</span>[] cal_a = {-<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>};\n\t\t<span class=\"hljs-keyword\">int</span>[] cal_b = {<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>};\t\t\n\t\t\n\t\t<span class=\"hljs-keyword\">while</span> (number &lt; N) {\n\t\t\tnum++;\n\t\t\tnumber += num;\n\t\t\t\n\t\t}\n\t\tr = num % <span class=\"hljs-number\">2</span>;\n\t\t<span class=\"hljs-keyword\">if</span> (r == <span class=\"hljs-number\">0</span>) a = num;\n\t\t<span class=\"hljs-keyword\">else</span> b = num;\n\t\t\n\t\t<span class=\"hljs-keyword\">while</span> (number != N) {\n\t\t\ta += cal_a[r];\n\t\t\tb += cal_b[r];\n\t\t\tnumber--;\n\t\t\t\n\t\t}\n\t\t<span class=\"hljs-keyword\">return</span> a+<span class=\"hljs-string\">\"/\"</span>+b;\n\t}\n}\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:26:31.943Z",
		"id": "2019-12-10-algorithm-10",
		"filename": "algorithm\\2019-12-10-algorithm-10.json"
	},
	{
		"layout": "post-content",
		"title": "(수학1) 달팽이는 올라가고 싶다 2869 - 백준 java",
		"date": "2019-12-10T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<h1>문제</h1>\n<p><a href=\"https://www.acmicpc.net/step/8\">달팽이는 올라가고 싶다</a></p>\n<h1>내 풀이</h1>\n<p>하루에 a 만큼 올라가고 b 만큼 내려오므로 하루에 a-b 만큼 막대기에 올라가는 거와 같다. 정상에 도착하면 내려가지않으므로 c-a를 한다. (c-a) / (a-b) 의 값을 올림한 것이 소요된 일 수 이며 c-a를 했으므로 구한 값에 1을 더하면 된다.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">P2869</span> </span>{\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n\t\tScanner sc = <span class=\"hljs-keyword\">new</span> Scanner(System.in);\n\t\t<span class=\"hljs-keyword\">int</span> a = sc.nextInt();\n\t\t<span class=\"hljs-keyword\">int</span> b = sc.nextInt();\n\t\t<span class=\"hljs-keyword\">int</span> c = sc.nextInt();\n\t\tSystem.out.println(Solution(a, b, c));\n\t}\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Solution</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> a, <span class=\"hljs-keyword\">double</span> b, <span class=\"hljs-keyword\">double</span> c)</span> </span>{\n\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">int</span>) Math.ceil((c-a)/(a-b)) + <span class=\"hljs-number\">1</span>;\n\t\t\n\t}\n}\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:26:31.943Z",
		"id": "2019-12-10-algorithm-11",
		"filename": "algorithm\\2019-12-10-algorithm-11.json"
	},
	{
		"layout": "post-content",
		"title": "프로그래머스 기지국 설치 javascript",
		"date": "2019-12-10T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<h1>문제</h1>\n<p><a href=\"https://programmers.co.kr/learn/courses/30/lessons/12979\">프로그래머스 기지국 설치</a></p>\n<p>아파트의 개수 N, 현재 기지국이 설치된 아파트의 번호가 담긴 1차원 배열 stations, 전파의 도달 거리 W가 매개변수로 주어질 때, 모든 아파트에 전파를 전달하기 위해 증설해야 할 기지국 개수의 최솟값을 리턴하는 solution 함수를 완성하는 문제다.</p>\n<h1>내 풀이</h1>\n<p>떠올린 아이디어는 현재 설치된 기지국의 영향이 끼치는 곳에서 범위를 잘라주는 방식이었다.</p>\n<p>예를 들어 다음과 같이 초기 아파트의 상태가 있다면<br/>\n<img src=\"/assets/images/2019-12-10-img/p1-1.png\" alt=\"1\">  <br/>\n<img src=\"/assets/images/2019-12-10-img/p1-1-1.png\" alt=\"1\">  <br/>\n과 같이 분할을 한다.</p>\n<p>이 경우도 마찬가지다. <br/>\n<img src=\"/assets/images/2019-12-10-img/p1-2-1.png\" alt=\"1\">  <br/>\n<img src=\"/assets/images/2019-12-10-img/p1-2-1.png\" alt=\"1\">  <br/></p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution</span>(<span class=\"hljs-params\">n, stations, w</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> answer = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">const</span> func = <span class=\"hljs-function\">(<span class=\"hljs-params\">s, e</span>) =&gt;</span> {\n        <span class=\"hljs-keyword\">if</span> (s &gt; e) <span class=\"hljs-keyword\">return</span>;\n        answer++;\n        func(s+w+w+<span class=\"hljs-number\">1</span>, e);\n    }\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;stations.length; i++) {\n        func(s,stations[i]-w<span class=\"hljs-number\">-1</span>);\n        s = stations[i]+w+<span class=\"hljs-number\">1</span>;\n    }\n    func(s,n);\n    <span class=\"hljs-keyword\">return</span> answer;\n}\n</code></pre>\n<h1>다른 사람 풀이</h1>\n<p>재귀 쓸 필요 없이 해당 범위 크기를 (2*w) + 1로 나눈 후 올림한 값을 구하면 그 범위 내 기지국 개수를 알아 낼 수 있다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution</span>(<span class=\"hljs-params\">n, stations, w</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> answer = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span> ; i&lt;stations.length ; i++){\n        <span class=\"hljs-keyword\">var</span> r = stations[i] - w - <span class=\"hljs-number\">1</span>;\n        answer += <span class=\"hljs-built_in\">Math</span>.ceil((r - s) / ((<span class=\"hljs-number\">2</span> * w) + <span class=\"hljs-number\">1</span>));\n        s = stations[i] + w;\n    }\n    answer += <span class=\"hljs-built_in\">Math</span>.ceil((n - s) / ((<span class=\"hljs-number\">2</span> * w) + <span class=\"hljs-number\">1</span>));  \n    <span class=\"hljs-keyword\">return</span> answer;\n}\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:26:31.737Z",
		"id": "2019-12-10-algorithm-9",
		"filename": "algorithm\\2019-12-10-algorithm-9.json"
	},
	{
		"layout": "post-content",
		"title": "알고리즘 개념 잡자 1탄 - 연결리스트",
		"date": "2019-12-12T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<p>코딩 인터뷰 완전분석 연결리스트 파트 예제 문제 풀이</p>\n<h1>배열</h1>\n<h2>Random access</h2>\n<p>배열의 엘리먼트들은 메모리에 연속적으로 저장되므로 어떤 엘리먼트도 첫번째 엘리먼트의 주소에 각 엘리먼트 크기를 더해서 접근할 수 있다.<br>\n각 엘리먼트가 4byte고 세번째 엘리먼트 접근하려면 첫번째 주소 + 4*3 이다.<br>\n즉, 첫번째 탐색이나 마지막 엘리먼트 탐색 시간 차이가 없다. 탐색 시간 O(1) 가능하다.</p>\n<h2>메모리 낭비</h2>\n<p>개발자가 메모리를 얼마나 사용할 지 모르는 상태에서 배열의 크기를 초기화해야한다.</p>\n<h2>삽입 삭제 연산 느림</h2>\n<p>첫번째 또는 중간 삽입의 경우 삽입 엘리먼트 공간 확보를 위해 배열을 한칸씩 뒤로 이동시켜야한다.<br>\n삭제는 반대로 한칸씩 앞으로 이동시켜야하고 배열의 크기를 재조정해야 한다.<br>\n즉, n개의엘리먼트를 이동시켜야하므로 O(n) 단 맨끝 삭제는 o(1)</p>\n<h1>연결리스트</h1>\n<h2>Iterate access</h2>\n<p>배열과 달리 메모리에 연속적 공간 갖지않고 첫번째 노드의 포인터부터 순회해야한다.<br>\n즉, 탐색은 O(n) 시간복잡도를 가져서 배열보다 탐색이 느리다.</p>\n<h2>리스트 크기를 미리 정의해놓을필요가없음</h2>\n<h2>삽입 삭제 연산 빠름</h2>\n<p>중간노드 끝노드의 경우 위치 찾는데는 o(n) 이지만 실제 삽.삭은 포인터만 업데이트하면되니깐 o(1)이다.<br>\n단, 맨 앞 노드는 o(1)</p>\n<h1>2.1 중복 없애기 : 정렬되어 있지 않은 연결리스트가 주어졌을 때 이 리스트에서 중복되는 원소를 제거하는 코드를 작성하자. 임시 버퍼를 사용할 수 없는 경우도 생각해보자.</h1>\n<ol>\n<li>임시버퍼를 사용할 수 있다면, 중복을 허용하지 않는 Set 컬렉션을 이용해서 해결할 수 있다. 이 경우는 O(N)의 시간 복잡도를 갖는다.</li>\n<li>임시버퍼를 사용할 수 없다면, 이중 반복문을 통해 중복 노드를 찾은 후 제거하면 된다. 이 경우는 O(N^2)의 시간 복잡도를 갖는다.</li>\n</ol>\n<h2>자바스크립트 풀이</h2>\n<pre><code class=\"language-javascript\"><span class=\"hljs-meta\">\n'use strict'</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Node</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(data, next) {\n    <span class=\"hljs-keyword\">this</span>.data = data;\n    <span class=\"hljs-keyword\">this</span>.next = next;\n  }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LinkedList</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(head) {\n    <span class=\"hljs-keyword\">this</span>.head = head;\n  }\n\n  display () {\n    <span class=\"hljs-keyword\">let</span> cur = <span class=\"hljs-keyword\">this</span>.head;\n    <span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-literal\">null</span>) {\n      <span class=\"hljs-built_in\">console</span>.log(cur.data);\n      cur = cur.next;\n    }\n  }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">makeList</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> n6 = <span class=\"hljs-keyword\">new</span> Node(<span class=\"hljs-number\">4</span>);\n  <span class=\"hljs-keyword\">let</span> n5 = <span class=\"hljs-keyword\">new</span> Node(<span class=\"hljs-number\">5</span>, n6);\n  <span class=\"hljs-keyword\">let</span> n4 = <span class=\"hljs-keyword\">new</span> Node(<span class=\"hljs-number\">3</span>, n5);\n  <span class=\"hljs-keyword\">let</span> n3 = <span class=\"hljs-keyword\">new</span> Node(<span class=\"hljs-number\">5</span>, n4);\n  <span class=\"hljs-keyword\">let</span> n2 = <span class=\"hljs-keyword\">new</span> Node(<span class=\"hljs-number\">4</span>, n3);\n  <span class=\"hljs-keyword\">let</span> n1 = <span class=\"hljs-keyword\">new</span> Node(<span class=\"hljs-number\">5</span>, n2);\n  <span class=\"hljs-keyword\">let</span> list = <span class=\"hljs-keyword\">new</span> LinkedList(n1);\n  <span class=\"hljs-keyword\">return</span> list\n}\n\n<span class=\"hljs-comment\">// O(n) n: 연결리스트 길이</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution</span>(<span class=\"hljs-params\"></span>) </span>{  \n  <span class=\"hljs-keyword\">const</span> list = makeList();\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">set</span> = new Set();\n  let cur = list.head;\n  let pre = null;\n  while (cur != null) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">set</span>.has(cur.data)) {\n      pre.next = cur.next;     \n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">set</span>.add(cur.data);\n        pre = cur;\n    }\n    cur = cur.next;\n  }\n  list.display();\n}\n\n// O(N^2) 버퍼 없이\nfunction solution_2() {\n  <span class=\"hljs-keyword\">const</span> list = makeList();\n  <span class=\"hljs-keyword\">let</span> cur = list.head;\n\n  <span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-literal\">null</span>) {\n    <span class=\"hljs-keyword\">let</span> mn = cur;\n\n    <span class=\"hljs-keyword\">while</span> (mn.next != <span class=\"hljs-literal\">null</span>) {\n        <span class=\"hljs-keyword\">if</span> (cur.data === mn.next.data) {\n            mn.next = mn.next.next;\n        } <span class=\"hljs-keyword\">else</span> {\n            mn = mn.next;\n        }\n    }\n    cur = cur.next;\n  }\n\n  list.display();   \n}\n\nsolution();\nsolution_2();\n</code></pre>\n<p><strong>자바스크립트의 null과 undefined</strong><br>\n자바스크립트에서 '없음’을 나타내는 값에 null과 undefined가 있다. 값이 대입되지 않은 변수나 속성의 경우는 undefined이며 객체가 없는 경우는 null로 나타낸다.<br>\n자바스크립트의 === 등호는 값이 정확히 같을 때 true를 반환하나 == 등호는 그렇지 않을 때가 많다. 보통의 경우는 === 를 권장하나 null check 할 때는 == 쓰면 값이 null 또는 undefined의 경우 false를 리턴 받을 수 있다.</p>\n<p><strong>자바스크립트의 class</strong><br>\nES6의 클래스 선언은 호이스팅이 되지 않아서 클래스를 사용하기 위해서는 클래스를 먼저 선언해야 한다. class body는 {}로 묶여 있는 안쪽 부분으로 constructor(생성자)가 있는 곳이다. 객체를 생성하고 초기화하는 메소드로 클래스 안에 한 개만 존재할 수 있다. 부모 생성자를 호출하기 위해 super 키워드를 사용할 수도 있다.</p>\n<p><strong>자바스크립트에서 오토박싱</strong><br>\nnon-strict 모드에서 this 값이 null 혹은 undefined 일 경우 window 객체로 자동으로 변환을 해주는 것을 오토박싱이라고 한다. 그래서 일반 메서드에서 this 값이 window 객체가 된다. class 문법 안에 있는 코드는 항상 strict mode로 실행되기 때문에 클래스 메서드 호출에서 this의 초기값은 undefined다.</p>\n<p><strong>자바에서 오토박싱</strong><br>\n자바에는 int, float와 같은 기본형(primitive type)과 Integer, Float와 같은 래퍼 클래스가 있다. 래퍼 클래스는 기본형을 객체로 다루어야 할 경우에 사용할 수 있다. 컬렉션에서 엘리먼트는 객체가 되어야 되서 int 기본형을 사용하지 않고 Integer를 사용하는 것을 본 적이 있을 거다.    박싱은 기본형을 참조형으로 변환하는 것이고 언박싱은 반대로 참조형을 기본형으로 바꾸는 것이다. 예제를 통해 확실히 이해해보자.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">int</span> pa = <span class=\"hljs-number\">1</span>;\nInteger wa = pa; <span class=\"hljs-comment\">// 오토박싱</span>\n\nInteger wb = <span class=\"hljs-keyword\">new</span> Integer(<span class=\"hljs-number\">2</span>);\n<span class=\"hljs-keyword\">int</span> pb = wb; <span class=\"hljs-comment\">// 오토언박싱</span>\n\n</code></pre>\n<h2>자바 풀이</h2>\n<p><strong>리스트 반복하면서 삭제하기</strong><br>\nfor(;;)를 이용한 방법은 반복 도중 엘리먼트가 삭제되면 반복문의 크기가 변한다. 또한 삭제된 엘리먼트 자리를 채우기 위해 모든 인덱스가 하나씩 이동하게 된다. 생각대로 동작하지 않는 것 당연하다.</p>\n<p>for-each문 안에서 엘리먼트를 삭제하게 되면 <strong>java.util.ConcurrentModificationException</strong> 에러를 보게 된다. Iterator로 반복 중인 리스트를 수정하려 하면 이 에러가 발생된다. for-each 문은 내부적으로 iterator를 실행하므로 remove()나 add()를 할 경우 에러가 발생되는 것이다.</p>\n<p>그래서 반복을 하면서 삭제를 하려면 Itertor 인터페이스를 사용하거나 Collection 인터페이스의 removeif 메서드를 사용한다.</p>\n<pre><code class=\"language-java\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n\t\tLinkedList&lt;Integer&gt; list = <span class=\"hljs-keyword\">new</span> LinkedList&lt;&gt;(Arrays.asList(<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">4</span>));\n\t\tsolution(list);\n\t}\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">solution</span><span class=\"hljs-params\">(LinkedList&lt;Integer&gt; list)</span> </span>{\n\t\t<span class=\"hljs-comment\">// 1번 iterator 사용</span>\n\t\tHashSet&lt;Integer&gt; set = <span class=\"hljs-keyword\">new</span> HashSet&lt;Integer&gt;();\n\t\tIterator&lt;Integer&gt; it = list.iterator();\n\t\t\n\t\t<span class=\"hljs-keyword\">while</span>(it.hasNext()) {\n\t\t\t<span class=\"hljs-keyword\">int</span> next = it.next();\n\t\t\t<span class=\"hljs-keyword\">if</span> (set.contains(next)) it.remove();\n\t\t\t<span class=\"hljs-keyword\">else</span> set.add(next);\n\t\t}\n\n\t\t<span class=\"hljs-comment\">// 2번 removeif 사용</span>\n\t\tHashSet&lt;Integer&gt; set = <span class=\"hljs-keyword\">new</span> HashSet&lt;Integer&gt;();\n\t\tlist.removeIf(num -&gt; {\n\t\t\t<span class=\"hljs-keyword\">if</span> (set.contains(num)) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n\t\t\t<span class=\"hljs-keyword\">else</span> {\n\t\t\t\tset.add(num);\n\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n\t\t\t}\n\t\t});\n\t}\n</code></pre>\n<h1>2.2 뒤에서 K번째 원소 구하기: 단방향 연결리스트가 주어졌을 때 뒤에서 K번째 원소를 찾는 알고리즘을 구현하라.</h1>\n<h2>내 풀이</h2>\n<p>리스트의 크기를 구하기 위해 한번 순회한 다음, 리스트 크기에 k만큼 뺀 index까지 반복을 돌려 원소를 찾았다.<br>\n시간 복잡도는 O(N)</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution_2</span>(<span class=\"hljs-params\">k</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> list = makeList();\n\n  <span class=\"hljs-keyword\">let</span> cur = list.head;\n  <span class=\"hljs-keyword\">let</span> len = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-literal\">null</span>) {\n      len++;\n      cur = cur.next;\n  }\n\n  cur = list.head;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;len-k; i++) {\n      cur = cur.next;\n  }\n  \n  <span class=\"hljs-keyword\">if</span> (len-k &lt; <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> cur.data;\n  <span class=\"hljs-comment\">//console.log(`뒤에서 ${k}번째 원소 값 : ${cur.data}`);</span>\n}\n</code></pre>\n<h2>반복문을 한번만 돌릴 수 있다면?</h2>\n<p>Runner 기법을 사용했다. 연결리스트 문제에서 많이 활용되는 기법으로 순회할 때 두 개의 포인터를 동시에 사용하는 방법이다. 이 때 한 포인트가 다른 포인터보다 앞서도록 하며 앞선 포인터가 따라오는 포인터보다 <strong>항상 지정된 개수만큼</strong> 앞서거나, 따라오는 포인터를 <strong>여러 노드를 한번에 뛰어넘도록</strong> 설정할 수 있다.</p>\n<p>시간복잡도는 O(N) 이다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution_2_1</span>(<span class=\"hljs-params\">k</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> list = makeList();\n  \n  <span class=\"hljs-keyword\">let</span> cur = list.head;\n  <span class=\"hljs-keyword\">let</span> runner = cur;\n  <span class=\"hljs-keyword\">let</span> len = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-literal\">null</span>) {\n    <span class=\"hljs-keyword\">if</span> (len++ &gt;= k) runner = runner.next;\n    cur = cur.next;\n  }\n  <span class=\"hljs-keyword\">if</span> (len-k &lt; <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> runner.data;\n  <span class=\"hljs-comment\">// console.log(`뒤에서 ${k}번째 원소 값 : ${runner.data}`);</span>\n}\n</code></pre>\n<h1>2.3 중간 노드 삭제: 단방향 연결리스트가 주어졌을 때 중간(정확히 가운데 노드일 필요는 없고 처음과 끝 노드만 아니면 된다)에 있는 노드 하나를 삭제하는 알고리즘을 구현해라. 단, 삭제할 노드에만 접근할 수 있다.</h1>\n<p>Runner 기법으로 중간 노드를 찾고 찾은 노드의 data와 next 값을 바로 다음 노드의 값으로 바꾼 다음 다음 노드의 next를 찾은 노드의 next로 지정한다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution_3</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> list = makeList();\n  <span class=\"hljs-keyword\">let</span> cur = list.head;\n  <span class=\"hljs-keyword\">let</span> runner = list.head;\n  <span class=\"hljs-keyword\">let</span> len = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-literal\">null</span>) {\n      cur = cur.next;      \n      <span class=\"hljs-keyword\">if</span> ((++len)%<span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) runner = runner.next;\n  }\n\n  <span class=\"hljs-keyword\">if</span> (runner.next == <span class=\"hljs-literal\">null</span>) {\n    runner.data = <span class=\"hljs-literal\">null</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    runner.data = runner.next.data;\n    runner.next = runner.next.next;\n  }\n  \n  list.display();\n}\n</code></pre>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution_3</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> list = makeList();\n\n  <span class=\"hljs-keyword\">let</span> cur = list.head;\n  <span class=\"hljs-keyword\">let</span> prerunner = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">let</span> runner = list.head;\n  <span class=\"hljs-keyword\">let</span> len = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-literal\">null</span> &amp;&amp; cur.next != <span class=\"hljs-literal\">null</span>) {\n      cur = cur.next.next;   \n      prerunner = runner; \n      runner = runner.next;\n  }\n  <span class=\"hljs-keyword\">if</span> (cur != <span class=\"hljs-literal\">null</span>) {\n    prerunner = runner;\n    runner = runner.next;\n  }\n  <span class=\"hljs-comment\">// 노드 갯수가 2 이하일 때, 처음/끝 노드가 삭제되는 것을 막기 위해</span>\n  <span class=\"hljs-keyword\">if</span> (prerunner == <span class=\"hljs-literal\">null</span> || runner.next == <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span>;\n\n  prerunner.next = runner.next; \n  list.display();\n  \n}\n</code></pre>\n<h1>2.4 분할: 값 x가 주어졌을 때 x보다 작은 노드들을 x보다 크거나 같은 노드들보다 앞에 오도록 하는 코드를 작성하라. 만약 x가 리스트에 있다면 x는 그보다 작은 원소들보다 뒤에 나오기만 하면 된다. 즉, 원소 x는 ‘오른쪽 그룹’ 어딘가에만 존재하면 된다. 왼쪽과 오른쪽 그룹 사이에 있을 필요는 없다.</h1>\n<ul>\n<li>입력: 3-&gt;5-&gt;8-&gt;5-&gt;10-&gt;2-&gt;1 (분할값 x = 5)</li>\n<li>출력: 3-&gt;1-&gt;2-&gt;10-&gt;5-&gt;5-&gt;8</li>\n</ul>\n<p>순회를 하면서 data 값이 x보다 작은 경우에는 무조건 맨 앞으로 이동시키는 식으로 해결했다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution_4</span>(<span class=\"hljs-params\">x</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> list = makeList();\n  <span class=\"hljs-keyword\">let</span> cur, pre;\n  <span class=\"hljs-keyword\">if</span> (list.head.data &lt; x) {\n      cur = list.head.next;\n      pre = list.head;\n  } <span class=\"hljs-keyword\">else</span> {\n      cur = list.head;\n      pre = <span class=\"hljs-literal\">null</span>;\n  }\n\n  <span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-literal\">null</span>) {\n      <span class=\"hljs-keyword\">if</span> (cur.data &lt; x) {\n        pre.next = cur.next;\n        cur.next = list.head;\n        list.head = cur;\n        cur = pre.next;\n      } <span class=\"hljs-keyword\">else</span> {\n        pre = cur;\n        cur = cur.next;\n      }    \n  }\n  \n  list.display();\n  \n}\n</code></pre>\n<h2>그렇다면 원소의 순서를 유지하면서 x보다 작은 노드들을 x의 앞에 위치하게 하고 싶다면?</h2>\n<p>두 개의 연결리스트를 만들어서 하나는 x보다 작은 노드들을 삽입하고 다른 하나는 x보다 크거나 같은 노드들을 넣는다. 모든 작업이 완료된 후 두 리스트를 합하면 된다.</p>\n<h1>2.5 리스트의 합: 연결리스트로 숫자를 표현할 때 각 노드가 자릿수 하나를 가리키는 방식으로 표현할 수 있다. 각 숫자는 역순으로 배열되어 있는데, 첫 번째 자릿수가 리스트의 맨 앞에 위치하도록 배열된다는 뜻이다. 이와 같은 방식으로 표현된 숫자 두 개가 있을 때, 이 두 수를 더하여 그 합을 연결리스트로 반환하는 함수를 작성하라</h1>\n<ul>\n<li>입력: (7-&gt;1-&gt;6) + (5-&gt;9-&gt;2) 즉, 617 + 295</li>\n<li>출력: 2-&gt;1-&gt;9 즉, 912</li>\n</ul>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution_5</span>(<span class=\"hljs-params\">list_1, list_2</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> cur_1 = list_1.head, cur_2 = list_2.head;\n  <span class=\"hljs-keyword\">let</span> c = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">let</span> newListHead = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">let</span> newList = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">while</span> (cur_1 != <span class=\"hljs-literal\">null</span> || cur_2 != <span class=\"hljs-literal\">null</span>) {\n    <span class=\"hljs-keyword\">if</span> (cur_1 == <span class=\"hljs-literal\">null</span> || cur_2 == <span class=\"hljs-literal\">null</span>) {\n      newList.next = cur_1 == <span class=\"hljs-literal\">null</span> ? cur_2: cur_1;\n      <span class=\"hljs-keyword\">break</span>;\n    }\n    <span class=\"hljs-keyword\">let</span> sum = cur_1.data + cur_2.data + c;\n    <span class=\"hljs-keyword\">if</span> (newList == <span class=\"hljs-literal\">null</span>) {\n      newList = <span class=\"hljs-keyword\">new</span> Node(sum % <span class=\"hljs-number\">10</span>);\n      newListHead = <span class=\"hljs-keyword\">new</span> LinkedList(newList);\n    }\n    <span class=\"hljs-keyword\">else</span> {\n      newList.next = <span class=\"hljs-keyword\">new</span> Node(sum % <span class=\"hljs-number\">10</span>);\n      newList = newList.next;\n    }\n    c = <span class=\"hljs-built_in\">parseInt</span>(sum / <span class=\"hljs-number\">10</span>);\n    cur_1 = cur_1.next;\n    cur_2 = cur_2.next;\n  }\n\n  newListHead.display();  \n}\n</code></pre>\n<h2>각 자릿수가 정상적으로 배열된다고 가정하고 같은 문제를 풀면?</h2>\n<ul>\n<li>입력: (6-&gt;1-&gt;7) + (2-&gt;9-&gt;5) 즉, 617+295</li>\n<li>출력: 9-&gt;1-&gt;2 즉, 912</li>\n</ul>\n<p>재귀로 순회해서 끝에서 부터 더해가면 된다. 단, 리스트의 길이가 다를 경우가 있으므로 이 부분을 고려해야 한다.\n재귀 안에서 해결해볼까 했는 데, 복잡해져서 아예 길이를 같게 만드는 방법으로 해보았다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution_5_1</span>(<span class=\"hljs-params\">list_1, list_2</span>) </span>{  \n  <span class=\"hljs-keyword\">let</span> list_1_len = getSize(list_1.head), list_2_len = getSize(list_2.head);\n\n  <span class=\"hljs-keyword\">while</span> (list_1_len &gt; list_2_len) {\n    list_2.head = <span class=\"hljs-keyword\">new</span> Node(<span class=\"hljs-number\">0</span>, list_2.head);\n    list_2_len++;\n  }\n  <span class=\"hljs-keyword\">while</span> (list_1_len &lt; list_2_len) {\n    list_1.head = <span class=\"hljs-keyword\">new</span> Node(<span class=\"hljs-number\">0</span>, list_1.head);\n    list_1_len++;\n  }\n  \n  <span class=\"hljs-keyword\">let</span> newList = <span class=\"hljs-literal\">null</span>;\n  recursion(list_1.head, list_2.head);\n\n  newList.display();\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">recursion</span> (<span class=\"hljs-params\">cur_1, cur_2</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (cur_1 == <span class=\"hljs-literal\">null</span> &amp;&amp; cur_2 == <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">let</span> sum = cur_1.data + cur_2.data + recursion(cur_1.next, cur_2.next);\n    <span class=\"hljs-keyword\">if</span> (newList == <span class=\"hljs-literal\">null</span>) {\n      newList = <span class=\"hljs-keyword\">new</span> LinkedList(<span class=\"hljs-keyword\">new</span> Node(sum % <span class=\"hljs-number\">10</span>));\n    }\n    <span class=\"hljs-keyword\">else</span> {\n      newList.head = <span class=\"hljs-keyword\">new</span> Node(sum % <span class=\"hljs-number\">10</span>, newList.head);\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">parseInt</span>(sum / <span class=\"hljs-number\">10</span>);\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getSize</span> (<span class=\"hljs-params\">list</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> cur = list;\n    <span class=\"hljs-keyword\">let</span> len = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-literal\">null</span>) {\n      len++;\n      cur = cur.next;\n    }\n    <span class=\"hljs-keyword\">return</span> len;\n  }\n}\n</code></pre>\n<h1>회문: 주어진 연결리스트가 회문인지 검사하는 함수를 작성하라</h1>\n<p>회문이란? 순서를 거꾸로 읽어도 제대로 읽은 것과 같은 단어와 문장을 말한다.<br>\n예시) level, sos</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution_6</span>(<span class=\"hljs-params\">list</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> cur = list.head;\n  <span class=\"hljs-keyword\">return</span> recursion(list.head);\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">recursion</span> (<span class=\"hljs-params\">list</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (list == <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;    \n    <span class=\"hljs-keyword\">let</span> chk = recursion(list.next) &amp;&amp; (cur.data === list.data);\n    cur = cur.next;\n    <span class=\"hljs-keyword\">return</span> chk;\n  }\n}\n</code></pre>\n<h2>책 해법 1. 뒤집어서 비교하기</h2>\n<p>연결리스트를 순회하면서 새 리스트의 맨 앞에 삽입하면서 역순 리스트를 만든 후 비교한다.</p>\n<h2>책 해법 2. runner와 스택 이용</h2>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution_6_1</span>(<span class=\"hljs-params\">list</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> cur = list.head;\n  <span class=\"hljs-keyword\">let</span> runner = cur;\n  <span class=\"hljs-keyword\">let</span> len = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">let</span> array = <span class=\"hljs-built_in\">Array</span>();\n  <span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-literal\">null</span> &amp;&amp; cur.next != <span class=\"hljs-literal\">null</span>) {\n    len++;\n    array.push(runner.data);\n    runner = runner.next;\n    cur = cur.next.next;\n  }\n\n  <span class=\"hljs-keyword\">if</span> (len % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>) runner = runner.next;\n\n  <span class=\"hljs-keyword\">while</span> (runner != <span class=\"hljs-literal\">null</span>) { \n    <span class=\"hljs-keyword\">if</span> (array.pop() !== runner.data) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    runner = runner.next;\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n}\n</code></pre>\n<h1>교집합: 단방향 연결리스트 두 개가 주어졌을 때 이 두 리스트의 교집합 노드를 찾은 뒤 반환하는 코드를 작성하라. 여기서 교집합이란 노드의 값이 아니라 노드의 주소가 완전히 같은 경우를 말한다. 즉, 첫 번째 리스트에 있는 k번째 노드와 두 번째 리스트에 있는 j번째 노드가 주소까지 완전히 같다면 이 노드는 교집합의 원소가 된다.</h1>\n<p>두 연결리스트에서 교집합이 있다는 것은… 그 교집합 노드 뒤부터는 같은 노드라는 것, 즉 마지막 노드가 같다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution_7</span>(<span class=\"hljs-params\">list_1, list_2</span>) </span>{  \n  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">set</span> = new Set();\n  let newList = null;\n  let cur = list_1.head;\n  while (cur != null) {\n    <span class=\"hljs-keyword\">set</span>.add(cur);\n    cur = cur.next;\n  }\n\n  cur = list_2.head;\n  while (cur != null) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">set</span>.has(cur)) {\n      newList = cur;\n      <span class=\"hljs-keyword\">break</span>;\n    }\n    cur = cur.next;\n  }\n  <span class=\"hljs-keyword\">if</span> (newList == <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> LinkedList(newList);\n}\n</code></pre>\n<h2>책 풀이</h2>\n<ol>\n<li>두 연결리스트를 순회해서 마지막 노드와 사이즈를 구하고 각 마지막 노드가 같으면 교집합이 존재하며 다르면 교집합은 없다.</li>\n<li>길이가 더 긴 연결리스트의 포인터를 이동시켜서 두 연결리스트 순회 길이가 같도록 포인터를 맞춘다.</li>\n<li>동시에 두 연결리스트의 포인트를 이동시키면서 같은 노드가 발견되는 순간을 찾는다.</li>\n</ol>\n<h1>루프발견: 순환 연결리스트가 주어졌을 때, 순환되는 부분의 첫째 노드를 반환하는 알고리즘을 작성하라. 순환 연결리스트란 노드의 next 포인터가 앞선 노드들 가운데 어느 하나를 가리키도록 설정되어 있는, 엄밀히 말해서 변질된 방식의 연결리스트를 의미한다.</h1>\n<ul>\n<li>입력: A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C (앞에 나온 C와 같음)</li>\n<li>출력: C</li>\n</ul>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution_8</span>(<span class=\"hljs-params\">list</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">set</span> = new Set();\n  let cur = list.head;\n  \n  while (cur != null) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">set</span>.has(cur)) return cur.data;\n    <span class=\"hljs-keyword\">set</span>.add(cur);    \n    cur = cur.next;\n  }\n  return null;\n}\n</code></pre>\n<h1>끝!</h1>\n",
		"updatedAt": "2020-02-23T12:39:19.024Z",
		"id": "2019-12-12-coding-interview-linkedlist-1",
		"filename": "algorithm\\2019-12-12-coding-interview-linkedlist-1.json"
	},
	{
		"layout": "post-content",
		"title": "프로그래머스 - lv3 네트워크, lv2 짝지어 제거하기",
		"date": "2019-12-30T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<hr>\n<h1># LV3 네트워크</h1>\n<p>각 행을 순회해서 컬럼 값이 1일 때, 해당 col을 row로 하여 또 순회하는 식으로 해결했다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution</span>(<span class=\"hljs-params\">n, computers</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> answer = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">var</span> arr = [];\n    arr = computers.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">acc, cur</span>) =&gt;</span> {\n        acc.push(cur.includes(<span class=\"hljs-number\">1</span>));\n        <span class=\"hljs-keyword\">return</span> acc;\n    }, []);\n    \n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;n; i++) {\n        <span class=\"hljs-keyword\">if</span> (arr[i]) {           \n            dfs(i);\n            answer++;\n        }\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dfs</span>(<span class=\"hljs-params\">row</span>) </span>{\n        <span class=\"hljs-keyword\">if</span> (!arr[row]) <span class=\"hljs-keyword\">return</span>;\n        arr[row] = <span class=\"hljs-literal\">false</span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;n; i++) {            \n            <span class=\"hljs-keyword\">if</span> (computers[row][i] &gt; <span class=\"hljs-number\">0</span>) {\n                computers[row][i] = <span class=\"hljs-number\">0</span>;\n                dfs(i);\n            }        \n        }\n    }\n\n    <span class=\"hljs-keyword\">return</span> answer;\n}\n</code></pre>\n<h1># lv2 짝지어 제거하기</h1>\n<p>스택을 생각해냈으면 쉽게 해결할 수 있다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">solution</span>(<span class=\"hljs-params\">s</span>)\n</span>{\n    <span class=\"hljs-keyword\">var</span> stack = [];\n    stack.push(s[<span class=\"hljs-number\">0</span>]);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">1</span>; i&lt;s.length; i++) {\n        <span class=\"hljs-keyword\">if</span> (stack[stack.length<span class=\"hljs-number\">-1</span>] === s[i]) stack.pop();\n        <span class=\"hljs-keyword\">else</span> stack.push(s[i])\n    }\n    <span class=\"hljs-keyword\">return</span> stack.length ? <span class=\"hljs-number\">0</span> : <span class=\"hljs-number\">1</span>;\n}\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:27:31.522Z",
		"id": "2019-12-30-algorithm-12",
		"filename": "algorithm\\2019-12-30-algorithm-12.json"
	},
	{
		"layout": "post-content",
		"title": "백준 - 16235 나무 재테크(C++)",
		"date": "2020-01-28T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<h1>나무 재테크</h1>\n<ul>\n<li>각 계절을 구현하는 데는 어려움이 없었으나 처음에 벡터 하나에 나무를 다 저장하고 매번 sort를 해서 시간 초과가 발생했었다.</li>\n<li>고민하다가 각 칸마다 deque에 나무 나이를 담는 식으로 바꿨다.</li>\n<li>vector가 아닌 deque를 선택한 건 가을(번식)때 생성되는 나무는 나이가 1이므로 맨 앞에 추가되어야하기 때문이다.</li>\n<li>vector는 배열이라 맨 앞 추가할 때 O(N)의 시간복잡도가 발생한다.</li>\n<li>deque로 바꿨기에 처음 1번만 sort를 사용하여 효율성을 높였다.</li>\n</ul>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;vector&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;algorithm&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;deque&gt;</span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> MAX 10</span>\n\n<span class=\"hljs-keyword\">int</span> N, M, K;\n<span class=\"hljs-keyword\">int</span> A[MAX][MAX]; <span class=\"hljs-comment\">// 로봇 양분</span>\n<span class=\"hljs-keyword\">int</span> L[MAX][MAX]; <span class=\"hljs-comment\">// 땅</span>\n<span class=\"hljs-built_in\">deque</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; T[MAX][MAX]; <span class=\"hljs-comment\">// 각 땅의 나무 나이</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addTree</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> r, <span class=\"hljs-keyword\">int</span> c)</span></span>{\n\t<span class=\"hljs-keyword\">if</span> (r &lt; <span class=\"hljs-number\">0</span> || c &lt; <span class=\"hljs-number\">0</span> || r &gt;= N || c &gt;= N) <span class=\"hljs-keyword\">return</span>;\n\tT[r][c].push_front(<span class=\"hljs-number\">1</span>);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n\t<span class=\"hljs-keyword\">int</span> x, y, age;\n\t<span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d %d %d\"</span>, &amp;N, &amp;M, &amp;K);\n\t\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;N; i++) {\n\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>; j&lt;N; j++) {\n\t\t\t<span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d\"</span>, &amp;A[i][j]);\n\t\t\tL[i][j] = <span class=\"hljs-number\">5</span>;\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;M; i++) {\n\t\t<span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d %d %d\"</span>, &amp;x, &amp;y, &amp;age);\n\t\tT[--x][--y].push_back(age);\n\t}\n\t\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;N; i++) {\n\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>; j&lt;N; j++) {\n\t\t\t<span class=\"hljs-keyword\">if</span> (T[i][j].size() &gt; <span class=\"hljs-number\">1</span>) {\n\t\t\t\tsort(T[i][j].begin(), T[i][j].end());\n\t\t\t}\n\t\t}\n\t}\n\t\n\t<span class=\"hljs-keyword\">bool</span> flag;\n\t<span class=\"hljs-keyword\">while</span>(K-- &gt; <span class=\"hljs-number\">0</span>) {\n\t\t\n\t\t<span class=\"hljs-comment\">// 같은 칸이면 어린 순으로 나이만큼 양분먹고 나이 증가</span>\n\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;N; i++) {\n\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>; j&lt;N; j++) {\n\t\t\t\t<span class=\"hljs-built_in\">deque</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; &amp;tmp = T[i][j];\n\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;\n\t\t\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> iter=tmp.begin(); iter != tmp.end();) {\n\t\t\t\t\t<span class=\"hljs-keyword\">int</span> &amp;t = *iter;\n\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (L[i][j] &gt;= t &amp;&amp; flag) {\n\t\t\t\t\t\tL[i][j] -= t;\n\t\t\t\t\t\tt += <span class=\"hljs-number\">1</span>;\n\t\t\t\t\t\titer++;\n\t\t\t\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\t\t\t\tflag = <span class=\"hljs-literal\">false</span>;\n\t\t\t\t\t\t<span class=\"hljs-comment\">// 여름 처리</span>\n\t\t\t\t\t\tL[i][j] += t / <span class=\"hljs-number\">2</span>;\n\t\t\t\t\t\titer = tmp.erase(iter);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t<span class=\"hljs-comment\">// 나이 5의 배수 나무 번식</span>\n\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;N; i++) {\n\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>; j&lt;N; j++) {\n\t\t\t\t<span class=\"hljs-built_in\">deque</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; &amp;tmp = T[i][j];\n\t\t\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> iter=tmp.begin(); iter != tmp.end(); iter++) {\n\t\t\t\t\t<span class=\"hljs-keyword\">int</span> t = *iter;\n\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (t % <span class=\"hljs-number\">5</span> == <span class=\"hljs-number\">0</span>) {\n\t\t\t\t\t\taddTree(i - <span class=\"hljs-number\">1</span>, j - <span class=\"hljs-number\">1</span>);\n\t\t\t\t\t\taddTree(i - <span class=\"hljs-number\">1</span>, j);\n\t\t\t\t\t\taddTree(i - <span class=\"hljs-number\">1</span>, j + <span class=\"hljs-number\">1</span>);\n\t\t\t\t\t\taddTree(i, j - <span class=\"hljs-number\">1</span>);\n\t\t\t\t\t\taddTree(i, j + <span class=\"hljs-number\">1</span>);\n\t\t\t\t\t\taddTree(i + <span class=\"hljs-number\">1</span>, j - <span class=\"hljs-number\">1</span>);\n\t\t\t\t\t\taddTree(i + <span class=\"hljs-number\">1</span>, j);\n\t\t\t\t\t\taddTree(i + <span class=\"hljs-number\">1</span>, j + <span class=\"hljs-number\">1</span>);\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t<span class=\"hljs-comment\">// 로봇이 양분 추가</span>\n\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;N; i++) {\n\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>; j&lt;N; j++) {\n\t\t\t\tL[i][j] += A[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\t<span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;N; i++) {\n\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>; j&lt;N; j++) {\n\t\t\tans += T[i][j].size();\n\t\t}\n\t}\n\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d\"</span>, ans);\n\t\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n",
		"updatedAt": "2020-01-28T09:30:37.302Z",
		"id": "2020-01-28-algorithm-13",
		"filename": "algorithm\\2020-01-28-algorithm-13.json"
	},
	{
		"layout": "post-content",
		"title": "백준 - 17143 낚시왕(C++)",
		"date": "2020-01-28T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<h1>낚시왕</h1>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;vector&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;map&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cstring&gt;</span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Shark</span>\n{</span>\n\t<span class=\"hljs-keyword\">int</span> r;\n\t<span class=\"hljs-keyword\">int</span> c;\n\t<span class=\"hljs-keyword\">int</span> s; <span class=\"hljs-comment\">// 속력</span>\n\t<span class=\"hljs-keyword\">int</span> d; <span class=\"hljs-comment\">// 이동</span>\n\t<span class=\"hljs-keyword\">int</span> z; <span class=\"hljs-comment\">// 크기</span>\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n\t<span class=\"hljs-keyword\">int</span> R, C, M;\n\t<span class=\"hljs-keyword\">int</span> r, c, s, d, z;\n\t<span class=\"hljs-built_in\">map</span>&lt;<span class=\"hljs-keyword\">int</span>, Shark&gt; sharkmap; <span class=\"hljs-comment\">// 상어정보들 [크기, 정보구조체]</span>\n\t<span class=\"hljs-built_in\">map</span>&lt;<span class=\"hljs-keyword\">int</span>, Shark&gt;::iterator it;\n\t<span class=\"hljs-keyword\">int</span> row[<span class=\"hljs-number\">5</span>] = {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>}; <span class=\"hljs-comment\">// 1:위, 2:아래, 3: 오른쪽, 4:왼쪽</span>\n\t<span class=\"hljs-keyword\">int</span> col[<span class=\"hljs-number\">5</span>] = {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>};\n\t<span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n\t\n\t<span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d %d %d\"</span>, &amp;R, &amp;C, &amp;M);\n\t<span class=\"hljs-keyword\">int</span> arr[R+<span class=\"hljs-number\">1</span>][C+<span class=\"hljs-number\">1</span>] = {<span class=\"hljs-number\">0</span>};\n\t<span class=\"hljs-keyword\">int</span> arrtmp[R+<span class=\"hljs-number\">1</span>][C+<span class=\"hljs-number\">1</span>] = {<span class=\"hljs-number\">0</span>};\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;M; i++) {\n\t\t<span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d %d %d %d %d\"</span>, &amp;r, &amp;c, &amp;s, &amp;d, &amp;z);\n\t\tarr[r][c] = z;\n\t\tShark tmp = {r, c, s, d, z};\n\t\tsharkmap.insert(make_pair(z, tmp));\n\t}\n\t\n\t\n\t<span class=\"hljs-keyword\">int</span> nr, nc, nd, move;\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>; i&lt;=C; i++) {\n\t\t\n\t\t\n\t\t<span class=\"hljs-comment\">// 상어잡기</span>\n\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>; j&lt;=R; j++) {\n\t\t\t<span class=\"hljs-keyword\">if</span> (arr[j][i] &gt; <span class=\"hljs-number\">0</span>) {\n\t\t\t\tsharkmap.erase(arr[j][i]);\n\t\t\t\tans += arr[j][i];\n\t\t\t\tarr[j][i] = <span class=\"hljs-number\">0</span>;\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t}\n\t\t}\n\t\t\n\t\t<span class=\"hljs-comment\">// 상어이동</span>\n\t\t<span class=\"hljs-keyword\">for</span>(it=sharkmap.begin(); it != sharkmap.end(); it++) {\n\t\t\tShark &amp;shark = it -&gt; second;\n\t\t\t<span class=\"hljs-comment\">// 오른쪽, 왼쪽</span>\n\t\t\t<span class=\"hljs-keyword\">if</span> (shark.d == <span class=\"hljs-number\">3</span> || shark.d == <span class=\"hljs-number\">4</span>) {\n\t\t\t\tmove = shark.s % ((C<span class=\"hljs-number\">-1</span>)*<span class=\"hljs-number\">2</span>);\t<span class=\"hljs-comment\">// 실제 이동해야할 MOVE</span>\n\t\t\t\tnc = shark.c;\n\t\t\t\tnd = shark.d;\n\t\t\t\t<span class=\"hljs-keyword\">while</span> (move &gt; <span class=\"hljs-number\">0</span>) {\n\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (nc == <span class=\"hljs-number\">1</span>) nd = <span class=\"hljs-number\">3</span>;\n\t\t\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (nc == C) nd = <span class=\"hljs-number\">4</span>;\n\t\t\t\t\tnc += col[nd];\n\t\t\t\t\tmove--;\n\t\t\t\t}\n\t\t\t\tshark.d = nd;\n\t\t\t\tshark.c = nc;\n\t\t\t} \n\t\t\t<span class=\"hljs-comment\">// 위, 아래 </span>\n\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (shark.d == <span class=\"hljs-number\">1</span> || shark.d == <span class=\"hljs-number\">2</span>) {\n\t\t\t\tmove = shark.s % ((R<span class=\"hljs-number\">-1</span>)*<span class=\"hljs-number\">2</span>);\t<span class=\"hljs-comment\">// 실제 이동해야할 MOVE</span>\n\t\t\t\tnr = shark.r;\n\t\t\t\tnd = shark.d;\n\t\t\t\t<span class=\"hljs-keyword\">while</span> (move &gt; <span class=\"hljs-number\">0</span>) {\n\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (nr == <span class=\"hljs-number\">1</span>) nd = <span class=\"hljs-number\">2</span>;\n\t\t\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (nr == R) nd = <span class=\"hljs-number\">1</span>;\n\t\t\t\t\tnr += row[nd];\n\t\t\t\t\tmove--;\n\t\t\t\t}\n\t\t\t\tshark.d = nd;\n\t\t\t\tshark.r = nr;\n\t\t\t}\n\t\t\t<span class=\"hljs-comment\">// 상어 먹기</span>\n\t\t\t<span class=\"hljs-keyword\">if</span> (arrtmp[shark.r][shark.c] &lt; shark.z) {\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (arrtmp[shark.r][shark.c] &gt; <span class=\"hljs-number\">0</span>) \n\t\t\t\t\tsharkmap.erase(arrtmp[shark.r][shark.c]);\n\t\t\t\t\n\t\t\t\tarrtmp[shark.r][shark.c] = shark.z;\n\t\t\t\t\t\n\t\t\t} <span class=\"hljs-keyword\">else</span> sharkmap.erase(shark.z);\n\t\t\t\n\t\t\n\t\t}\n\t\t\n\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>; j&lt;=R; j++) {\n\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> k=<span class=\"hljs-number\">1</span>; k&lt;=C; k++) {\n\t\t\t\tarr[j][k] = arrtmp[j][k];\n\t\t\t\tarrtmp[j][k] = <span class=\"hljs-number\">0</span>;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d\"</span>, ans);\n\t\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n",
		"updatedAt": "2020-01-28T09:49:35.425Z",
		"id": "2020-01-28-algorithm-14",
		"filename": "algorithm\\2020-01-28-algorithm-14.json"
	},
	{
		"layout": "post-content",
		"title": "백준 - 17142 연구소3(C++)",
		"date": "2020-01-29T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<h2>입력 받기</h2>\n<ul>\n<li>연구소 상태는 N x N 이니깐 int A[N][N] 형태로 입력을 저장해야겠다.</li>\n<li>입력을 받을 때, 선택 가능한 바이러스들(값이 2인)의 row, col 값을 따로 저장할 필요가 있겠네. pair&lt;int, int&gt; V[10] 형태로 저장해야겠다. 바이러스 개수는 최대 10이니깐 배열의 크기는 10으로 하자.</li>\n<li>퍼트릴 수 있는 빈 칸의 개수도 카운트 해놓자. 그래야 모든 빈칸에 바이러스를 퍼트렸는 지 알 수 있으니깐.</li>\n<li>아! 퍼트린 후 연구소 상태를 원상 복귀해야하니깐 int TMP[N][N] 형태의 2차원 배열을 만들어놔야지.</li>\n</ul>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;queue&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;limits&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-keyword\">int</span> A[<span class=\"hljs-number\">50</span>][<span class=\"hljs-number\">50</span>]; <span class=\"hljs-comment\">// 연구소</span>\n  <span class=\"hljs-keyword\">int</span> TMP[<span class=\"hljs-number\">50</span>][<span class=\"hljs-number\">50</span>]; <span class=\"hljs-comment\">// 연구소 결과 처리용</span>\n  <span class=\"hljs-keyword\">int</span> N, M; <span class=\"hljs-comment\">// N: 연구소 크기, M: 활성화할 바이러스 수</span>\n  <span class=\"hljs-keyword\">int</span> tcnt = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 연구소 빈칸(0)의 개수</span>\n  pair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt; V[<span class=\"hljs-number\">10</span>]; <span class=\"hljs-comment\">// 연구소 선택 가능한 바이러스(2)의 위치</span>\n  <span class=\"hljs-keyword\">int</span> vcnt = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// V 배열을 위한 인덱스</span>\n  <span class=\"hljs-keyword\">int</span> prow[<span class=\"hljs-number\">4</span>] = {<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>}; <span class=\"hljs-comment\">// 상하좌우 확산 시 사용 row</span>\n  <span class=\"hljs-keyword\">int</span> pcol[<span class=\"hljs-number\">4</span>] = {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>}; <span class=\"hljs-comment\">// 상하좌우 확산 시 사용 col</span>\n    \n  <span class=\"hljs-comment\">// 입력받기</span>\n  <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d %d\"</span>, &amp;N, &amp;M);\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;N; i++) {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>; j&lt;N; j++) {\n      <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d\"</span>, &amp;A[i][j]);\n      TMP[i][j] = A[i][j];\n      <span class=\"hljs-keyword\">if</span> (A[i][j] == <span class=\"hljs-number\">2</span>) V[vcnt++] = make_pair(i, j);\n      <span class=\"hljs-keyword\">if</span> (A[i][j] == <span class=\"hljs-number\">0</span>) tcnt++;\n    }\n  }\n}\n</code></pre>\n<h2>활성화할 바이러스 선택하기</h2>\n<ul>\n<li>DFS로 할 수도 있지만 비트 마스크로 풀어봐야지</li>\n<li>만약 5개의 바이러스 중 3개를 선택해야한다면 범위는 00111 ~ 11100 이다.</li>\n<li>근데 사실, DFS로 하는 게 코드가 간단해서… DFS가 나을 듯, 비트 마스크로 풀다가 실수를 너무 많이 했다.</li>\n</ul>\n<pre><code class=\"language-cpp\">  <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> flag = (<span class=\"hljs-number\">1</span> &lt;&lt; M) - <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 시작 플래그, unsigned int는 양수 범위를 가짐</span>\n  <span class=\"hljs-keyword\">int</span> tcc = M;\n  <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> fin = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 종료 플래그</span>\n  <span class=\"hljs-comment\">// 종료 플래그 만들기.</span>\n  <span class=\"hljs-keyword\">while</span> (tcc-- &gt; <span class=\"hljs-number\">0</span>) {\n    fin |= (<span class=\"hljs-number\">1</span> &lt;&lt;  (vcnt - <span class=\"hljs-number\">1</span> - tcc));\n  }\n  <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> curflag = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 조작용</span>\n  <span class=\"hljs-keyword\">int</span> fcnt = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">int</span> pos = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-built_in\">queue</span>&lt;pair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt; &gt; q;\n  <span class=\"hljs-comment\">// 시작플래그 ~ 종료플래그</span>\n  <span class=\"hljs-keyword\">for</span> (flag; flag&lt;=fin; flag++) {\t\n    curflag = flag;\n    fcnt = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-comment\">// 1비트 개수 세기, M개 일때만 코드 진행</span>\n    <span class=\"hljs-keyword\">while</span> (curflag &gt; <span class=\"hljs-number\">0</span>) {\n      <span class=\"hljs-keyword\">if</span> (curflag &amp; <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span>) fcnt++;\n      <span class=\"hljs-keyword\">if</span> (fcnt &gt; M) <span class=\"hljs-keyword\">break</span>;\n      curflag = curflag &gt;&gt; <span class=\"hljs-number\">1</span>;\n    }\n    <span class=\"hljs-keyword\">if</span> (fcnt != M) <span class=\"hljs-keyword\">continue</span>;\n\t\t<span class=\"hljs-comment\">// 이제 고른 바이러스 표시하기</span>\n    curflag = flag;\n    pos = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">while</span> (curflag &gt; <span class=\"hljs-number\">0</span>) {\n      <span class=\"hljs-keyword\">if</span> (curflag &amp; <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span>) {\n        TMP[V[pos].first][V[pos].second] = <span class=\"hljs-number\">-1</span>; <span class=\"hljs-comment\">// 바이러스 복제</span>\n        <span class=\"hljs-comment\">// 큐에 선택한 바이러스 넣기 -&gt; 퍼트리기에서 BFS로 사용할 예정</span>\n        q.push(make_pair(V[pos].first, V[pos].second));\n      }\n      pos++;\n      curflag = curflag &gt;&gt; <span class=\"hljs-number\">1</span>;\n    }\n    <span class=\"hljs-comment\">// ...바이러스 퍼트리기가 이어진다.</span>\n  }\n</code></pre>\n<h2>바이러스 퍼트리기</h2>\n<ul>\n<li>만약 백준에서 제출 시 100%에서 틀린다면 비활성화 바이러스도 시간 체크했는 지 살펴봐야한다.\n여기서 엄청 헤매서 시간 다 잡아먹었다ㅠㅠ</li>\n<li>쉽게 설명하자면 대부분 BFS로 q가 빌 때까지 반복을 돌릴텐데 만약 이미 빈칸(0)에는 다 전파했는 데 q에 비활성화(선택 못 받은 바이러스)가 있다면? 이 상황을 이해한다면 오류를 잡을 수 있을 거다.</li>\n</ul>\n<blockquote>\n<p>반례가 있어야 이해가 되겠죠?<br>\n5 1<br>\n1 1 1 1 1<br>\n1 1 1 1 1<br>\n1 1 1 1 1<br>\n2 0 0 2 0<br>\n1 1 1 1 1<br>\nanswer : 2</p>\n</blockquote>\n<ul>\n<li>사실 q에 시간 체크용 값도 넣어버려서… 복잡하게 풀어버린 것 같다…</li>\n<li>더 간단히 풀 수 있을 듯…</li>\n</ul>\n<pre><code class=\"language-cpp\">  <span class=\"hljs-comment\">// ..위에는 바이러스 선택하기</span>\n  <span class=\"hljs-comment\">// 시간 체크용, 현재 q에는 선택된 바이러스가 있고 얘는 0초이므로 0을 넣어준다. -1은 구분 용</span>\n  q.push(make_pair(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">0</span>));\n  spread = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 퍼진 바이러스</span>\n  time = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 시간</span>\n  stopflag = <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// 빈칸에 다 퍼트렸으면 true로 바꿀거다.</span>\n  <span class=\"hljs-keyword\">while</span> (!q.empty()) {\n    <span class=\"hljs-comment\">// c++에서 q.pop()은 void 메소드라서 q.front()로 값 가져온다.</span>\n    pair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt; po = q.front(); \n    q.pop();\n    <span class=\"hljs-keyword\">if</span> (po.first &gt;= <span class=\"hljs-number\">0</span>) { <span class=\"hljs-comment\">// 퍼트린 칸이면</span>\n      <span class=\"hljs-keyword\">if</span> (A[po.first][po.second] == <span class=\"hljs-number\">0</span>) spread++; <span class=\"hljs-comment\">// 해당 칸이 원래 빈칸(0)이면 값 증가</span>\n      <span class=\"hljs-keyword\">if</span> (spread == tcnt) stopflag = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// 빈칸에 다 퍼트리면 시간체크용 값 나올 때 스탑하려고</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">4</span>; i++) { <span class=\"hljs-comment\">// 상하좌우 처리</span>\n        nextrow = po.first + prow[i];\n        nextcol = po.second + pcol[i];\n        <span class=\"hljs-keyword\">if</span> (nextrow &lt; <span class=\"hljs-number\">0</span> || nextrow &gt;= N || nextcol &lt; <span class=\"hljs-number\">0</span> || nextcol &gt;= N) <span class=\"hljs-keyword\">continue</span>; <span class=\"hljs-comment\">// 범위 밖</span>\n        <span class=\"hljs-keyword\">if</span> (TMP[nextrow][nextcol] == <span class=\"hljs-number\">-1</span> || TMP[nextrow][nextcol] == <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">continue</span>;\n        q.push(make_pair(nextrow, nextcol)); <span class=\"hljs-comment\">// 큐에 넣자넣자!</span>\n        TMP[nextrow][nextcol] = <span class=\"hljs-number\">-1</span>; <span class=\"hljs-comment\">// 퍼트렸다는(방문했다는) 표시!</span>\n      }\n    } <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-comment\">// 시간체크용</span>\n      time = po.second;\n      <span class=\"hljs-keyword\">if</span> (!q.empty()) q.push(make_pair(<span class=\"hljs-number\">-1</span>, po.second + <span class=\"hljs-number\">1</span>));\n      <span class=\"hljs-keyword\">if</span> (stopflag) <span class=\"hljs-keyword\">break</span>; <span class=\"hljs-comment\">// 이미 모든 빈칸에 퍼트렸으면 나오자!</span>\n    }\n  }\n  <span class=\"hljs-keyword\">while</span> (!q.empty()) <span class=\"hljs-comment\">// 위 반복에서 stopflag에 의해 중간에 빠져나왔을 경우를 대비해서</span>\n  {\n    q.pop();\n  }\n  <span class=\"hljs-comment\">// 시간 넣자!!</span>\n  <span class=\"hljs-keyword\">if</span> (spread == tcnt &amp;&amp; ans &gt; time) ans = time;\n</code></pre>\n<h2>원상복귀</h2>\n<ul>\n<li>TMP는 또 써야하니깐!</li>\n</ul>\n<pre><code class=\"language-cpp\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;N; i++) {\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>; j&lt;N; j++) {\n    TMP[i][j] = A[i][j];\n  }\n}\n</code></pre>\n<h2>전체 코드</h2>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;queue&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;limits&gt;</span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n\n<span class=\"hljs-keyword\">int</span> A[<span class=\"hljs-number\">50</span>][<span class=\"hljs-number\">50</span>];\n<span class=\"hljs-keyword\">int</span> TMP[<span class=\"hljs-number\">50</span>][<span class=\"hljs-number\">50</span>];\n<span class=\"hljs-keyword\">int</span> N, M;\n<span class=\"hljs-keyword\">int</span> vcnt = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-keyword\">int</span> tcnt = <span class=\"hljs-number\">0</span>;\npair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt; V[<span class=\"hljs-number\">10</span>];\n<span class=\"hljs-keyword\">int</span> prow[<span class=\"hljs-number\">4</span>] = {<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>};\n<span class=\"hljs-keyword\">int</span> pcol[<span class=\"hljs-number\">4</span>] = {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-comment\">// 입력받기</span>\n  <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d %d\"</span>, &amp;N, &amp;M);\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;N; i++) {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>; j&lt;N; j++) {\n      <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d\"</span>, &amp;A[i][j]);\n      TMP[i][j] = A[i][j];\n      <span class=\"hljs-keyword\">if</span> (A[i][j] == <span class=\"hljs-number\">2</span>) V[vcnt++] = make_pair(i, j);\n      <span class=\"hljs-keyword\">if</span> (A[i][j] == <span class=\"hljs-number\">0</span>) tcnt++;\n    }\n  }\n  <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> flag = (<span class=\"hljs-number\">1</span> &lt;&lt; M) - <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 시작 플래그, unsigned int는 양수 범위를 가짐</span>\n  <span class=\"hljs-keyword\">int</span> tcc = M;\n  <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> fin = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 종료 플래그</span>\n  <span class=\"hljs-comment\">// 종료 플래그 만들기.</span>\n  <span class=\"hljs-keyword\">while</span> (tcc-- &gt; <span class=\"hljs-number\">0</span>) {\n    fin |= (<span class=\"hljs-number\">1</span> &lt;&lt;  (vcnt - <span class=\"hljs-number\">1</span> - tcc));\n  }\n  <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> curflag = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 조작용</span>\n  <span class=\"hljs-keyword\">int</span> fcnt = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">int</span> pos = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">int</span> nextrow = <span class=\"hljs-number\">0</span>, nextcol = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-built_in\">queue</span>&lt;pair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt; &gt; q;\n  <span class=\"hljs-keyword\">int</span> spread = <span class=\"hljs-number\">0</span>, time = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">int</span> ans = numeric_limits&lt;<span class=\"hljs-keyword\">int</span>&gt;::max();\n  <span class=\"hljs-keyword\">bool</span> stopflag = <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-comment\">// 시작플래그 ~ 종료플래그</span>\n  <span class=\"hljs-keyword\">for</span> (flag; flag&lt;=fin; flag++) {\t\n    curflag = flag;\n    fcnt = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-comment\">// 1비트 개수 세기, M개 일때만 코드 진행</span>\n    <span class=\"hljs-keyword\">while</span> (curflag &gt; <span class=\"hljs-number\">0</span>) {\n      <span class=\"hljs-keyword\">if</span> (curflag &amp; <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span>) fcnt++;\n      <span class=\"hljs-keyword\">if</span> (fcnt &gt; M) <span class=\"hljs-keyword\">break</span>;\n      curflag = curflag &gt;&gt; <span class=\"hljs-number\">1</span>;\n    }\n    <span class=\"hljs-keyword\">if</span> (fcnt != M) <span class=\"hljs-keyword\">continue</span>;\n\t\t<span class=\"hljs-comment\">// 이제 고른 바이러스 표시하기</span>\n    curflag = flag;\n    pos = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">while</span> (curflag &gt; <span class=\"hljs-number\">0</span>) {\n      <span class=\"hljs-keyword\">if</span> (curflag &amp; <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span>) {\n        TMP[V[pos].first][V[pos].second] = <span class=\"hljs-number\">-1</span>; <span class=\"hljs-comment\">// 바이러스 복제</span>\n        <span class=\"hljs-comment\">// 큐에 선택한 바이러스 넣기 -&gt; 퍼트리기에서 BFS로 사용할 예정</span>\n        q.push(make_pair(V[pos].first, V[pos].second));\n      }\n      pos++;\n      curflag = curflag &gt;&gt; <span class=\"hljs-number\">1</span>;\n    }\n    q.push(make_pair(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">0</span>));\n    spread = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 퍼진 바이러스</span>\n    time = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 시간</span>\n    stopflag = <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// 빈칸에 다 퍼트렸으면 true로 바꿀거다.</span>\n    <span class=\"hljs-keyword\">while</span> (!q.empty()) {\n      <span class=\"hljs-comment\">// c++에서 q.pop()은 void 메소드라서 q.front()로 값 가져온다.</span>\n      pair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt; po = q.front(); \n      q.pop();\n      <span class=\"hljs-keyword\">if</span> (po.first &gt;= <span class=\"hljs-number\">0</span>) { <span class=\"hljs-comment\">// 퍼트린 칸이면</span>\n        <span class=\"hljs-keyword\">if</span> (A[po.first][po.second] == <span class=\"hljs-number\">0</span>) spread++; <span class=\"hljs-comment\">// 해당 칸이 원래 빈칸(0)이면 값 증가</span>\n        <span class=\"hljs-keyword\">if</span> (spread == tcnt) stopflag = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// 빈칸에 다 퍼트리면 시간체크용 값 나올 때 스탑하려고</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">4</span>; i++) { <span class=\"hljs-comment\">// 상하좌우 처리</span>\n          nextrow = po.first + prow[i];\n          nextcol = po.second + pcol[i];\n          <span class=\"hljs-keyword\">if</span> (nextrow &lt; <span class=\"hljs-number\">0</span> || nextrow &gt;= N || nextcol &lt; <span class=\"hljs-number\">0</span> || nextcol &gt;= N) <span class=\"hljs-keyword\">continue</span>; <span class=\"hljs-comment\">// 범위 밖</span>\n          <span class=\"hljs-keyword\">if</span> (TMP[nextrow][nextcol] == <span class=\"hljs-number\">-1</span> || TMP[nextrow][nextcol] == <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">continue</span>;\n          q.push(make_pair(nextrow, nextcol)); <span class=\"hljs-comment\">// 큐에 넣자넣자!</span>\n          TMP[nextrow][nextcol] = <span class=\"hljs-number\">-1</span>; <span class=\"hljs-comment\">// 퍼트렸다는(방문했다는) 표시!</span>\n        }\n      } <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-comment\">// 시간체크용</span>\n        time = po.second;\n        <span class=\"hljs-keyword\">if</span> (!q.empty()) q.push(make_pair(<span class=\"hljs-number\">-1</span>, po.second + <span class=\"hljs-number\">1</span>));\n        <span class=\"hljs-keyword\">if</span> (stopflag) <span class=\"hljs-keyword\">break</span>; <span class=\"hljs-comment\">// 이미 모든 빈칸에 퍼트렸으면 나오자!</span>\n      }\n    }\n    <span class=\"hljs-keyword\">while</span> (!q.empty()) <span class=\"hljs-comment\">// 위 반복에서 stopflag에 의해 중간에 빠져나왔을 경우를 대비해서</span>\n    {\n      q.pop();\n    }\n    <span class=\"hljs-comment\">// 시간 넣자!!</span>\n    <span class=\"hljs-keyword\">if</span> (spread == tcnt &amp;&amp; ans &gt; time) ans = time;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;N; i++) {\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>; j&lt;N; j++) {\n        TMP[i][j] = A[i][j];\n      }\n    }\n  }\n  <span class=\"hljs-keyword\">if</span> (ans == numeric_limits&lt;<span class=\"hljs-keyword\">int</span>&gt;::max()) ans = <span class=\"hljs-number\">-1</span>;\n  <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d\"</span>, ans);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n",
		"updatedAt": "2020-01-29T08:19:21.899Z",
		"id": "2020-01-29-algorithm-15",
		"filename": "algorithm\\2020-01-29-algorithm-15.json"
	},
	{
		"layout": "post-content",
		"title": "백준 - 17837 새로운 게임2(C++)",
		"date": "2020-01-30T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<h2>생각의 흐름</h2>\n<ul>\n<li>자료구조는 뭘 사용해야하지?</li>\n<li>체스는 구조체로 정의해서 배열로 저장해야겠고… 보드판 각 칸마다 어떤 체스가 순서대로 있는 지를 표현해야하는 데… 어떤 걸 사용할까?</li>\n<li>앞, 뒤로 pop, push 하고 싶으니깐 deque를 사용해보자…!</li>\n</ul>\n<blockquote>\n<p>다 푼 후,… <br/>\n근데… 다른 사람들 코드를 보니깐 vector를 사용했던 데 나중에 살펴봐야겠다…</p>\n</blockquote>\n<ul>\n<li>구조체 배열을 받을 때는 &amp;를 사용한 참조변수를 사용하자! 그래야 수정도 가능하니깐!</li>\n<li>A말이 위치한 체스칸의 큐에서 뒤부터 하나씩 빼야겠다. 단, A가 나올 때까지만!</li>\n<li>그 다음 뺀 거를 가지고 A말이 이동할 체스칸에 push_back을 해줘야겠지…?</li>\n<li>빨간색은 반대로 넣어줘야하니깐 pop_front, pop_back을 적절히 활용해봐야겠다…</li>\n</ul>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;deque&gt;</span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Horse</span> {</span>\n <span class=\"hljs-keyword\">int</span> row, col, dir;\n};\n\n<span class=\"hljs-keyword\">int</span> N, K;\n<span class=\"hljs-keyword\">int</span> prow[<span class=\"hljs-number\">4</span>] = {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>}; <span class=\"hljs-comment\">//우,좌,상,하</span>\n<span class=\"hljs-keyword\">int</span> pcol[<span class=\"hljs-number\">4</span>] = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>};\n\nHorse horse[<span class=\"hljs-number\">10</span>];\n<span class=\"hljs-keyword\">int</span> color[<span class=\"hljs-number\">12</span>][<span class=\"hljs-number\">12</span>];\n<span class=\"hljs-built_in\">deque</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; board[<span class=\"hljs-number\">12</span>][<span class=\"hljs-number\">12</span>];\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">input</span><span class=\"hljs-params\">()</span> </span>{\n <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d %d\"</span>, &amp;N, &amp;K);\n \n <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;N; i++) {\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>; j&lt;N; j++) {\n   <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d\"</span>, &amp;color[i][j]);\n  }\n }\n \n <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;K; i++) {\n  <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d %d %d\"</span>, &amp;horse[i].row, &amp;horse[i].col, &amp;horse[i].dir);\n  horse[i].row--, horse[i].col--, horse[i].dir--;\n  board[horse[i].row][horse[i].col].push_back(i);\n } \n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">move</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> k)</span> </span>{\n Horse &amp;h = horse[k];\n <span class=\"hljs-keyword\">int</span> nextrow = h.row + prow[h.dir];\n <span class=\"hljs-keyword\">int</span> nextcol = h.col + pcol[h.dir];\n \n <span class=\"hljs-comment\">// 범위 밖 or 파란색</span>\n <span class=\"hljs-keyword\">if</span> ((nextrow &lt; <span class=\"hljs-number\">0</span> || nextcol &lt; <span class=\"hljs-number\">0</span> || nextrow &gt;= N || nextcol &gt;= N) || color[nextrow][nextcol] == <span class=\"hljs-number\">2</span>) {\n  <span class=\"hljs-comment\">// 방향 반대로</span>\n  <span class=\"hljs-keyword\">switch</span>(h.dir) {\n   <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">0</span>:\n    h.dir = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">break</span>;\n   <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:\n    h.dir = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">break</span>;\n   <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>:\n    h.dir = <span class=\"hljs-number\">3</span>;\n    <span class=\"hljs-keyword\">break</span>;\n   <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">3</span>:\n    h.dir = <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-keyword\">break</span>;\n   <span class=\"hljs-keyword\">default</span>: <span class=\"hljs-keyword\">break</span>;\n  }\n  nextrow = h.row + prow[h.dir];\n  nextcol = h.col + pcol[h.dir];\n  \n  <span class=\"hljs-keyword\">if</span> ((nextrow &lt; <span class=\"hljs-number\">0</span> || nextcol &lt; <span class=\"hljs-number\">0</span> || nextrow &gt;= N || nextcol &gt;= N) || color[nextrow][nextcol] == <span class=\"hljs-number\">2</span>) \n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n }\n \n <span class=\"hljs-built_in\">deque</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; &amp;q = board[h.row][h.col];\n <span class=\"hljs-built_in\">deque</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; tmpq;\n <span class=\"hljs-keyword\">int</span> tmpk;\n <span class=\"hljs-keyword\">while</span> (!q.empty()) {\n  tmpk = q.back();\n  <span class=\"hljs-comment\">// k말 좌표 이동</span>\n  horse[tmpk].row = nextrow;\n  horse[tmpk].col = nextcol;\n  \n  <span class=\"hljs-comment\">// 원래 큐에서 이동할 말들 빼기</span>\n  tmpq.push_front(tmpk);\n  q.pop_back();\n  \n  <span class=\"hljs-keyword\">if</span> (tmpk == k) <span class=\"hljs-keyword\">break</span>;\n }\n <span class=\"hljs-built_in\">deque</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; &amp;nextq = board[nextrow][nextcol];\n <span class=\"hljs-comment\">// 다음 이동칸이 흰색</span>\n <span class=\"hljs-keyword\">if</span> (color[nextrow][nextcol] == <span class=\"hljs-number\">0</span>) {\n  <span class=\"hljs-keyword\">while</span> (!tmpq.empty()) {\n   nextq.push_back(tmpq.front());\n   tmpq.pop_front();\n  }\n } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (color[nextrow][nextcol] == <span class=\"hljs-number\">1</span>) { <span class=\"hljs-comment\">// 빨간(순서 반대로)</span>\n  <span class=\"hljs-keyword\">while</span> (!tmpq.empty()) {\n   nextq.push_back(tmpq.back());\n   tmpq.pop_back();\n  }\n }\n <span class=\"hljs-keyword\">if</span> (nextq.size() &gt;= <span class=\"hljs-number\">4</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n <span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n <span class=\"hljs-keyword\">int</span> i;\n input();\n <span class=\"hljs-keyword\">while</span> (ans++ &lt; <span class=\"hljs-number\">1000</span>) {\n  <span class=\"hljs-keyword\">for</span> (i=<span class=\"hljs-number\">0</span>; i&lt;K; i++) {\n   <span class=\"hljs-keyword\">if</span> (move(i)) <span class=\"hljs-keyword\">break</span>;\n  }\n  <span class=\"hljs-keyword\">if</span> (i &lt; K) <span class=\"hljs-keyword\">break</span>;\n }\n \n <span class=\"hljs-keyword\">if</span> (ans &gt; <span class=\"hljs-number\">1000</span>) ans = <span class=\"hljs-number\">-1</span>;\n <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d\"</span>, ans);\n <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n",
		"updatedAt": "2020-01-30T11:00:37.944Z",
		"id": "2020-01-30-algorithm-16",
		"filename": "algorithm\\2020-01-30-algorithm-16.json"
	},
	{
		"layout": "post-content",
		"title": "백준 - 17779 게리멘더링2(C++)",
		"date": "2020-01-31T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<h2>생각의 흐름</h2>\n<ul>\n<li>x, y, d1, d2를 정해야되서 4중 포문을 써야지… 시간 초과가 나려나… 일단 해본 후에 최적화하자 --&gt; 시간 초과 발생하지 않음</li>\n</ul>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cstring&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;algorithm&gt;</span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-keyword\">int</span> N;\n<span class=\"hljs-keyword\">int</span> total = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-keyword\">int</span> A[<span class=\"hljs-number\">21</span>][<span class=\"hljs-number\">21</span>]; <span class=\"hljs-comment\">// 인풋용</span>\n<span class=\"hljs-keyword\">int</span> C[<span class=\"hljs-number\">21</span>][<span class=\"hljs-number\">21</span>]; <span class=\"hljs-comment\">// 각 구역 표시 용도</span>\n<span class=\"hljs-keyword\">int</span> S[<span class=\"hljs-number\">6</span>] ={<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>}; <span class=\"hljs-comment\">// 1~5 구역 인구수 합 표시</span>\n<span class=\"hljs-keyword\">int</span> prow[<span class=\"hljs-number\">4</span>] = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>};\n<span class=\"hljs-keyword\">int</span> pcol[<span class=\"hljs-number\">4</span>]= {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>};\n<span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">40001</span>;\n\n<span class=\"hljs-comment\">// 구역 그리기</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> sx, <span class=\"hljs-keyword\">int</span> sy, <span class=\"hljs-keyword\">int</span> ex, <span class=\"hljs-keyword\">int</span> ey, <span class=\"hljs-keyword\">int</span> area)</span> </span>{\n <span class=\"hljs-comment\">// 좌표가 범위 밖인 경우</span>\n <span class=\"hljs-keyword\">if</span> (sx &lt; <span class=\"hljs-number\">1</span> || sy &lt; <span class=\"hljs-number\">1</span> || sx &gt; ex || sy &gt; ey) <span class=\"hljs-keyword\">return</span>;\n <span class=\"hljs-keyword\">if</span> (C[sx][sy] &gt; <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span>; <span class=\"hljs-comment\">// 이미 다른 구역인 경우</span>\n S[area] += A[sx][sy]; <span class=\"hljs-comment\">// 인구 수 더하기</span>\n C[sx][sy] = area; <span class=\"hljs-comment\">// 구역 방문했다는 표시</span>\n <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">4</span>; i++) { <span class=\"hljs-comment\">// 상하좌우</span>\n  dfs(sx + prow[i], sy + pcol[i], ex, ey, area); \n }\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dividearea</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y, <span class=\"hljs-keyword\">int</span> d1, <span class=\"hljs-keyword\">int</span> d2)</span> </span>{\n <span class=\"hljs-keyword\">int</span> tx, ty;\n <span class=\"hljs-built_in\">memset</span>(C, <span class=\"hljs-number\">0</span>, <span class=\"hljs-keyword\">sizeof</span>(C));\n <span class=\"hljs-built_in\">memset</span>(S, <span class=\"hljs-number\">0</span>, <span class=\"hljs-keyword\">sizeof</span>(S));\n  \n <span class=\"hljs-comment\">/* 경계선 그리기 */</span>\n <span class=\"hljs-comment\">// 경계선 1, 4번 조건</span>\n <span class=\"hljs-keyword\">for</span> (tx=x, ty=y; tx&lt;=x+d1 &amp;&amp; ty&gt;=y-d1; tx++, ty--) {\n  C[tx][ty] = <span class=\"hljs-number\">5</span>, C[tx+d2][ty+d2] = <span class=\"hljs-number\">5</span>;\n  S[<span class=\"hljs-number\">5</span>] += A[tx][ty] + A[tx+d2][ty+d2];\n }\n <span class=\"hljs-comment\">// 경계선 2, 3번 조건</span>\n <span class=\"hljs-keyword\">for</span> (tx=x, ty=y; tx&lt;=x+d2 &amp;&amp; ty&lt;=y+d2; tx++, ty++) {\n  C[tx][ty] = <span class=\"hljs-number\">5</span>, C[tx+d1][ty-d1] = <span class=\"hljs-number\">5</span>;\n  S[<span class=\"hljs-number\">5</span>] += A[tx][ty] + A[tx+d1][ty-d1];\n }\n\n <span class=\"hljs-comment\">// 각 구역 인구수 세기</span>\n <span class=\"hljs-comment\">// 문제에서 주어진 조건대로 시작 좌표와 종료 좌표 입력</span>\n dfs(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, x+d1<span class=\"hljs-number\">-1</span>, y, <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 1번 구역</span>\n dfs(<span class=\"hljs-number\">1</span>, y+<span class=\"hljs-number\">1</span>, x+d2, N, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 2번 구역</span>\n dfs(N, <span class=\"hljs-number\">1</span>, N, y-d1+d2<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// 3번 구역</span>\n dfs(N, N, N, N, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 4번 구역</span>\n \n <span class=\"hljs-comment\">// 경계선 내부 인구수 계산</span>\n <span class=\"hljs-comment\">// 위 dfs로 인해 S[]에 인구수 합이 있으므로 얘를 이용하면 경계선 내부 인구 수 알 수 있다.</span>\n <span class=\"hljs-keyword\">int</span> inside= total;\n <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>; i&lt;=<span class=\"hljs-number\">5</span>; i++) {\n  inside -= S[i];\n }\n S[<span class=\"hljs-number\">5</span>] += inside;\n\n <span class=\"hljs-comment\">// 최댓값, 최솟값, 정답 구하기</span>\n <span class=\"hljs-keyword\">int</span> largest = <span class=\"hljs-number\">0</span>, smallest = <span class=\"hljs-number\">40001</span>;\n <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>; i&lt;=<span class=\"hljs-number\">5</span>; i++) {\n  largest = max(largest, S[i]);\n   smallest = min(smallest, S[i]);\n }\n ans = min(ans, largest - smallest);\n  \n}\n\n<span class=\"hljs-comment\">// x, y, d1, d2 구하기 == 경계썬 구하기</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">selectval</span><span class=\"hljs-params\">()</span> </span>{\n <span class=\"hljs-keyword\">int</span> x, y, d1, d2;\n <span class=\"hljs-keyword\">for</span> (x=<span class=\"hljs-number\">1</span>; x&lt;=N; x++) {\n  <span class=\"hljs-keyword\">for</span> (y=<span class=\"hljs-number\">1</span>; y&lt;=N; y++) {\n   <span class=\"hljs-keyword\">for</span> (d1=<span class=\"hljs-number\">1</span>; d1&lt;N; d1++) {\n    <span class=\"hljs-keyword\">for</span> (d2=<span class=\"hljs-number\">1</span>; d2&lt;N; d2++) {\n     <span class=\"hljs-keyword\">if</span> (x + d1 + d2 &lt;= N &amp;&amp; <span class=\"hljs-number\">1</span> &lt;= y - d1 &amp;&amp; y + d2 &lt;= N) {\n      dividearea(x, y, d1, d2);\n     } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">break</span>;\n    }\n   }\n  }\n }\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d\"</span>, &amp;N);\n <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>; i&lt;=N; i++) {\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>; j&lt;=N; j++) {\n   <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d\"</span>, &amp;A[i][j]);\n   total += A[i][j]; <span class=\"hljs-comment\">// 나중에 경계선 내부 인구 수 계산할 때 쓰려고 전체 인구수를 저장해놓음</span>\n  }\n }\n selectval();\n <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d\"</span>, ans);\n <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n\n</code></pre>\n",
		"updatedAt": "2020-01-31T06:03:57.867Z",
		"id": "2020-01-31-algorithm-17",
		"filename": "algorithm\\2020-01-31-algorithm-17.json"
	},
	{
		"layout": "post-content",
		"title": "알고리즘 개념 잡자 6탄 - 그래프",
		"date": "2020-02-01T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<blockquote>\n<p>참고서적</p>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/69750539\">C언어로 쉽게 풀어쓴 자료구조</a></li>\n</ul>\n</blockquote>\n<br/>\n<h1>1. 그래프(graph)란</h1>\n<ul>\n<li>연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조다.</li>\n<li>정점(vertex)과 간선(edge)들의 집합으로 구성된다 =&gt; G = (V, E)</li>\n<li>정점 == 객체 == 노드, 간선 == 관계 == 노드</li>\n<li>그래프로 표현할 수 있는 것들) 도로, 영역 간 인접 관계, 선수 과목</li>\n<li>간선의 종류에 따라 무방향 그래프와 방향 그래프로 구분된다.</li>\n</ul>\n<blockquote>\n<p><strong>오일러 경로</strong></p>\n<ul>\n<li>모든 간선을 한번만 통과하면서 처음 정점으로 되돌아오는 경로다.</li>\n<li>그래프의 모든 정점에 연결된 간선의 개수가 짝수일 때만 오일러 경로가 존재한다.</li>\n</ul>\n</blockquote>\n<h1>2. 그래프 용어정리</h1>\n<ul>\n<li>가중치 그래프(네트워크) : 간선에 비용이나 가중치가 할당된 그래프</li>\n<li>차수(degree) : 정점이 가지고 있는 인접 링크의 수</li>\n<li>인접 정점(adjacent vertex) : 간선에 의해 직접 연결된 정점\n<ul>\n<li>무방향 그래프에서 정점의 차수(degree)는 인접 정점의 수다.</li>\n<li>무방향 그래프에 존재하는 정점의 모든 차수를 합하면 그래프의 간선 수의 2배가 된다.</li>\n</ul>\n</li>\n<li>방향 그래프 : 간선에 방향성이 존재하는 그래프\n<ul>\n<li>집입 차수(in-degree) : 외부에서 오는 간선 수</li>\n<li>진출 차수(out-degree) : 외부로 향하는 간선 수</li>\n<li>정점의 진입 차수와 진출 차수의 합은 방향 그래프의 간선의 수가 된다.</li>\n</ul>\n</li>\n<li>경로 길이(path length) : 경로를 구성하는 데 사용된 간선의 수\n<ul>\n<li>단순 경로(simple path) : 경로 중에서 반복되는 간선이 없는 경우</li>\n<li>사이클(cycle) : 단순 경로의 시작 정점과 종료 정점이 동일한 경우</li>\n</ul>\n</li>\n<li>연결 그래프(connected graph) : 무방향 그래프에 있는 모든 정점에 대해 항상 경로가 존재하면 그래프는 연결되어 있다고 한다.\n<ul>\n<li>그래프의 어느 두 정점을 선택해도 그 사이에 경로가 존재하면 연결 그래프다.</li>\n<li>트리는 그래프의 특수한 형태로 사이클을 가지지 않는 연결 그래프이다.</li>\n</ul>\n</li>\n<li>완전 그래프(complete graph) : 그래프에 속해 있는 모든 정점이 서로 연결되어 있는 그래프\n<ul>\n<li>무방향 완전 그래프의 정점 수가 n이면 하나의 정점은 n-1개의 다른 정점으로 연결되므로 간선의 수는 n x (n-1)/2가 된다.</li>\n</ul>\n</li>\n</ul>\n<h1>3. 그래프의 구현</h1>\n<h2>1) 인접 행렬(adjacency matrix)</h2>\n<p><img src=\"/assets/images/2020-02-23-img/1.png\" alt=\"process tree\"><br/></p>\n<ul>\n<li>2차원 배열로 표현</li>\n<li>n개의 정점을 가지는 그래프를 표현하기 위해서는 n<sup>2</sup>의 메모리 공간이 필요해서 간선이 많이 존재하는 밀집 그래프를 표현하는 경우에 적합하다.</li>\n<li>간선 수가 적은 최소 그래프의 경우에는 메모리의 낭비가 크므로 부적합하다.</li>\n<li>두 정점을 연결하는 간선의 존재 여부를 O(1) 시간 안에 알 수 있다.</li>\n<li>정점의 차수는 인접 행렬의 행이나 열을 조사하면 알 수 있으므로 O(n)의 연산에 알 수 있다.</li>\n<li>정점 i에 대한 차수는 인접 행렬의 i번째 행에 있는 값을 모두 더하면 된다.</li>\n<li>그래프에 존재하는 모든 간선의 수를 알아내려면 인접 행렬 전체를 조사해야하므로 O(n<sup>2</sup>)의 시간이 요구된다.</li>\n</ul>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-keyword\">int</span> n, m; <span class=\"hljs-comment\">// n: 정점개수, m: 간선 개수</span>\n  <span class=\"hljs-keyword\">int</span> v1, v2, d, c; <span class=\"hljs-comment\">// v1: 정점1, v2: 정점2, d: 0(무방향) 1(v1-&gt;v2), c: 간선 가중치 (1이상)</span>\n  <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d %d\"</span>, &amp;n, &amp;m);\n  \n  <span class=\"hljs-keyword\">int</span> graph[n+<span class=\"hljs-number\">1</span>][n+<span class=\"hljs-number\">1</span>] = {<span class=\"hljs-number\">0</span>}; <span class=\"hljs-comment\">// 0으로 초기화</span>\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;m+<span class=\"hljs-number\">1</span>; i++) {\n    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d %d %d %d\"</span>, &amp;v1, &amp;v2, &amp;d, &amp;c);\n    <span class=\"hljs-keyword\">if</span> (d == <span class=\"hljs-number\">0</span>) {\n      graph[v1][v2] = graph[v2][v1] = c;\n    } <span class=\"hljs-keyword\">else</span> {\n      graph[v1][v2] = c;\n    }\n  }\n  \n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n<h2>2) 인접 리스트(adjacency list)</h2>\n<p><img src=\"/assets/images/2020-02-23-img/2.png\" alt=\"process tree\"><br/></p>\n<ul>\n<li>각 정점에 인접한 정점들을 연결리스트로 표현</li>\n<li>각 연결 리스트들은 헤드 포인터를 가지고 있고 이 헤드 포인터들은 하나의 배열로 구성되어 있어 정점의 번호만 알면 이 번호를 배열의 인덱스로 하여 각 정점의 연결리스트에 쉽게 접근할 수 있다.</li>\n<li>정점의 수가 n개고 간선의 수가 e개인 무방향 그래프를 표시하기 위해서는 n개의 연결 리스트가 필요하고 n개의 헤드 포인터와 2e개의 노드가 필요하다.</li>\n<li>간선의 개수가 적은 희소 그래프의 표현에 적합하다.</li>\n<li>간선의 존재 여부나 정점 i의 차수를 알기 위해서는 정점 i의 연결리스트를 탐색해야 하므로 연결리스트에 있는 노드의 수만큼(정점 차수만큼)의 시간이 필요하다.</li>\n<li>n개의 정점, e개의 간선을 가진 그래프의 전체 간선 수를 알아내려면 O(n+e)의 연산이 요구된다.</li>\n</ul>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;vector&gt;</span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-keyword\">int</span> n, m;\n  <span class=\"hljs-keyword\">int</span> v1, v2, d, c;\n  <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d %d\"</span>, &amp;n, &amp;m);\n\n  <span class=\"hljs-built_in\">vector</span>&lt;pair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt; &gt; graph[n+<span class=\"hljs-number\">1</span>];\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;m+<span class=\"hljs-number\">1</span>; i++) {\n    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d %d %d %d\"</span>, &amp;v1, &amp;v2, &amp;d, &amp;c);\n    <span class=\"hljs-keyword\">if</span> (d == <span class=\"hljs-number\">0</span>) { <span class=\"hljs-comment\">// 무방향</span>\n      graph[v1].push_back(make_pair(v2, c));\n      graph[v2].push_back(make_pair(v1, c));\n    } <span class=\"hljs-keyword\">else</span> {\n      graph[v1].push_back(make_pair(v2, c));\n    }\n  }\n}\n</code></pre>\n<h1>4. 그래프 탐색</h1>\n<ul>\n<li>그래프에서 모든 노드를 방문하고 싶다면?\n<ul>\n<li>DFS, BFS 중 아무거나 사용해도 상관없으나 DFS가 좀 더 간단하긴 하다.</li>\n</ul>\n</li>\n<li>두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶다면?\n<ul>\n<li>BFS가 일반적으로 더 낫다.</li>\n<li>DFS는 경로를 찾을 수는 있겠지만 모든 노드를 탐색해야할지도 모르고 최단 경로가 아닐 수도 있다.</li>\n</ul>\n</li>\n</ul>\n<h2>1) 깊이 우선 탐색(DFS)</h2>\n<blockquote>\n<p>미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 가다가 더 이상 갈 수 없게 되면 가장 가까운 갈림길로 돌아와서 다른 방향으로 다시 탐색을 진행하는 방법과 유사하다.</p>\n</blockquote>\n<ul>\n<li>순환 호출이나 명시적 스택을 사용한다.</li>\n<li>전위 순회를 포함한 다른 형태의 트리 순회는 모두 DFS의 한 종류다.</li>\n<li>그래프 탐색의 경우는 어떤 노드를 방문했었는지 여부를 반드시 검사해야한다. 이를 검사하지 않으면 무한 루프에 빠질 위험이 있다.</li>\n<li>정점의 수가 n, 간선의 수가 e인 그래프를 깊이 우선 탐색하는 시간은? (힌트 : 모든 간선을 조사한다.)\n<ul>\n<li>인접리스트 : O(n+e)</li>\n<li>인접행렬 : O(n<sup>2</sup>)</li>\n</ul>\n</li>\n</ul>\n<p><strong>인접 행렬로 표현된 무방향 그래프 DFS</strong></p>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> MAX_V 20; <span class=\"hljs-comment\">// 정점 최대 값</span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-keyword\">int</span> n; <span class=\"hljs-comment\">// 입력받은 정점의 수</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> graph[][MAX_V], <span class=\"hljs-keyword\">int</span> visited[], <span class=\"hljs-keyword\">int</span> v)</span> </span>{  \n  visited[v] = <span class=\"hljs-literal\">true</span>;\n  <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d\"</span>, v);\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;n+<span class=\"hljs-number\">1</span>; i++) {\n    <span class=\"hljs-keyword\">if</span> (graph[v][i] == <span class=\"hljs-number\">1</span> &amp;&amp; !visited[i]) dfs(graph, visited, i);\n  }\n}\n</code></pre>\n<h2>2) 너비 우선 탐색(BFS)</h2>\n<ul>\n<li>큐를 사용한다.</li>\n<li>시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.</li>\n</ul>\n<p><strong>인접 행렬로 표현된 무방향 그래프 BFS</strong></p>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;queue&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> MAX_V 20; <span class=\"hljs-comment\">// 정점 최대 값</span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-keyword\">int</span> n; <span class=\"hljs-comment\">// 입력받은 정점의 수</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> graph[][MAX_V], <span class=\"hljs-keyword\">int</span> visited[], <span class=\"hljs-keyword\">int</span> v)</span> </span>{  \n  visited[v] = <span class=\"hljs-literal\">true</span>;\n  <span class=\"hljs-built_in\">queue</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; q;\n  q.push(v);\n\n  <span class=\"hljs-keyword\">while</span>(!q.empty()) {\n    <span class=\"hljs-keyword\">int</span> top = q.front();\n    q.pop();\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d\"</span>, top);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;n+<span class=\"hljs-number\">1</span>; i++) {\n      <span class=\"hljs-keyword\">if</span> (graph[v][i] == <span class=\"hljs-number\">1</span> &amp;&amp; !visited[i]) {\n        q.push(i);\n        visited[i] = <span class=\"hljs-literal\">true</span>;\n      }\n    }\n  }\n  \n}\n\n</code></pre>\n<h2>3) 양방향 탐색</h2>\n<ul>\n<li>출발지와 도착지 사이에 최단 경로를 찾을 때 사용한다.</li>\n<li>출발지, 도착지 두 노드에서 동시에 너비 우선 탐색을 수행한 뒤, 두 탐색 지점이 충돌하는 경우에 경로를 찾는 방법이다.</li>\n<li>두 탐색 알고리즘이 대략 d/2 단계(s와 t 사이의 중간 지점)에서 충돌하여 각 출발지와 도착지 노드의 방문 노드의 개수는 대략 k<sup>d/2</sup>가 된다. (k : 각 노드의 인접 노드의 개수)</li>\n</ul>\n",
		"updatedAt": "2020-02-23T14:47:05.891Z",
		"id": "2020-02-01-algorithm-18",
		"filename": "algorithm\\2020-02-01-algorithm-18.json"
	},
	{
		"layout": "post-content",
		"title": "알고리즘 개념 잡자 7탄 - 최소 신장 트리 (feat. 백준 1992번 네트워크 연결)",
		"date": "2020-02-02T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<blockquote>\n<p>참고서적</p>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/69750539\">C언어로 쉽게 풀어쓴 자료구조</a><br>\n최소 신장 트리 관련 문제</li>\n<li><a href=\"https://www.acmicpc.net/problem/1922\">백준 1922 네트워크 연결</a></li>\n</ul>\n</blockquote>\n<br/>\n<h3>신장 트리(spanning tree)</h3>\n<ul>\n<li>그래프 내의 모든 정점을 포함하는 트리다.</li>\n<li>트리의 특수한 형태로 모든 정점들이 연결되어 있어야 하고 사이클을 포함해서는 안된다.</li>\n<li>신장 트리는 그래프에 있는 n개의 정점을 정확히 (n-1)개의 간선으로 연결하게 된다.</li>\n<li>DFS나 BFS로 신장 트리를 탐색할 수 있으며, 탐색 도중에 사용된 간선만 모으면 신장 트리를 만들 수 있다.</li>\n<li>하나의 그래프에는 많은 신장 트리가 존재할 수 있다.</li>\n</ul>\n",
		"updatedAt": "2020-02-23T12:43:54.530Z",
		"id": "2020-02-02-algorithm-19",
		"filename": "algorithm\\2020-02-02-algorithm-19.json"
	},
	{
		"layout": "post-content",
		"title": "c++로 알고리즘 풀 때 팁들",
		"date": "2020-01-28T00:00:00.000Z",
		"categories": [
			"algorithm"
		],
		"body": "<h1># 입출력</h1>\n<p>cin, cout은 느려서 scanf, printf를 사용하는 걸 추천한다.</p>\n<pre><code class=\"language-cpp\"><span class=\"hljs-keyword\">int</span> N, M, K;\n<span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d %d %d\"</span>, &amp;N, &amp;M, &amp;K);\n</code></pre>\n<h1># 2차원 배열</h1>\n<p>1 2 3 4 5 <br/>\n2 3 4 5 6 <br/>\n… 방식의 입력을 받고 싶다면?</p>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> MAX 10</span>\n<span class=\"hljs-keyword\">int</span> A[MAX][MAX];\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;N; i++) {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>; j&lt;N; j++) {\n      <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d\"</span>, &amp;A[i][j]);\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n<h2>2차원 deque 입력, 정렬</h2>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> MAX 10</span>\n<span class=\"hljs-built_in\">deque</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; T[MAX][MAX];\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-keyword\">int</span> x, y, age;\n\n  <span class=\"hljs-comment\">// 입력</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;M; i++) {\n    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d %d %d\"</span>, &amp;x, &amp;y, &amp;age);\n    T[--x][--y].push_back(age);\n  }\n\n  <span class=\"hljs-comment\">// 정렬 오름차순</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;N; i++) {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>; j&lt;N; j++) {\n      <span class=\"hljs-keyword\">if</span> (T[i][j].size() &gt; <span class=\"hljs-number\">1</span>)\n        sort(T[i][j].begin(), T[i][j].end());\n\t  \n    }\n  }\n\n  <span class=\"hljs-comment\">// 순회</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;N; i++) {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>; j&lt;N; j++) {\n      <span class=\"hljs-built_in\">deque</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; &amp;tmp = T[i][j]; <span class=\"hljs-comment\">// 참조로 받기(수정하려면)</span>\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> iter=tmp.begin(); iter != tmp.end();) {\n        <span class=\"hljs-keyword\">int</span> &amp;t = *iter;\n        <span class=\"hljs-keyword\">if</span> () <span class=\"hljs-comment\">//삭제X</span>\n          iter++;\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-comment\">//삭제 O</span>\n          iter = tmp.erase(iter); <span class=\"hljs-comment\">//다음 iter 받음</span>\n\t\t  \n      }\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n<h1>포인터와 참조</h1>\n<pre><code class=\"language-cpp\"><span class=\"hljs-comment\">// 새로운게임2 에서..</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Horse</span> {</span>\n  <span class=\"hljs-keyword\">int</span> row, col, dir;\n};\n\n<span class=\"hljs-comment\">// 참조 변수 : 대상을 직접 할당</span>\n<span class=\"hljs-comment\">// 선언과 동시에 초기화해야한다! </span>\n<span class=\"hljs-comment\">// NULL 불가</span>\nHorse &amp;h = horse[<span class=\"hljs-number\">0</span>]; \nh = horse[<span class=\"hljs-number\">1</span>]; <span class=\"hljs-comment\">// 에러!! (대상 변경 불가)</span>\n<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d\"</span>, h.row);\n\n<span class=\"hljs-comment\">// 포인터 변수 : 주소값 할당</span>\nHorse *h = &amp;horse[<span class=\"hljs-number\">0</span>]; \nh = &amp;horse[<span class=\"hljs-number\">1</span>];  <span class=\"hljs-comment\">// 대상 변경 가능!</span>\nHorse *h = <span class=\"hljs-literal\">NULL</span>; <span class=\"hljs-comment\">// NULL 가능</span>\n\n<span class=\"hljs-keyword\">if</span> (h) <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d\"</span>, h-&gt;row);\n<span class=\"hljs-comment\">// 또는</span>\n<span class=\"hljs-keyword\">if</span> (h) <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d\"</span>, (*h).row);\n</code></pre>\n<h1>배열 초기화할 때, memset 함수 쓰자!</h1>\n<ul>\n<li>for문보다 더 빠른 속도가 나올 수 있다.</li>\n<li>특정 범위에 있는 <strong>연속된 메모리</strong>에 값을 지정하고 싶을 때 쓰자!</li>\n<li>cstring 헤더</li>\n</ul>\n<pre><code class=\"language-cpp\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span>* <span class=\"hljs-title\">memset</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span> *ptr, <span class=\"hljs-keyword\">int</span> value, <span class=\"hljs-keyword\">size_t</span> num)</span></span>;\n<span class=\"hljs-comment\">/*\nptr : 메모리 시작 포인터(주소) =&gt; 배열 이름\nvalue: 채울 값 =&gt; 값\nnum: 채우고자 하는 바이트 수(메모리 크기) =&gt; sizeof(배열이름)\n*/</span>\n</code></pre>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cstring&gt;</span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-keyword\">int</span> C[<span class=\"hljs-number\">21</span>][<span class=\"hljs-number\">21</span>];\n  <span class=\"hljs-built_in\">memset</span>(C, <span class=\"hljs-number\">0</span>, <span class=\"hljs-keyword\">sizeof</span>(C)); \n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n<h1>구조체 멤버 내용 복사하고 싶으면? memcpy를 쓰자</h1>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cstring&gt;</span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Horse</span> {</span>\n  <span class=\"hljs-keyword\">int</span> row, col, dir;\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n  Horse h1, h2;\n  h1.row = <span class=\"hljs-number\">1</span>;\n  h1.col = <span class=\"hljs-number\">2</span>;\n  h1.dir = <span class=\"hljs-number\">3</span>\n\n  <span class=\"hljs-built_in\">memcpy</span>(&amp;h2, &amp;h1, <span class=\"hljs-keyword\">sizeof</span>(Horse)); <span class=\"hljs-comment\">// Horse 구조체 크기만큼 h1 내용을 h2에 복사</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n<h2>동적 할당된 경우는?</h2>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cstring&gt;</span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Horse</span> {</span>\n  <span class=\"hljs-keyword\">int</span> row, col, dir;\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n  Horse *h1 = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(Horse));\n  Horse *h2= <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(Horse));\n  h1-&gt;row = <span class=\"hljs-number\">1</span>;\n  h1-&gt;col = <span class=\"hljs-number\">2</span>;\n  h1-&gt;dir = <span class=\"hljs-number\">3</span>\n\n  <span class=\"hljs-built_in\">memcpy</span>(h2, h1, <span class=\"hljs-keyword\">sizeof</span>(Horse)); <span class=\"hljs-comment\">// Horse 구조체 크기만큼 h1 내용을 h2에 복사</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n<h2>또 다른 예</h2>\n<pre><code class=\"language-cpp\">Horse h1;\nHorse *h2= <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(Horse));\n\n<span class=\"hljs-built_in\">memcpy</span>(h2, &amp;h1, <span class=\"hljs-keyword\">sizeof</span>(Horse));    <span class=\"hljs-comment\">// 구조체 변수에서 동적 메모리로 복사</span>\n</code></pre>\n<h1>자료형</h1>\n<p>정수 자료형 int는 4바이트 정보를 기록할 수 있는 자료형으로, signed int(부호가 있는 정수)를 기준으로 기록할 수 있는 양의 정수 범위는 0 ~ 2,147,483,647 (16진수로 7FFFFFFF)이다.</p>\n<h2>int 범위를 벗어나는 경우 자료형은 무엇을 쓸까?</h2>\n<p>8바이트 크기를 가지는 정수 자료형 long long을 쓰는 게 좋다. signed long long을 기준으로 하면 최대 계산할 수 있는 양의 정수 범위는  0 ~ 9,223,372,036,854,775,807(16진수로 7FFFFFFFFFFFFFFF)다.</p>\n<p>long long으로도 불가능하다면 BigInteger를 사용하면 된다.</p>\n<pre><code class=\"language-cpp\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">long</span> ll;\nll large, small;\n\n</code></pre>\n<h1>순열관련 함수</h1>\n<p>prev_permutation</p>\n",
		"updatedAt": "2020-02-07T07:23:13.688Z",
		"id": "algorithm-cpp-tip",
		"filename": "algorithm\\algorithm-cpp-tip.json"
	},
	{
		"title": "알고리즘 개념 잡자 5탄 - 재귀와 동적 프로그래밍",
		"date": "2020-01-09T00:00:00.000Z",
		"tags": [
			"coding-interview",
			"data-structure"
		],
		"category": [
			"algorithm"
		],
		"body": "<blockquote>\n<p>참고 <br/></p>\n<ul>\n<li><a href=\"https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545\">코딩 인터뷰 완전분석</a> 재귀와 동적 프로그래밍</li>\n<li><a href=\"https://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/\">Geeksforgeeks 바로가기</a></li>\n</ul>\n</blockquote>\n<h1>동적 프로그래밍</h1>\n<ul>\n<li>주어진 문제를 부분 문제로 나눠 값을 계산하는 것</li>\n<li>중복되는 계산을 막기 위해 부분 문제의 결과 값을 저장함 - 메모이제이션(Memoization)과 타뷸레이션(Tabulation)</li>\n</ul>\n<h2>메모이제이션(Memoization)과 타뷸레이션(Tabulation)</h2>\n<ul>\n<li>메모이제이션 : 하향식 접근법 (Top Down) - 재귀적\n<ul>\n<li>테이블을 만들고 NIL(예, -1) 값을 넣음</li>\n<li>서브 문제의 결과값을 구할 때, 먼저 테이블 검색</li>\n<li>계산된 값이 있으면 얘를 리턴</li>\n<li>NIL이면 계산 실행하여 계산 결과를 테이블에 저장</li>\n<li>요구가 있을 때 채워지므로 테이블에 데이터가 다 채워지지 않을 수도 있음</li>\n</ul>\n</li>\n<li>타뷸레이션 : 상향식 접근법 (Bottom Up) - 순환적\n<ul>\n<li>테이블의 마지막 요소를 반환하는 구조</li>\n<li>첫번째부터 전체가 채워지는</li>\n</ul>\n</li>\n</ul>\n<h2>DP의 2가지 속성</h2>\n<p>모든 DP 문제는 Overlapping subproblems 속성을 만족하고 대부분의 클래식 DP 문제는 Optimal Substructure 속성을 만족한다.</p>\n<p><strong>1. overlapping subproblems</strong> <br/><br/></p>\n<ul>\n<li>부분 문제들이 공통으로 겹치는 부분이 있는 지?<br/></li>\n</ul>\n<blockquote>\n<p><span class=\"clr-grey\">우리가 메모이제이션이나 타뷸레이션을 사용하는 이유는 부분 문제의 결과값을 저장해놔서 나중에 이를 활용하려고 사용하죠. 근데 겹치는 부분 문제가 없으면?? 이게 필요가 없음.</span></p>\n</blockquote>\n<ul>\n<li>동적 프로그래밍과 분할 정복\n<ul>\n<li>문제를 나누는 방식에 차이가 있음 <br/><br/></li>\n<li>피보나치<br/>\n<img src=\"/assets/images/2020-01-10-img/2.png\" alt=\"피보나치\"></li>\n<li>이진탐색 <br/>\n<img src=\"/assets/images/2020-01-10-img/1.png\" alt=\"이진탐색\"></li>\n</ul>\n</li>\n</ul>\n<br/>\n<p><strong>2. Optimal Substructure</strong> <br/></p>\n<ul>\n<li>문제의 답을 부분 문제의 답에서 구할 수 있는 가?</li>\n<li>최단 경로 vs 최장 경로<br/>\n<ul>\n<li>경로안에 무수히 많은 경로가 있을 때, 중간 정점들이 각각 최단이 된다면 이를 모든 이은 경로 또한 최단이 된다. <br/><br/>\n<img src=\"/assets/images/2020-01-10-img/3.gif\" alt=\"경로\">\n<ul>\n<li>q -&gt; t 최단 : q -&gt; r + r -&gt; t</li>\n<li>q -&gt; t 최장 : q -&gt; s -&gt; t -&gt; r + r -&gt; q -&gt; s -&gt; t</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>문제 푸는 방법</h2>\n<p><strong>1. DP 문제인가?</strong></p>\n<ul>\n<li>DP의 2가지 속성으로 판단하기</li>\n</ul>\n<p><strong>2. 상태 찾기</strong></p>\n<ul>\n<li>서브 문제마다 값이 달라지는 변수 찾기</li>\n<li>각 서브 문제를 구별하는 값</li>\n<li>파라미타들</li>\n<li>적을 수록 좋다.</li>\n<li>DP(상태) = 결과값(예, 최고 이익, 경우의 수…)</li>\n</ul>\n<p><strong>3. 재귀 방법 알아내기 == 상태들의 관계 알아내기</strong> <br/></p>\n<ul>\n<li>state(n) = state(n-1) + state(n-3) + state(n-5)</li>\n</ul>\n<p><strong>4. 메모이제이션과 타뷸레이션 쓰기</strong></p>\n<h1>8.1 트리플 스텝</h1>\n<p>어떤 아이가 n개의 계단을 오른다. 한 번에 1계단 오르기도 하고 2계단이나 3계단을 오르기도 한다. 계단을 오르는 방법이 몇 가지가 있는지 계산하는 메서드를 구현하라.</p>\n<ul>\n<li>Step 1 : DP 문제인지 판별하기\n<ul>\n<li>느낌…</li>\n</ul>\n</li>\n<li>Step 2 : 부분 문제마다 값이 달라지는 변수 찾기\n<ul>\n<li>N : 계단의 개수 =&gt; 매개변수</li>\n<li>DP[N] = N을 만족하는 경우의 수</li>\n</ul>\n</li>\n<li>Step 3 : 재귀 방법을 알아내기\n<ul>\n<li>조정할 수 있는 거, 오를 수 있는 계단 개수져</li>\n<li>upStair(n) = (n - 1) || (n - 2) || (n - 3)</li>\n<li>upStair(n) = (n - 1) + (n - 2) + (n - 3)</li>\n</ul>\n</li>\n<li>Step 4 : 메모이제이션, 타뷸레이션</li>\n</ul>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;vector&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">solution</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n, <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; memo)</span> </span>{\n  <span class=\"hljs-keyword\">if</span> (n &lt; <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">if</span> (n == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">if</span> (memo[n] &gt; <span class=\"hljs-number\">-1</span>) <span class=\"hljs-keyword\">return</span> memo[n];\n  memo[n] = solution(n - <span class=\"hljs-number\">1</span>, memo) + solution (n - <span class=\"hljs-number\">2</span>, memo) + solution (n - <span class=\"hljs-number\">3</span>, memo);\n  <span class=\"hljs-keyword\">return</span> memo[n];\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">solution_BU</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>{\n  <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; dp(n+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>);\n  dp[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;\n  dp[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span>;\n  dp[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">2</span>;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">3</span>; i&lt;=n; i++) {\n    dp[i] = dp[i<span class=\"hljs-number\">-1</span>] + dp[i<span class=\"hljs-number\">-2</span>] + dp[i<span class=\"hljs-number\">-3</span>];\n  }\n  <span class=\"hljs-keyword\">return</span> dp[n];\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>{\n  <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">10</span>;\n  <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; memo(n+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>);\n  <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &lt;&lt; solution(n, memo) &lt;&lt; <span class=\"hljs-string\">\",\"</span>;\n  <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &lt;&lt; solution_BU(n) &lt;&lt; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n<h1>8.11 코인</h1>\n<p>쿼터(25센트), 다임(10센트), 니켈(5센트), 페니(1센트)의 네 가지 동전이 무한히 주어졌을 때, n센트를 표현하는 모든 방법의 수를 계산하는 코드를 작성하라</p>\n<ul>\n<li>\n<p>Step 1 : DP 문제인지 판별하기</p>\n<ul>\n<li>10원 방법의 수는 5원 방법에 + 5를 더하는 것…</li>\n<li>느낌…</li>\n</ul>\n</li>\n<li>\n<p>Step 2 : 부분 문제마다 값이 달라지는 변수 찾기</p>\n<ul>\n<li>부분 문제는 1원일 때 방법의 수… 2원일 때 방법의 수…3원일 때…N원일 때 방법의 수</li>\n<li>N : 구할 센트, =&gt; 매개변수, 상태값</li>\n<li>D[N] = 방법의 수</li>\n</ul>\n</li>\n<li>\n<p>Step 3 : 재귀 방법을 알아내기**</p>\n<ul>\n<li>재귀의 방법을 조정할 수 있는 값은? 동전의 가치 (25, 10, 5, 1)</li>\n<li>D(n) = D(n - 25) + D(n - 10) + D(n - 5) + D(n - 1)</li>\n</ul>\n</li>\n<li>\n<p>Step 4 : 메모이제이션, 타뷸레이션</p>\n</li>\n<li>\n<p>10센트 만들기 (D[0] = 1)</p>\n<ul>\n<li>25센트로 : 0 0 0 0 0 0 0 0 0 0</li>\n<li>10센트로 : 0 0 0 0 0 0 0 0 0 1</li>\n<li>5센트로  : 0 0 0 0 1 0 0 0 0 2</li>\n<li>1센트로  : 1 1 1 1 2 2 2 2 2 4</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;vector&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;string&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-keyword\">int</span> coin[<span class=\"hljs-number\">4</span>] = {<span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">1</span>};\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">solution</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n, <span class=\"hljs-keyword\">int</span> index, <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; &gt;&amp; memo)</span> </span>{\n  <span class=\"hljs-keyword\">if</span> (index &gt;= <span class=\"hljs-number\">3</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">if</span> (memo[n][index] &gt; <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> memo[n][index];\n  <span class=\"hljs-keyword\">int</span> answer = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i * coin[index] &lt;= n; i++) {\n    answer += solution(n - i * coin[index], index + <span class=\"hljs-number\">1</span>, memo);\n  }\n  \n  memo[n][index] = answer;\n  <span class=\"hljs-keyword\">return</span> memo[n][index];\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">solution_BU</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>{\n  <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; dp(n+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);\n  dp[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">4</span>; i++) {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>; j&lt;=n; j++) {\n      <span class=\"hljs-keyword\">if</span> (j - coin[i] &gt;= <span class=\"hljs-number\">0</span>) dp[j] += dp[j-coin[i]]; \n    }\n  }\n  <span class=\"hljs-keyword\">return</span> dp[n];\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">10</span>;\n  <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; &gt; memo(n + <span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>));\n  <span class=\"hljs-keyword\">int</span> answer = solution(n, <span class=\"hljs-number\">0</span>, memo);\n  <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &lt;&lt; answer &lt;&lt; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n  <span class=\"hljs-keyword\">int</span> answer_2 = solution_BU(n);\n  <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &lt;&lt; answer &lt;&lt; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n<h1>8.7 중복 없는 순열</h1>\n<p>문자열이 주어졌을 때 모든 경우의 순열을 계산하는 메서드를 작성하라. 단, 문자는 중복되어 나타날 수 없다.</p>\n<h1>8.9 괄호</h1>\n<p>n-쌍의 괄호로 만들 수 있는 모든 합당한(괄호가 적절히 열리고 닫힌) 조합을 출력하는 알고리즘을 구현하라</p>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;string&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;vector&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fnc</span><span class=\"hljs-params\">(<span class=\"hljs-built_in\">string</span> result, <span class=\"hljs-keyword\">int</span> cur, <span class=\"hljs-keyword\">int</span> dep, <span class=\"hljs-keyword\">int</span> n, <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;&amp; answer)</span> </span>{\n  <span class=\"hljs-keyword\">if</span> (cur &lt; <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span>;\n  <span class=\"hljs-keyword\">if</span> (cur &gt; <span class=\"hljs-number\">0</span> &amp;&amp; n - dep &lt; cur) <span class=\"hljs-keyword\">return</span>;\n  <span class=\"hljs-keyword\">if</span> (cur == <span class=\"hljs-number\">0</span> &amp;&amp; dep == n) {\n    answer.push_back(result);\n    <span class=\"hljs-keyword\">return</span>;\n  }\n  fnc(result + <span class=\"hljs-string\">\"(\"</span>, cur + <span class=\"hljs-number\">1</span>, dep + <span class=\"hljs-number\">1</span>, n, answer);\n  fnc(result + <span class=\"hljs-string\">\")\"</span>, cur - <span class=\"hljs-number\">1</span>, dep + <span class=\"hljs-number\">1</span>, n, answer);\n}\n\n<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-built_in\">string</span>&gt; solution(<span class=\"hljs-keyword\">int</span> n) {    \n    <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-built_in\">string</span>&gt; answer;\n    fnc(<span class=\"hljs-string\">\"\"</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, n*<span class=\"hljs-number\">2</span>, answer); \n    <span class=\"hljs-keyword\">return</span> answer;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">solution_2</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> leftRem, <span class=\"hljs-keyword\">int</span> rightRem, <span class=\"hljs-keyword\">int</span> index, <span class=\"hljs-keyword\">char</span> *str, <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;&amp; answer)</span> </span>{\n  <span class=\"hljs-keyword\">if</span> (leftRem &lt; <span class=\"hljs-number\">0</span> || leftRem &gt; rightRem) <span class=\"hljs-keyword\">return</span>;\n  <span class=\"hljs-keyword\">if</span> (leftRem == <span class=\"hljs-number\">0</span> &amp;&amp; rightRem == <span class=\"hljs-number\">0</span>) {\n    answer.push_back(str);\n    <span class=\"hljs-keyword\">return</span>;\n  }\n  str[index] = <span class=\"hljs-string\">'('</span>;\n  solution_2(leftRem - <span class=\"hljs-number\">1</span>, rightRem, index+<span class=\"hljs-number\">1</span>, str, answer);\n\n  str[index] = <span class=\"hljs-string\">')'</span>;\n  solution_2(leftRem, rightRem - <span class=\"hljs-number\">1</span>, index + <span class=\"hljs-number\">1</span>, str, answer);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-keyword\">int</span> n;\n  <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"input:\"</span>;\n  <span class=\"hljs-built_in\">cin</span> &gt;&gt; n;\n  <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-built_in\">string</span>&gt; answer = solution(n);\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;answer.size(); i++) {\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; answer[i] &lt;&lt; <span class=\"hljs-string\">\" \"</span>;\n  }\n  <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n  <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-built_in\">string</span>&gt; answer2;\n  <span class=\"hljs-keyword\">char</span> str[n*<span class=\"hljs-number\">2</span>];\n  solution_2(n, n, <span class=\"hljs-number\">0</span>, str, answer2);\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;answer2.size(); i++) {\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; answer2[i] &lt;&lt; <span class=\"hljs-string\">\" \"</span>;\n  }\n  \n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n\n</code></pre>\n<h1>8.10 영역 칠하기</h1>\n<p>화면(색이 칠해진 이차원 배열), 화면상의 한 지점, 새로운 색상이 주어졌을 때, 주어진 지점과 색이 같은 주변 영역을 새로운 색상으로 다시 칠하라</p>\n<ul>\n<li>BFS</li>\n</ul>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;string&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;vector&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;queue&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-keyword\">int</span> row[<span class=\"hljs-number\">4</span>] = {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>};\n<span class=\"hljs-keyword\">int</span> col[<span class=\"hljs-number\">4</span>] = {<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">solution</span><span class=\"hljs-params\">(<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; &gt;&amp; screen, pair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt;&amp; point, <span class=\"hljs-keyword\">int</span> newColor)</span> </span>{\n  \n  <span class=\"hljs-built_in\">queue</span>&lt;pair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt; &gt; q;\n  <span class=\"hljs-keyword\">int</span> next_row, next_col;\n  <span class=\"hljs-keyword\">int</span> pre_color = screen[point.first][point.second];\n  q.push(point);  \n  <span class=\"hljs-keyword\">while</span> (!q.empty()) {\n    pair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt; pop = q.front();\n    screen[pop.first][pop.second] = newColor;\n    q.pop();\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">4</span>; i++) {\n      next_row = pop.first + row[i];\n      next_col = pop.second + col[i];\n      <span class=\"hljs-keyword\">if</span> (next_row &lt; <span class=\"hljs-number\">0</span> || next_col &lt; <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">continue</span>;\n      <span class=\"hljs-keyword\">if</span> (next_row &gt;= screen.size() || next_col &gt;= screen[<span class=\"hljs-number\">0</span>].size()) <span class=\"hljs-keyword\">continue</span>;\n      <span class=\"hljs-keyword\">if</span> (screen[next_row][next_col] == pre_color) {\n        q.push(make_pair(next_row, next_col));\n      }\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-comment\">// vector&lt;vector&lt;int&gt; &gt; screen({</span>\n  <span class=\"hljs-comment\">//   vector&lt;int&gt;({1, 1, 2, 3}),</span>\n  <span class=\"hljs-comment\">//   vector&lt;int&gt;({2, 1, 2, 3}),</span>\n  <span class=\"hljs-comment\">//   vector&lt;int&gt;({1, 1, 2, 2}),</span>\n  <span class=\"hljs-comment\">//   vector&lt;int&gt;({2, 2, 2, 1})</span>\n  <span class=\"hljs-comment\">// });</span>\n  <span class=\"hljs-comment\">/*\n  1 2 2 3\n  2 1 2 3\n  1 1 2 2\n  2 2 2 1\n  */</span>\n <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; &gt; screen(<span class=\"hljs-number\">4</span>, <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;(<span class=\"hljs-number\">4</span>));\n  screen[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;\n  screen[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">2</span>;\n  screen[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">2</span>;\n  screen[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">3</span>] = <span class=\"hljs-number\">3</span>;\n\n  screen[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">2</span>;\n  screen[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span>;\n  screen[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">2</span>;\n  screen[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">3</span>] = <span class=\"hljs-number\">3</span>;\n  \n  screen[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;\n  screen[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span>;\n  screen[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">2</span>;\n  screen[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">3</span>] = <span class=\"hljs-number\">2</span>;\n\n  screen[<span class=\"hljs-number\">3</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">2</span>;\n  screen[<span class=\"hljs-number\">3</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">2</span>;\n  screen[<span class=\"hljs-number\">3</span>][<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">2</span>;\n  screen[<span class=\"hljs-number\">3</span>][<span class=\"hljs-number\">3</span>] = <span class=\"hljs-number\">1</span>;\n\n  pair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt; point = make_pair(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;screen.size(); i++) {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>; j&lt;screen[<span class=\"hljs-number\">0</span>].size(); j++)\n      <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &lt;&lt; screen[i][j] &lt;&lt; <span class=\"hljs-string\">\" \"</span>;\n    <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n  }\n  solution(screen, point, <span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;screen.size(); i++) {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>; j&lt;screen[<span class=\"hljs-number\">0</span>].size(); j++)\n      <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &lt;&lt; screen[i][j] &lt;&lt; <span class=\"hljs-string\">\" \"</span>;\n    <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n<h1>8.14 불린값 계산</h1>\n<p>0(false), 1(true), &amp;(AND), |(OR), ^(XOR)으로 구성된 불린 표현식과 원하는 계산 결과(불린값)이 주어졌을 때, 표현식에 괄호를 적절하게 추가하여 그 값이 원하는 결과값과 같게 만들 수 있는 모든 경우의 수 출력하기</p>\n<p>출력 예시</p>\n<ul>\n<li>\n<p>countEval(“1^0|0|1”, false) -&gt; 2개</p>\n</li>\n<li>\n<p>countEval(“0&amp;0&amp;0&amp;1^1|0”, true) -&gt; 10개</p>\n</li>\n<li>\n<p>Step 1 : DP 문제인지 판별하기</p>\n<ul>\n<li>뭔가… 적절하게 조합해서 모든 경우 구하는 거라서… dp같네…?</li>\n</ul>\n</li>\n<li>\n<p>Step 2 : 부분 문제마다 값이 달라지는 변수 찾기</p>\n<ul>\n<li>음… 전체 수식을 쪼개니깐 수식이 부분문제마다 달라지넵, 매개변수로 쪼개진 수식을 보내야겠댜~</li>\n</ul>\n</li>\n<li>\n<p>Step 3 : 재귀 방법을 알아내기**</p>\n<ul>\n<li>괄호를 추가한다라…</li>\n<li>1^0|0|1 예시로 보면…</li>\n<li>1 ^ (0|0|1) 처럼 괄호를 추가하고 싶다는 건데…</li>\n<li>그럼 ^ 같은 표현식을 기준으로 왼쪽 오른쪽 나눠어…</li>\n<li>D[수식] = D[왼쪽 수식] * D[오른쪽 수식]</li>\n<li>서로 연관있으니깐 *곱하기</li>\n<li>표현식은 index 1, 3, 5, 7 …에 위치</li>\n</ul>\n</li>\n<li>\n<p>Step 4 : 메모이제이션, 타뷸레이션</p>\n</li>\n</ul>\n<p>1       ^  0|0|1<br>\n1^0     |    0|1<br>\n1^0|0   |   1</p>\n<pre><code class=\"language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;string&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;vector&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;map&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">fnc</span><span class=\"hljs-params\">(<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">string</span> <span class=\"hljs-built_in\">exp</span>, <span class=\"hljs-keyword\">bool</span> r, <span class=\"hljs-built_in\">map</span>&lt;<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-keyword\">int</span>&gt;&amp; memo)</span> </span>{  \n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">exp</span>.length() == <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">exp</span>[<span class=\"hljs-number\">0</span>] == (r ? <span class=\"hljs-string\">'1'</span> : <span class=\"hljs-string\">'0'</span>) ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">if</span> (memo.count(<span class=\"hljs-built_in\">exp</span> + (r ? <span class=\"hljs-string\">\"-1\"</span> : <span class=\"hljs-string\">\"-0\"</span>)) == <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> memo[<span class=\"hljs-built_in\">exp</span> + (r ? <span class=\"hljs-string\">\"-1\"</span> : <span class=\"hljs-string\">\"-0\"</span>)];\n  <span class=\"hljs-keyword\">int</span> sum = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>; i&lt;<span class=\"hljs-built_in\">exp</span>.length(); i+=<span class=\"hljs-number\">2</span>) {\n    <span class=\"hljs-keyword\">char</span> e = <span class=\"hljs-built_in\">exp</span>[i];\n    <span class=\"hljs-built_in\">string</span> left = <span class=\"hljs-built_in\">exp</span>.substr(<span class=\"hljs-number\">0</span>, i);\n    <span class=\"hljs-built_in\">string</span> right = <span class=\"hljs-built_in\">exp</span>.substr(i+<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-keyword\">if</span> (e == <span class=\"hljs-string\">'^'</span>) {\n      <span class=\"hljs-keyword\">if</span> (r) {  <span class=\"hljs-comment\">// true</span>\n        sum += fnc(left, r, memo) * fnc(right, r^<span class=\"hljs-number\">1</span>, memo);\n        sum += fnc(left, r^<span class=\"hljs-number\">1</span>, memo) * fnc(right, r, memo);\n      } <span class=\"hljs-keyword\">else</span> {\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n        sum += fnc(left, r^<span class=\"hljs-number\">1</span>, memo) * fnc(right, r^<span class=\"hljs-number\">1</span>, memo);\n      }\n     \n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (e == <span class=\"hljs-string\">'|'</span>) {\n      <span class=\"hljs-keyword\">if</span> (r) { <span class=\"hljs-comment\">// true</span>\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n        sum += fnc(left, r, memo) * fnc(right, r^<span class=\"hljs-number\">1</span>, memo);\n        sum += fnc(left, r^<span class=\"hljs-number\">1</span>, memo) * fnc(right, r, memo);\n      } <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-comment\">// false</span>\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n      }      \n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">if</span> (r) { <span class=\"hljs-comment\">// true</span>\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n      } <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-comment\">// false</span>\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n        sum += fnc(left, r^<span class=\"hljs-number\">1</span>, memo) * fnc(right, r, memo);\n        sum += fnc(left, r, memo) * fnc(right, r^<span class=\"hljs-number\">1</span>, memo);\n      }\n      \n    }    \n  }\n  memo.insert(pair&lt;<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-keyword\">int</span>&gt;(<span class=\"hljs-built_in\">exp</span> + (r ? <span class=\"hljs-string\">\"-1\"</span> : <span class=\"hljs-string\">\"-0\"</span>) , sum));\n  <span class=\"hljs-keyword\">return</span> sum;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">countEval</span><span class=\"hljs-params\">(<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">string</span> <span class=\"hljs-built_in\">exp</span>, <span class=\"hljs-keyword\">bool</span> result)</span> </span>{ \n  <span class=\"hljs-built_in\">map</span>&lt;<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-built_in\">map</span>;\n  <span class=\"hljs-keyword\">return</span> fnc(<span class=\"hljs-built_in\">exp</span>, result, <span class=\"hljs-built_in\">map</span>);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &lt;&lt; countEval(<span class=\"hljs-string\">\"1^0|0|1\"</span>, <span class=\"hljs-literal\">false</span>) &lt;&lt; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n  <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &lt;&lt; countEval(<span class=\"hljs-string\">\"0&amp;0&amp;0&amp;1^1|0\"</span>, <span class=\"hljs-literal\">true</span>) &lt;&lt; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n",
		"updatedAt": "2020-02-23T12:42:26.192Z",
		"id": "coding-interview-dp",
		"filename": "algorithm\\coding-interview-dp.json"
	},
	{
		"title": "알고리즘 개념 잡자 2탄 - 트리",
		"date": "2020-01-03T00:00:00.000Z",
		"tags": [
			"coding-interview",
			"data-structure"
		],
		"category": "algorithm",
		"body": "<blockquote>\n<p>참고 서적<br/>\n<a href=\"https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545\">코딩 인터뷰 완전분석</a> 트리와 그래프<br/>\n<a href=\"http://www.yes24.com/Product/Goods/69750539\">C언어로 쉽게 풀어쓴 자료구조</a> 제 7장 트리, 제 8장 우선순위 큐</p>\n</blockquote>\n<h1>1. 트리(Tree)</h1>\n<ul>\n<li>트리는 노드(node)와 간선(edge)로 이루어진 자료구조이다.</li>\n<li>트리는 하나의 루트 노드를 가진다.</li>\n<li>루트 노드는 0개 이상의 자식 노드를 가진다.</li>\n<li>그 자식 노드 또한 0개 이상의 자식 노드를 가진다.</li>\n<li>그 자식의 자식 노드 또한…</li>\n<li>노드들은 특정 순서대로 나열될 수도 있고 없을 수도 있다.</li>\n<li>각 노드는 어떤 자료형으로도 표현이 가능하다.</li>\n<li>각 노드는 부모 노드로의 연결이 있을 수도 있고 없을 수도 있다.</li>\n</ul>\n<h2>용어 정리</h2>\n<ul>\n<li>트리에는 **사이클(cycle)**이 존재할 수 없다.</li>\n<li>자식이 없는 노드는 **말단 노드(leaf node)**라고 부른다.</li>\n<li>**차수(degree)**는 자식 노드의 개수로 자식 노드가 3개면 그 노드의 차수는 3이다. 트리의 차수는 트리가 가지고 있는 노드의 차수 중에서 가장 큰 차수이다.</li>\n<li>**레벨(level)**은 트리의 각 층에 번호를 매긴 것으로 루트의 레벨은 1이 되고 한 층씩 내려갈수록 1씩 증가한다</li>\n<li>트리의 **높이(height)**는 트리가 가진 최대 레벨이다.</li>\n</ul>\n<p>예시) 노드 클래스</p>\n<pre><code class=\"language-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Node</span> </span>{\n  <span class=\"hljs-keyword\">public</span> String name;\n  <span class=\"hljs-keyword\">public</span> Node[] children;\n}\n</code></pre>\n<p>예시) 트리 클래스</p>\n<pre><code class=\"language-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Tree</span> </span>{\n  <span class=\"hljs-keyword\">public</span> Node root;\n}\n</code></pre>\n<h2>이진 트리(Binary tree)와 이진 탐색 트리(Binary search tree)</h2>\n<ul>\n<li>이진트리\n<ul>\n<li>이진 트리의 노드는 최대 2개까지의 자식 노드가 존재할 수 있고 모든 노드의 차수는 2 이하가 된다.</li>\n<li>n개의 노드를 가진 이진 트리는 n-1개의 간선을 가진다. 루트 노드를 제외한 노드들은 부모와 정확히 하나의 간선으로 이어져있기 때문이다.</li>\n<li>높이가 h인 이진 트리는 최소 h개 노드를 가지고 최대 2<sup>h</sup>-1 노드를 가진다.</li>\n<li>레벨 i에서 노드의 개수는 2<sup>i-1</sup> 다.</li>\n<li>n개의 노드를 가진 이진 트리의 최대 높이는 n이며 최소 높이는 log<sub>2</sub>(n+1) 이다.</li>\n</ul>\n</li>\n<li>이진 탐색 트리\n<ul>\n<li>모든 노드 n은 <span class=\"clr-note\">모든 왼쪽 자식들 &lt;= n &lt; 모든 오른쪽 자식들</span> 속성을 만족한다.</li>\n<li>이진 탐색 트리의 탐색, 삽입, 삭제 연산의 시간 복잡도는 트리의 높이를 h라고 했을 때 O(h)가 된다.</li>\n<li>n개의 노드를 가진 균형 잡힌 이진 트리의 높이는 log<sub>2</sub>n 이므로 평균적인 시간 복잡도는 O(log<sub>2</sub>n)</li>\n<li>한쪽으로 치우친 이진 트리의 경우 트리의 높이가 노드의 개수 n과 같게 되어 시간복잡도는 선형 탐색과 같이 O(n)이 된다.</li>\n</ul>\n</li>\n</ul>\n<h2>이진 트리 표현 방법</h2>\n<p><strong>1. 배열 이용</strong> <br/><br/>\n<img src=\"/assets/images/2020-01-03-img/1.png\" alt=\"배열 이용\"><br/></p>\n<ul>\n<li>주로 포화 이진 트리나 완전 이진 트리의 경우에 많이 쓰인다.</li>\n<li>높이가 k인 완전 이진 트리로 가정하여 배열의 크기를 최대 노드 개수인 2<sup>k</sup>-1 로 할당한 다음 완전 이진 트리의 번호대로 노드를 저장한다.</li>\n<li>편한 계산을 위해 인덱스는 1부터 시작한다.</li>\n<li>오른쪽 그림처럼 일반 이진 트리의 경우 공간 낭비가 크다.</li>\n</ul>\n<blockquote>\n<p>부모 &amp; 자식 노드 찾는 법 <br/><br/>\n현재 노드 i를 기준으로, <br/>\n부모 노드의 인덱스 =  <strong>i/2</strong> <br/>\n왼쪽 자식 노드의 인덱스 =  <strong>i*2</strong> <br/>\n오른쪽 자식 노드의 인덱스 = <strong>i*2 + 1</strong> <br/></p>\n</blockquote>\n<br/>\n<p><strong>2. 연결리스트 이용</strong> <br/><br/></p>\n<ul>\n<li>노드가 자바에서는 클래스, C에서는 구조체로 표현되고 각 노드가 포인터를 가지고 있어서 이 포인터를 이용하여 노드와 노드를 연결하는 방법이다.</li>\n<li>하나의 노드가 왼쪽 자식 노드, 오른쪽 자식 노드를 필드로 가진다.</li>\n</ul>\n<h2>트리가 ‘균형’ 트리인지 아닌지 확인하는 방법</h2>\n<p><span class=\"clr-note\">O(log N)</span> 시간에 insert와 find를 할 수 있는 정도로 균형이 잘 잡혀있는 지 확인하면 된다. 꼭 완전 이진 트리처럼 완벽하게 균형 잡혀 있을 필요는 없다.</p>\n<blockquote>\n<p>예) 레드-블랙 트리와 AVL 트리</p>\n</blockquote>\n<h2>이진 트리의 종류</h2>\n<ul>\n<li>완전 이진 트리(complete binary tree) : 트리의 모든 높이에서 노드가 꽉 차 있다. 마지막 단계(level)은 꽉 차 있지 않아도 되지만 노드가 왼쪽에서 오른쪽으로 채워져야 한다.</li>\n<li>전 이진 트리(full binary tree) : 자식노드가 0개 또는 2개인 경우다.</li>\n<li>포화 이진 트리(perfect binary tree) : 전 이진 트리면서 완전 이진 트리인 경우다. 모든 말단 노드는 같은 레벨에 있으며 마지막 레벨에서 노드의 개수가 최대가 되어야 한다. 노드의 개수는 정확히 2<sup>k-1</sup>(k는 트리의 레벨)</li>\n</ul>\n<h2>이진 트리 순회 방법</h2>\n<p>**중위 순회(in-order traversal)**는 <span class=\"clr-note\">왼쪽 가지(branch) - 현재 노드 - 오른쪽 가지</span> 순서로 노드를 방문하고 출력하는 방법이다.</p>\n<blockquote>\n<p>이진 탐색 트리를 이 방법으로 순회한다면? <span class=\"is-has-danger\">오름차순</span>으로 방문!</p>\n</blockquote>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">inOrderTraversal</span><span class=\"hljs-params\">(TreeNode node)</span> </span>{\n  <span class=\"hljs-keyword\">if</span> (node != <span class=\"hljs-keyword\">null</span>) {\n    inOrderTraversal(node.left);\n    visit(node);\n    inOrderTraversal(node.right);\n  }\n}\n</code></pre>\n<br/>\n<p>**전위 순회(pre-order traversal)**는 <span class=\"clr-note\">현재 노드 - 왼쪽 가지(branch) - 오른쪽 가지</span> 순서로 노드를 방문하고 출력하는 방법이다.</p>\n<blockquote>\n<p>가장 먼저 방문할 노드는? 루트 노드!</p>\n</blockquote>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">preOrderTraversal</span><span class=\"hljs-params\">(TreeNode node)</span> </span>{\n  <span class=\"hljs-keyword\">if</span> (node != <span class=\"hljs-keyword\">null</span>) {\n    visit(node);\n    preOrderTraversal(node.left);    \n    preOrderTraversal(node.right);\n  }\n}\n</code></pre>\n<br/>\n<p>**후위 순회(post-order traversal)**는 <span class=\"clr-note\">왼쪽 가지(branch) - 오른쪽 가지 - 현재 노드</span> 순서로 노드를 방문하고 출력하는 방법이다. 예) 현재 디렉토리 용량 계산</p>\n<blockquote>\n<p>맨 마지막에 방문할 노드는? 루트 노드!</p>\n</blockquote>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">postOrderTraversal</span><span class=\"hljs-params\">(TreeNode node)</span> </span>{\n  <span class=\"hljs-keyword\">if</span> (node != <span class=\"hljs-keyword\">null</span>) {    \n    postOrderTraversal(node.left);    \n    postOrderTraversal(node.right);\n    visit(node);\n  }\n}\n</code></pre>\n<br/>\n<p>**레벨 순회(level traversal)**는 각 노드를 레벨 순으로 순회하는 방법이다. 레벨 1에서 시작하며 동일한 레벨의 경우에는 왼쪽에서 오른쪽으로 순으로 방문한다.</p>\n<blockquote>\n<p>중위, 전위, 후위는 스택을 사용하며 레벨 순회는 <strong>큐</strong>를 이용한다.</p>\n</blockquote>\n<h2>이진 트리 순회의 응용</h2>\n<p>**수식 트리(expression tree)**를 처리하는 데 사용\n<br/></p>\n<p><img src=\"/assets/images/2020-01-03-img/2.png\" alt=\"수식 트리 예제\"><br/></p>\n<ul>\n<li>루트 노드는 연산자이고 서브 트리가 피연산자이므로 서브 트리를 계산하면 전체 수식을 계산할 수 있다.</li>\n<li>위 표에 나와있듯이 가장 적합한 순회 방식은 <strong>후위 순회</strong>다.</li>\n</ul>\n",
		"updatedAt": "2020-02-23T12:45:58.772Z",
		"id": "coding-interview-tree-graph-1",
		"filename": "algorithm\\coding-interview-tree-graph-1.json"
	},
	{
		"title": "알고리즘 개념 잡자 3탄 - 이진힙",
		"date": "2020-01-03T00:00:00.000Z",
		"tags": [
			"coding-interview",
			"data-structure"
		],
		"category": "algorithm",
		"body": "<blockquote>\n<p>참고 서적<br/>\n<a href=\"https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545\">코딩 인터뷰 완전분석</a> 트리와 그래프<br/>\n<a href=\"http://www.yes24.com/Product/Goods/69750539\">C언어로 쉽게 풀어쓴 자료구조</a> 제 7장 트리, 제 8장 우선순위 큐</p>\n</blockquote>\n<h1>1. 이진 힙(최소힙과 최대힙)</h1>\n<p>**우선 순위 큐(priority queue)**에서 각 노드들은 우선 순위를 가지고 있고 우선 순위가 높은 노드가 먼저 나가게 된다. 이는 배열, 연결 리스트 등 여러 가지 방법으로 구현이 가능한데, 가장 효율적인 구조는 **히프(heap)**다.</p>\n<h2>우선 순위 큐 구현 방법</h2>\n<p><strong>배열을 이용한 방법</strong></p>\n<ul>\n<li>정렬이 안 된 배열\n<ul>\n<li>삽입 : 맨 끝에 삽입 O(1)</li>\n<li>삭제 : 가장 우선 순위 높은 요소 찾기 O(n) + 삭제 후 뒤에 요소들 앞으로 이동 부담</li>\n</ul>\n</li>\n<li>정렬이 된 배열(우선 순위 낮은 순으로)\n<ul>\n<li>삽입 : 탐색을 통해 삽입 위치를 결정해야 하며, 위치를 찾은 후에는 요소를 이동시켜서 빈 공간을 만들어야 한다. O(n)</li>\n<li>삭제 : 맨 끝 요소 삭제 O(1)</li>\n</ul>\n</li>\n</ul>\n<br/>\n<p><strong>연결리스트를 이용한 방법</strong></p>\n<ul>\n<li>정렬이 안 된 리스트\n<ul>\n<li>삽입 : 첫 번째 노드로 삽입 O(1)</li>\n<li>삭제 : 포인터 따라서 모든 노드를 뒤져보아야 한다. O(n)</li>\n</ul>\n</li>\n<li>정렬이 된 리스트(우선 순위 높은 순으로)\n<ul>\n<li>삽입 : 맨 끝에 삽입해야하므로 O(n)</li>\n<li>삭제 : 맨 앞 노드 삭제 O(1)\n<br/></li>\n</ul>\n</li>\n</ul>\n<p><strong>히프를 이용한 방법</strong></p>\n<ul>\n<li>히프는 완전 이진 트리의 일종으로 우선 순위 큐를 위하여 만들어진 자료 구조이다.</li>\n<li>반 정렬 상태를 유지한다.</li>\n<li>삽입, 삭제 시간복잡도는 **O(log<sub>2</sub>n)**로 상당히 유리</li>\n</ul>\n<h2>히프란?</h2>\n<ul>\n<li>여러 개의 값들 중에서 가장 큰 값이나 가장 작은 값을 빠르게 찾아내도록 만들어진 자료구조다.</li>\n<li><strong>부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은)</strong> 이진 트리다.</li>\n<li>반 정렬 상태로, 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다는 정도다.</li>\n<li>히프 트리는 중복된 값을 허용한다.</li>\n<li>히프는 <span class=\"clr-note\">완전 이진 트리</span>다.</li>\n<li>최대 힙 : 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리</li>\n<li>최소 힙 : 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리</li>\n</ul>\n<h2>히프 구현 방법(최대 힙)</h2>\n<p>히프는 완전 이진 트리이기 때문에 표준적인 자료 구조는 배열이다. 완전 이진 트리 구현 방법은 위 트리의 표현 방법에서 이미 언급했다.</p>\n<p><strong>최대 힙 표현 방법</strong>\n<br/></p>\n<p><img src=\"/assets/images/2020-01-03-img/3.png\" alt=\"히프\"></p>\n<br/>\n<ul>\n<li>\n<p>삽입 연산</p>\n<ul>\n<li>1단계 - 히프의 끝(마지막 노드 다음)에 새로운 노드를 삽입한다. <span class=\"clr-grey\">위 그림에서 키 값이 3인 말단 노드의 형제로 삽입한다.</span></li>\n<li>2단계 - 삽입된 노드와 그 부모 노드의 키 값을 비교한다. 삽입된 노드의 키 값이 부모 노드의 키 값보다 크면 두 노드의 위치를 바꾼다.</li>\n<li>3단계 - 삽입된 노드의 키 값이 자신의 부모 노드 키 값보다 작아질 때까지 단계 2를 반복한다.</li>\n</ul>\n</li>\n<li>\n<p>삭제 연산</p>\n<ul>\n<li>1단계 - 루트 노드가 삭제 된다. 빈자리에는 히프의 마지막 노드를 가져온다.</li>\n<li>2단계 - 새로운 루트 노드를 자식 노드들과 비교해보면서 자식 노드가 더 크면 두 노드의 위치를 바꾼다. 자식 노드 두 개 모두 값이 더 크다면 더 큰 값을 가진 노드와 교환한다.</li>\n<li>3단계 - 노드의 값이 자식보다 클 때까지 2단계를 반복한다.</li>\n</ul>\n</li>\n</ul>\n<p><strong>자바스크립트 구현 코드</strong></p>\n<br/>\n<pre><code class=\"language-javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MaxHeap</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(elements) {\n    <span class=\"hljs-keyword\">this</span>.heap = [,...elements]\n  }\n\n  insert(key) {\n    <span class=\"hljs-keyword\">this</span>.heap.push(key)\n    <span class=\"hljs-keyword\">let</span> current = <span class=\"hljs-keyword\">this</span>.heap.length - <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">let</span> parent = <span class=\"hljs-built_in\">parseInt</span>(current / <span class=\"hljs-number\">2</span>)\n    <span class=\"hljs-keyword\">while</span> (parent &gt;= <span class=\"hljs-number\">1</span>) {\n      <span class=\"hljs-keyword\">if</span> (key &gt; <span class=\"hljs-keyword\">this</span>.heap[parent]) [<span class=\"hljs-keyword\">this</span>.heap[current], <span class=\"hljs-keyword\">this</span>.heap[parent]] = [<span class=\"hljs-keyword\">this</span>.heap[parent], <span class=\"hljs-keyword\">this</span>.heap[current]]\n      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">break</span>\n      current = parent\n      parent = <span class=\"hljs-built_in\">parseInt</span>(current / <span class=\"hljs-number\">2</span>)\n    }\n  }\n\n  <span class=\"hljs-keyword\">delete</span>() {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.heap.length === <span class=\"hljs-number\">1</span>) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"heap is empty\"</span>\n    }\n    [<span class=\"hljs-keyword\">this</span>.heap[<span class=\"hljs-number\">1</span>], <span class=\"hljs-keyword\">this</span>.heap[<span class=\"hljs-keyword\">this</span>.heap.length - <span class=\"hljs-number\">1</span>]] = [<span class=\"hljs-keyword\">this</span>.heap[<span class=\"hljs-keyword\">this</span>.heap.length - <span class=\"hljs-number\">1</span>], <span class=\"hljs-keyword\">this</span>.heap[<span class=\"hljs-number\">1</span>]]\n    <span class=\"hljs-keyword\">let</span> maxValue = <span class=\"hljs-keyword\">this</span>.heap.pop()\n    <span class=\"hljs-keyword\">let</span> current = <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">let</span> leftChild = current * <span class=\"hljs-number\">2</span>\n    <span class=\"hljs-keyword\">while</span> (leftChild &lt; <span class=\"hljs-keyword\">this</span>.heap.length) {\n      <span class=\"hljs-keyword\">let</span> largest = leftChild\n      <span class=\"hljs-keyword\">if</span> (leftChild + <span class=\"hljs-number\">1</span> &lt; <span class=\"hljs-keyword\">this</span>.heap.length) largest = <span class=\"hljs-keyword\">this</span>.heap[leftChild] &lt; <span class=\"hljs-keyword\">this</span>.heap[leftChild + <span class=\"hljs-number\">1</span>] ? leftChild + <span class=\"hljs-number\">1</span> : leftChild\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.heap[largest] &gt; <span class=\"hljs-keyword\">this</span>.heap[current]) [<span class=\"hljs-keyword\">this</span>.heap[largest], <span class=\"hljs-keyword\">this</span>.heap[current]] = [<span class=\"hljs-keyword\">this</span>.heap[current], <span class=\"hljs-keyword\">this</span>.heap[largest]]\n      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">break</span>\n      current = largest\n      leftChild = current * <span class=\"hljs-number\">2</span>\n    }\n\n    <span class=\"hljs-keyword\">return</span> maxValue\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> maxHeap = <span class=\"hljs-keyword\">new</span> MaxHeap([<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>])\n<span class=\"hljs-built_in\">console</span>.log(maxHeap.heap);\nmaxHeap.insert(<span class=\"hljs-number\">8</span>);\n<span class=\"hljs-built_in\">console</span>.log(maxHeap.heap);\n<span class=\"hljs-keyword\">let</span> maxValue = maxHeap.delete();\n<span class=\"hljs-built_in\">console</span>.log(maxValue);\n<span class=\"hljs-built_in\">console</span>.log(maxHeap.heap);\n\n</code></pre>\n<h2>히프의 시간 복잡도</h2>\n<ul>\n<li>삽입 연산\n<ul>\n<li>최악의 경우는 루트 노드까지 올라간 경우이므로 트리의 높이에 해당하는 비교 연산과 이동 연산이 필요하다. 히프는 완전 이진 탐색이므로 히프의 높이는 log<sub>2</sub>n이 되고 시간 복잡도도 O(log<sub>2</sub>n)</li>\n</ul>\n</li>\n<li>삭제 연산\n<ul>\n<li>삽입 연산과 같다.</li>\n</ul>\n</li>\n</ul>\n<h2>히프의 응용</h2>\n<ul>\n<li>히프 정렬\n<ul>\n<li>최대 히프를 이용하여 정렬할 수 있다.</li>\n<li>요소가 n개일 때, 시간 복잡도는 **O(nlog<sub>2</sub>n)**이다.</li>\n<li>전체 자료 정렬이 아닌 가장 큰 값 몇 개만 정렬하고 싶을 때 사용하면 좋다.</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> heapSort = <span class=\"hljs-function\">(<span class=\"hljs-params\">elements, num</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> sortedElements = []\n  <span class=\"hljs-keyword\">const</span> maxHeap = <span class=\"hljs-keyword\">new</span> MaxHeap([])\n  elements.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">element</span> =&gt;</span> {\n    maxHeap.insert(element)\n  });\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;num; i++) {\n    sortedElements.push(maxHeap.delete())\n  }\n  <span class=\"hljs-keyword\">return</span> sortedElements\n}\n\n<span class=\"hljs-built_in\">console</span>.log(heapSort([<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">8</span>], <span class=\"hljs-number\">5</span>))\n</code></pre>\n<ul>\n<li>허프만 코드 (Huffman Coding) <span class=\"clr-grey\">나중에 추가할 예정…</span></li>\n</ul>\n",
		"updatedAt": "2020-02-23T12:41:54.189Z",
		"id": "coding-interview-tree-graph-2",
		"filename": "algorithm\\coding-interview-tree-graph-2.json"
	},
	{
		"title": "알고리즘 개념 잡자 4탄 - 트라이",
		"date": "2020-01-03T00:00:00.000Z",
		"tags": [
			"coding-interview",
			"data-structure"
		],
		"category": "algorithm",
		"body": "<blockquote>\n<p>참고 서적<br/>\n<a href=\"https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545\">코딩 인터뷰 완전분석</a> 트리와 그래프<br/>\n<a href=\"http://www.yes24.com/Product/Goods/69750539\">C언어로 쉽게 풀어쓴 자료구조</a> 제 7장 트리, 제 8장 우선순위 큐</p>\n</blockquote>\n<h1>3. 트라이(접두사 트리, prefix tree)</h1>\n<blockquote>\n<p>참조 링크 <a href=\"https://en.wikipedia.org/wiki/Trie\">wikipedia</a></p>\n</blockquote>\n<p><img src=\"/assets/images/2020-01-03-img/4.png\" alt=\"트라이\"></p>\n<ul>\n<li>n-차 트리의 변종으로 각 노드에 문자를 저장하는 자료구조이다.</li>\n<li>문자열 탐색에 효율적인 자료구조이다.</li>\n<li>트리를 아래쪽으로 순회하면 단어 하나가 나온다.</li>\n<li>TerminatingTrieNode로 널 노드를 표현한 경우, 트라이에서 각 노드는 1개 ~ 문자열 길이 + 1개 까지 자식을 가질 수 있다.</li>\n<li>널 노드 대신 불린 플래그로 표현한 경우, 각 노드는 0개 ~ 문자열 길이개까지 자식을 가질 수 있다.</li>\n</ul>\n<blockquote>\n<p><em><em>널 노드(</em> 노드)</em>*</p>\n<ul>\n<li>단어의 끝을 나타낸다.</li>\n<li>예) MANY 이후에 널 노드가 나오면 MANY라는 단어가 완성되었다는 의미다.</li>\n</ul>\n<p><strong>널 노드 구현 방법</strong></p>\n<ul>\n<li>TrieNode를 상속한 TerminatingTrieNode로 표현하기</li>\n<li>널 노드의 부모 노드 안에 불린 플래그를 새로 정의함으로써 표현하기</li>\n</ul>\n</blockquote>\n<p><strong>어디에 사용할까?</strong></p>\n<ul>\n<li>자동 완성</li>\n<li>문자열이 어떤 문자열의 접두사인지 확인하고 싶을 때 <span class=\"clr-grey\">cf) 단순 삽입/조회만 한다면 해시테이블 사용을 권장</span></li>\n<li>예: ‘a’, 'axe’로 시작하는 단어를 찾고 싶을 때</li>\n</ul>\n<blockquote>\n<p>예시, M, MA, MAN, MANY를 차례대로 살펴보는 경우 트리의 현재 노드를 참조값으로 넘김으로써 루트 노드에서 시작할 필요가 없고 단순히 Y가 MAN의 자식인지만 확인해보면 된다.</p>\n</blockquote>\n<h2>트라이 VS 해시테이블</h2>\n<ul>\n<li>최악의 경우, 시간복잡도는?\n<ul>\n<li>트라이 : O(K) (K: 가장 긴 문자열)</li>\n<li>해시테이블 : 충돌이 자주 발생되었다면 O(N)의 시간복잡도를 가진다. (N: 키의 개수) 또한 입력 문자열을 기반으로 해시 계산을 하므로 O(K)의 시간이 걸린다.</li>\n<li>cf) 탐색할 문자열이 트라이에 없는 경우에는 문자열 길이 K보다 시간이 덜 걸린다.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>트라이와 해시의 시간복잡도가 비슷하다…?</strong> <br/>\n길이가 K인 무자열이 주어졌을 때 트라이는 O(K) 시간에 해당 문자열이 유효한 접두사인지 확인할 수 있다. 이 시간은 해시테이블 사용했을 때와 정확히 같은 수행 시간이다. 우리가 종종 해시테이블을 검색하는 시간이 O(1)이라고 하지만 완전히 맞는 말은 아니다. 해시테이블도 입력 문자열은 전부 읽어야 하므로 길이가 K인 단어를 검색하는 데 걸리는 시간은 O(K)가 된다.</p>\n</blockquote>\n<ul>\n<li>\n<p>알파벳 정렬?</p>\n<ul>\n<li>일반적으로 자료구조에 문자열을 저장한다면 각 문자열의 순서가 중요하기도 하다. 트라이는 노드를 저장할 때 왼쪽에서 오른쪽으로 사전 순으로 저장한다면 쉽게 정렬이 가능하다.</li>\n</ul>\n</li>\n<li>\n<p>기타</p>\n<ul>\n<li>트라이는 삭제가 직관적이며 해시 함수가 필요 없으나 해시 테이블 보다는 많은 공간을 차지한다.</li>\n</ul>\n</li>\n</ul>\n<h2>트라이 구현</h2>\n<pre><code class=\"language-javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Trie</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(key) {\n    <span class=\"hljs-keyword\">this</span>.is_terminal = <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-keyword\">this</span>.key = key\n    <span class=\"hljs-keyword\">this</span>.trie_child = <span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">26</span>).fill(<span class=\"hljs-literal\">null</span>)    \n  }\n\n  char_to_index(key) {\n    <span class=\"hljs-keyword\">return</span> key.charCodeAt(<span class=\"hljs-number\">0</span>) - <span class=\"hljs-string\">'a'</span>.charCodeAt(<span class=\"hljs-number\">0</span>)\n  }\n\n  <span class=\"hljs-comment\">// 새로운 문자열을 트라이에 추가</span>\n  insert (key) {\n    <span class=\"hljs-keyword\">let</span> current_trie = <span class=\"hljs-keyword\">this</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;key.length; i++) {      \n      <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-keyword\">this</span>.char_to_index(key[i])\n      <span class=\"hljs-keyword\">if</span> (current_trie.trie_child[index] === <span class=\"hljs-literal\">null</span>) current_trie.trie_child[index] = <span class=\"hljs-keyword\">new</span> Trie(key.slice(<span class=\"hljs-number\">0</span>, i+<span class=\"hljs-number\">1</span>))\n      current_trie = current_trie.trie_child[index]   \n    }\n    current_trie.is_terminal = <span class=\"hljs-literal\">true</span>\n  }\n\n  <span class=\"hljs-comment\">// 트라이 출력</span>\n  print (trie, dep) {\n    <span class=\"hljs-built_in\">console</span>.log(dep, trie.key)\n    <span class=\"hljs-keyword\">if</span> (trie.is_terminal) <span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">26</span>; i++) {\n      <span class=\"hljs-keyword\">if</span> (trie.trie_child[i] !== <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">this</span>.print(trie.trie_child[i], dep + <span class=\"hljs-number\">1</span>)\n    }\n  }\n\n  <span class=\"hljs-comment\">// key를 접두어로 가지고 있는지, 가지고 있으면 해당 접두어가 끝나는 부분의 위치를 반환</span>\n  find (key) {\n    <span class=\"hljs-keyword\">let</span> current_trie = <span class=\"hljs-keyword\">this</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;key.length; i++) {      \n      <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-keyword\">this</span>.char_to_index(key[i])\n      <span class=\"hljs-keyword\">if</span> (current_trie.trie_child[index] === <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n      <span class=\"hljs-keyword\">else</span> current_trie = current_trie.trie_child[index]   \n    }\n    <span class=\"hljs-keyword\">return</span> current_trie\n  }\n\n  <span class=\"hljs-comment\">// key를 포함하는 지, 포함하면 true</span>\n  exist (key) {\n    <span class=\"hljs-keyword\">let</span> current_trie = <span class=\"hljs-keyword\">this</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;key.length; i++) {      \n      <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-keyword\">this</span>.char_to_index(key[i])\n      <span class=\"hljs-keyword\">if</span> (current_trie.trie_child[index] === <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n      <span class=\"hljs-keyword\">else</span> current_trie = current_trie.trie_child[index]   \n    }\n    <span class=\"hljs-keyword\">return</span> current_trie.is_terminal\n  }\n  \n\n}\n\n<span class=\"hljs-keyword\">var</span> trie = <span class=\"hljs-keyword\">new</span> Trie(<span class=\"hljs-literal\">null</span>)\n<span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-string\">'to'</span>,<span class=\"hljs-string\">'tea'</span>, <span class=\"hljs-string\">'ted'</span>, <span class=\"hljs-string\">'ten'</span>, <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'inn'</span>]\narr.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">str</span> =&gt;</span> trie.insert(str))\n<span class=\"hljs-comment\">// trie.print(trie, 0)</span>\n<span class=\"hljs-built_in\">console</span>.log(trie.exist(<span class=\"hljs-string\">'tea'</span>)) <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-built_in\">console</span>.log(trie.exist(<span class=\"hljs-string\">'aaa'</span>)) <span class=\"hljs-comment\">// false</span>\n<span class=\"hljs-built_in\">console</span>.log(trie.exist(<span class=\"hljs-string\">'a'</span>)) <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-built_in\">console</span>.log(trie.find(<span class=\"hljs-string\">'te'</span>)) <span class=\"hljs-comment\">// Trie {is_terminal: false, key: \"te\", trie_child: Array(26)}</span>\n\n</code></pre>\n",
		"updatedAt": "2020-02-23T12:41:23.122Z",
		"id": "coding-interview-tree-graph-3",
		"filename": "algorithm\\coding-interview-tree-graph-3.json"
	},
	{
		"title": "운영체제 서론 - 운영체제의 정의와 역할",
		"date": "2015-05-01T22:12:03.284Z",
		"tags": "operation-system",
		"category": "computer-science",
		"body": "<p>경성대학교 양희재 교수님 강의를 듣고 정리했습니다.<br>\n오늘은 운영체제의 정의와 역할에 대해 공부했습니다.</p>\n<hr>\n<h1># 운영체제가 없는 컴퓨터의 전원을 키면 어떤 일이 일어날까??</h1>\n<p>운영체제가 하는 일을 알면 운영체제가 없는 PC에서 어떤 일이 일어나는 지 알 수 있다. 결론부터 말하자면, 컴퓨터는 <strong>한 마디로 야.생.마.</strong> 가 되어 제어할 수 없게 된다. 아래에서 운영체제의 역할을 살펴보며 왜 야생마가 되는 지 알아보자.</p>\n<h2>알아보기 전, 간단히 컴퓨터 구조를 살펴보자!</h2>\n<p>컴퓨터에는 <code class=\"codetainer\">프로세스(처리기)</code>와 <code class=\"codetainer\">메인 메모리</code>가 있다. 우리는 어떤 프로그램을 실행하기 전에 메모리에 명령들(Instructions)을 기록하는 데 이 명령어의 집합을 <code class=\"codetainer\">프로그램</code>이라고 한다. 이렇게 프로그램을 미리 내장해놓고 실행하며 이런 구조의 컴퓨터를 프로그램 내장형 컴퓨터라고 한다. 정리하자면, 전원을 키면 프로세스는 메인 메모리에서 명령어를 가져와서 실행하고 또 그 다음 명령어를 가져와서 실행한다.</p>\n<h2>운영체제가 없는 PC의 전원을 켰을 때, 메인 메모리의 상태는??</h2>\n<p>멋대로의, 임의의 값이 들어있기에 프로세스가 하는 일이 의미가 없다. 마치 전혀 제어가 안되는 야생마와 같다.</p>\n<h2>운영체제는 프로그램을 어떻게 실행시킬까??</h2>\n<p><span class=\"clr-note\">프로그램은 컴퓨터의 하드디스크 안에 실행 파일 형태로 모여있으며 이 파일이 메모리에 올라가야 실제로 실행될 수 있다.</span> 하드디스크의 실행 파일을 메모리에 올리는 것은 운영체제가 담당하기 때문에 운영체제가 없으면 실행 파일을 메모리에 올릴 수가 없다. 메인 메모리에 여러 개의 프로그램이 동시에 올라가있고 프로세스는 한 개 라면 동시에 어떻게 실행시킬까? 사실 이 것도 운영체제가 처리해준다.</p>\n<h2>그 외에</h2>\n<p><span class=\"clr-note\">프린터에 인쇄 명령, 하드 디스크에 저장</span> 등 <span class=\"clr-grey\">(즉, 하드웨어 관리)</span>도 운영체제가 처리해준다. 따라서 운영체제가 없으면 위에 언급한 내용들을 처리할 수 없어서 컴퓨터를 제대로 사용할 수가 없다.</p>\n<h2>정리하자면!</h2>\n<p>운영체제는 컴퓨터의 하드웨어(프로세스, 메모리, 디스크, 키보드, 마우스, 모니터, 네트워크, 스피커, 마이크, GPS…) 등을 잘 관리하여 성능을 높이고 사용자에게 편의성을 제공하는 역할을 담당한다.</p>\n<h1># 부팅(Booting)</h1>\n<h2>알아보기 전, 메모리에 대해 간단히 살펴보자!</h2>\n<p>메인 메모리는 일반적으로 <code class=\"codetainer\">RAM</code>과 <code class=\"codetainer\">ROM</code>으로 나눠지는 데 ROM은 극히 일부분을 차지하고 대부분은 RAM이다. RAM은 휘발성 메모리라서 전원을 껐다 키면 내용이 사라지지만 ROM과 하드디스크는 전원 상관 없이 내용이 유지된다.</p>\n<h2>극히 일부분인 ROM이 하는 일은 무엇일까??</h2>\n<p>전원을 키면 프로세스는 제일 먼저 <code class=\"codetainer\">ROM</code>의 명령어를 읽어와서 실행한다. <span class=\"clr-grey\">ROM은 전원을 처음 켰을 때 한번만 필요.</span> ROM의 프로그램 중, <code class=\"codetainer\">POST(Power-On Self-Test: 컴퓨터가 환경 설정이 제대로 되어 있는지, 프린터 키보드 연결 여부 및 메인 메모리 크기 등을 테스트)</code>를 제일 먼저 실행하고 그 다음 <code class=\"codetainer\">부트로더(Boot loader)</code>를 실행한다.</p>\n<h2>ROM의 부트로더가 하는 일은??</h2>\n<p>부트로더는 하드디스크에 있는 OS를 메인 메모리에 올리는 역할을 한다. OS가 메인 메모리에 올라가면 ROM은 필요가 없다.</p>\n<h2>그 후의 이야기…</h2>\n<p>OS가 메인 메모리에 올라오면 윈도우즈라면 윈도우즈 초기화면이 나타나고 리눅스는 로그인 프롬트가 나타난다. 즉 <span class=\"clr-note\">OS가 메인 메모리에 상주되어 모든 명령어를 받아드릴 준비가 된다.</span> OS는 다른 프로그램과 달리 전원을 끌 때까지 메모리에 상주한다.</p>\n<h1># 커널(kernel) vs 명령 해석기(shell, command interpreter)</h1>\n<p>운영체제는 여러가지 하드웨어 장치를 관리하는 프로그램으로 OS 중 핵심 부분을 <code class=\"codetainer\">커널(kernel)</code>이라고 한다. 반대로 <code class=\"codetainer\">명령 해석기(shell, command interpreter)</code>는 os의 껍질로 사용자로부터 명령을 받고 그 명령을 해석하여 결과를 보여주는 역할을 한다. 예를 들어, 리눅스에서 <code class=\"codetainer\">$who</code>라는 명령을 내려 사용자 목록을 보여주는 데, 이 것을 쉘이 담당한다.</p>\n<h2>하드웨어 &gt; 운영체제 &gt; 애플리케이션</h2>\n<p>하드웨어 위에 운영체제, 운영체제 위에서 애플리케이션이 실행된다.</p>\n",
		"updatedAt": "2020-01-22T18:18:24.597Z",
		"id": "operating system-1",
		"filename": "computer-science\\operating system-1.json"
	},
	{
		"title": "운영체제의 역사 - 일괄처리부터 시분할시스템까지 운영체제 변천의 역사",
		"date": "2019-12-23T00:00:00.000Z",
		"tags": [
			"os"
		],
		"categories": [
			"operating-system"
		],
		"body": "<p>경성대학교 양희재 교수님 강의를 듣고 정리했습니다.<br>\n일괄처리부터 시분할시스템까지 운영체제 변천의 역사에 대해 공부했습니다.</p>\n<hr>\n<h1># Batch processing system(일괄처리)</h1>\n<p>최초의 운영체제로 과거 오퍼레이터가 했던 일련의 작업들을 <span class=\"clr-note\">메모리에 상주시켜 일괄처리</span>한다. 메모리에 상주시킨 작은 프로그램을 <code class=\"codetainer\">레지던트 모니터(resident monitor)</code>라고 한다.</p>\n<h1># Multiprogramming system(다중프로그래밍)</h1>\n<h2>멀티프로그래밍 시스템 등장 배경은??</h2>\n<p>배치 프로세싱 시스템은 메모리에 운영체제와 <strong>하나의</strong> 사용자 프로그램(컴파일러, 게임 등…)만 올릴 수 있다. 하나만 올린다는 건 비싼 컴퓨터를 낭비하는 일이다. 예를 들어 +, *와 같은 연산 작업(CPU)과 화면에 입/출력하는 작업(I/O)을 하는 간단한 C 프로그램을 생각해보자. 프로그램을 실행하면 연산 작업에서는 빠른 CPU를 사용하고 입/출력 작업에서 느린 I/O를 사용한다. 즉, I/O 작업 중에는 CPU가 놀게 되는 것이다. 비싼 CPU를 쉬게 만든다니 너무나 아까운 일이다. 그래서 메모리에 여러 프로그램을 올리는 다중 프로그래밍 시스템이 등장하게 된 것이다.</p>\n<h2>동작 방식은??</h2>\n<p>이제 메모리에 여러 개의 사용자 프로그램이 올라갈 수 있게 된다. user1, user2, user3 프로그램이 메모리에 올라가있고 user1을 실행 중이라고 가정해보자. user1이 연산작업을 위해 CPU를 사용하다가 I/O를 사용하게 되면 바로 user2 프로그램을 실행한다. user2에서도 CPU를 사용하다가 I/O를 사용하게 되면 user3를 실행한다. 이렇게 프로그램이 I/O 작업을 하는 동안 또 다른 프로그램을 실행시켜 CPU를 사용하게 만들어 CPU 낭비를 줄인다.</p>\n<h2>다중 프로그래밍에서 생각해야할 점이 있는데??</h2>\n<p>바로 <span class=\"clr-note\">CPU scheduling, 메모리 관리, 보호</span>이다. 성능을 위해 각 사용자 프로그램을 최적의 순서로 실행해야하는 데 이를 <code class=\"codetainer\">CPU 스케줄링</code>이라고 한다. 이는 나중에 배운다. 또한, 각 사용자 프로그램을 메모리에 어떻게 배치하고 관리<code class=\"codetainer\">(메모리 관리)</code>할지도 고민해야하며 다른 프로그램 영역을 침범하는 경우를 막아야 한다.<code class=\"codetainer\">(보호)</code></p>\n<h1># Time-sharing system(시공유 시스템)</h1>\n<h2>시공유 시스템 등장 배경은??</h2>\n<p>모니터와 키보드가 나오면서 대화형(Interactive system) 컴퓨터가 등장했고 컴퓨터 하나에 여러 개의 단말기(terminal)를 연결하여 여러 사람이 동시에 컴퓨터를 사용할 수 있게 되었다. 그런데 다중 프로그래밍 운영체제로는 동시에 컴퓨터를 사용할 수가 없다. user1 프로그램이 실행되는 동안 user2 프로그램을 실행할 수 없다는 것을 생각해보면 이해가 될 것이다. 시공유 시스템이 등장하게 된 배경이 바로 여기에 있다.</p>\n<h2>동작 방식은??</h2>\n<p>간단하게 1/100(초)마다 user1, user2, user3 프로그램을 스위칭한다고 생각하면 된다. 1/100(초) 동안 user1을 실행하고 그 다음 1/100(초) 동안 user2를 실행한다. 다중 프로그래밍이 I/O에 스위칭하는 것과 달리 시공유 시스템은 특정 시간마다 강제 전환한다. 더 나아가 1초를 기준으로 생각해보자. 1초동안 스위칭이 100번 일어나고 세 개의 프로그램이 메모리에 올라가있으므로 각 프로그램은 1초동안 33번 CPU에 할당된다. 워낙 빠르게 스위칭되어 여러 사용자가 하나의 컴퓨터를 사용하고 있음에도 혼자서 컴퓨터를 사용하는 것처럼 느껴진다.</p>\n<h2>생각해봐야할 점은??</h2>\n<p>바로 <span class=\"clr-note\">프로세스간 통신, 동기화, 가상 메모리</span>다. 하나의 컴퓨터를 여러명이 사용하다보면 서로 간에 데이터를 주고 받고 싶어진다. <code class=\"codetainer\">프로세스간 통신</code>의 등장 이유다. 또, user1, user2, user3가 거의 동시에 실행되므로 누가 앞서서 실행되는 지를 정해야하는 데 이를 <code class=\"codetainer\">동기화</code>라고 한다. 마지막으로 유저가 많아지면 메모리에 올린 프로그램이 많아져 메인 메모리가 부족해지는 경우가 생긴다. 이러한 문제를 해결하기 위해 하드디스크의 일부를 메인 메모리처럼 사용하는 <code class=\"codetainer\">가상 메모리 기술</code>이 등장했다.</p>\n<p>위에서 언급된 cpu 스케줄링, 프로세스간 통신 등은 뒤에서 상세히 공부할 예정이다.</p>\n",
		"updatedAt": "2020-01-22T18:18:24.641Z",
		"id": "operating system-2",
		"filename": "computer-science\\operating system-2.json"
	},
	{
		"layout": "post-content",
		"title": "운영체제 - 프로세스 동기화 2",
		"date": "2020-01-14T00:00:00.000Z",
		"tags": [
			"os"
		],
		"categories": [
			"operating-system"
		],
		"body": "<blockquote>\n<ol>\n<li>생산자-소비자 문제(Producer and Consumer Problem)</li>\n<li>독자-저자 문제(Readers-Writers Problem)</li>\n<li>식사하는 철학자 문제(Dining Philosopher Problem)</li>\n</ol>\n</blockquote>\n<h1>전통적 동기화(Classical Synchronization Problems)</h1>\n<h2>Producer and Consumer Problem</h2>\n<ul>\n<li>생산자-소비자 문제\n<ul>\n<li>생산자가 데이터를 생산하면 소비자는 그것을 소비</li>\n<li>예1: 컴파일러(생산자) &gt; 어셈블러(소비자)</li>\n<li>예2: 파일서버 &gt; 클라이언트</li>\n<li>예3: 웹 서버(html 생산함) -&gt; 웹 클라이언트(브라우저로 소비)</li>\n</ul>\n</li>\n<li>유한버퍼 문제 (Bounded Buffer Problem)\n<ul>\n<li>생산된 데이터는 버퍼에 일단 저장(속도 차이 등)</li>\n<li>현실 시스템에서 버퍼 크기는 유한</li>\n<li>생산자는 버퍼가 가득 차면 더 넣을 수 없다.</li>\n<li>소비자는 버퍼가 비면 뺄 수 없다.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>예시<br/>\n일반적으로 농작물 생산 속도와 소비 속도가 다르다. 현실적으로 바로 농산물을 소비자에게 주는 게 아니라 창고에 우선 저장한다. 저장된 여러 농작물을 소비자가 조금씩 빼먹고 생산자는 계속 생산해서 저장한다. 이 창고가 바로 <strong>버퍼</strong>다. 버퍼는 데이터를 저장할 수 있는 메모리 또는 디스크 공간으로 주로 메모리를 이용하긴 한다. 그런데 버퍼의 크기는 얼마나 될까? 현실 시스템에서 당연히 버퍼 크기는 유한하다. 컴퓨터에서 메모리가 한정적이니 당연한 얘기다.</p>\n</blockquote>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/****** 버퍼 ******/</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Buffer</span> </span>{\n  <span class=\"hljs-keyword\">int</span>[] buf;\n  <span class=\"hljs-keyword\">int</span> size;\n  <span class=\"hljs-keyword\">int</span> count;  <span class=\"hljs-comment\">// 버퍼의 현재 자원 크기</span>\n  <span class=\"hljs-keyword\">int</span> in; <span class=\"hljs-comment\">// 생산자 insert 할 버퍼의 위치</span>\n  <span class=\"hljs-keyword\">int</span> out;  <span class=\"hljs-comment\">// 소비자가 remove 할 버퍼의 위치</span>\n\n  Buffer(<span class=\"hljs-keyword\">int</span> size) {\n    buf = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[size];\n    <span class=\"hljs-keyword\">this</span>.size = size;\n    count = in = out = <span class=\"hljs-number\">0</span>;\n  }\n  <span class=\"hljs-comment\">// 생산자</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> item)</span> </span>{\n    <span class=\"hljs-comment\">/* check if buf is full */</span>\n    <span class=\"hljs-keyword\">while</span> (count == size)\n    ;\n    \n    buf[in] = item;\n    in = (in+<span class=\"hljs-number\">1</span>)%size; <span class=\"hljs-comment\">//circular</span>\n    count++; \n  }\n  <span class=\"hljs-comment\">// 소비자</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">/* check if buf is empty */</span>\n    <span class=\"hljs-keyword\">while</span> (count == <span class=\"hljs-number\">0</span>)\n    ;\n    \n    <span class=\"hljs-keyword\">int</span> item = buf[out];\n    out = (out+<span class=\"hljs-number\">1</span>)%size;\n    count--;\n    <span class=\"hljs-keyword\">return</span> item;    \n  }\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/****** 생산자 ******/</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Producer</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Thread</span> </span>{\n  Buffer b;\n  <span class=\"hljs-keyword\">int</span> N;\n  Producer(Buffer b, <span class=\"hljs-keyword\">int</span> N) {\n    <span class=\"hljs-keyword\">this</span>.b = b; <span class=\"hljs-keyword\">this</span>.N = N;\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;N; i++)\n    b.insert(i);\n  }\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/****** 소비자 ******/</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Consumer</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Thread</span> </span>{\n  Buffer b;\n  <span class=\"hljs-keyword\">int</span> N;\n  Consumer(Buffer b, <span class=\"hljs-keyword\">int</span> N) {\n    <span class=\"hljs-keyword\">this</span>.b = b; <span class=\"hljs-keyword\">this</span>.N = N;\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">int</span> item;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;N; i++)\n    item = b.remove();\n  }\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/****** 메인 ******/</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] arg)</span> </span>{\n    Buffer b = <span class=\"hljs-keyword\">new</span> Buffer(<span class=\"hljs-number\">100</span>);\n    Producer p = <span class=\"hljs-keyword\">new</span> Producer(b, <span class=\"hljs-number\">10000</span>);\n    Consumer c = <span class=\"hljs-keyword\">new</span> Consumer(b, <span class=\"hljs-number\">10000</span>);\n    p.start();\n    c.start();\n    <span class=\"hljs-keyword\">try</span> {\n      p.join();\n      c.join();\n    } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {}\n      System.out.println(<span class=\"hljs-string\">\"Number of items in the buf is \"</span> + b.count);\n  }\n}\n</code></pre>\n<ul>\n<li>위 코드는 잘못된 결과가 나온다.\n<ul>\n<li><code>실행 불가</code> 또는 <code>count != 0</code> (생산된 항목 숫자 != 소비자 항목 숫자)</li>\n<li>최종적으로 버퍼 내에는 0개의 항목이 있어야 한다.</li>\n</ul>\n</li>\n<li>원인은 무엇일까?\n<ul>\n<li>공통변수 count, buf[]에 대한 동시 업데이트 때문이다.</li>\n<li>공통 변수 업데이트 구간(=임계구역)에 대한 동시 진입한다.</li>\n</ul>\n</li>\n<li>어떻게 해결하지?\n<ul>\n<li><span class=\"clr-note\">임계구역에 대한 동시 접근 방지(상호배타)하기</span></li>\n<li>세마포를 사용한 상호배타 (mutual exclusion) 하기</li>\n<li>세마포: mutex.value = 1 (# of permit)</li>\n</ul>\n</li>\n</ul>\n<br/>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/****** 버퍼 ******/</span>\n<span class=\"hljs-keyword\">import</span> java.util.concurrent.Semaphore;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Buffer</span> </span>{\n  <span class=\"hljs-keyword\">int</span>[] buf;\n  <span class=\"hljs-keyword\">int</span> size;\n  <span class=\"hljs-keyword\">int</span> count;  <span class=\"hljs-comment\">// 버퍼의 현재 자원 크기</span>\n  <span class=\"hljs-keyword\">int</span> in; <span class=\"hljs-comment\">// 생산자 insert 할 버퍼의 위치</span>\n  <span class=\"hljs-keyword\">int</span> out;  <span class=\"hljs-comment\">// 소비자가 remove 할 버퍼의 위치</span>\n  Semaphore mutex;\n\n  Buffer(<span class=\"hljs-keyword\">int</span> size) {\n    buf = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[size];\n    <span class=\"hljs-keyword\">this</span>.size = size;\n    count = in = out = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">this</span>.mutex = <span class=\"hljs-keyword\">new</span> Semaphore(<span class=\"hljs-number\">1</span>);\n  }\n  <span class=\"hljs-comment\">// 생산자</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> item)</span> </span>{\n    <span class=\"hljs-comment\">/* check if buf is full */</span>\n    <span class=\"hljs-keyword\">while</span> (count == size)\n    ;\n    <span class=\"hljs-keyword\">try</span> {\n      mutex.acquire();\n      <span class=\"hljs-comment\">/****** S : 임계구역 *****/</span>\n      buf[in] = item;\n      in = (in+<span class=\"hljs-number\">1</span>)%size; <span class=\"hljs-comment\">//circular</span>\n      count++;\n      <span class=\"hljs-comment\">/****** E : 임계구역 *****/</span>    \n    } <span class=\"hljs-keyword\">catch</span>(InterruptedException) {}    \n    mutex.release();\n  }\n  <span class=\"hljs-comment\">// 소비자</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">/* check if buf is empty */</span>\n    <span class=\"hljs-keyword\">while</span> (count == <span class=\"hljs-number\">0</span>)\n    ;\n    <span class=\"hljs-keyword\">try</span> {\n      mutex.acquire();\n      <span class=\"hljs-comment\">/****** S : 임계구역 *****/</span>\n      <span class=\"hljs-keyword\">int</span> item = buf[out];\n      out = (out+<span class=\"hljs-number\">1</span>)%size;\n      count--;\n      <span class=\"hljs-keyword\">return</span> item;\n      <span class=\"hljs-comment\">/****** E : 임계구역 *****/</span>\n    } <span class=\"hljs-keyword\">catch</span>(InterruptedException) {}    \n    mutex.release();\n    <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n  }\n}\n</code></pre>\n<p><br/><br/></p>\n<ul>\n<li>하지만 또! <code>Busy-wait</code> 라는 문제가 있다.\n<ul>\n<li>insert의 <code>while (count == size);</code>와 remove의 <code>while (count == 0);</code> 로 인해 반복문에 붙잡히는 경우가 생긴다. cpu가 딴 일 못하고 붙잡힌다.</li>\n<li>생산자: 버퍼가 가득 차면 기다려야 = 빈(empty) 공간이 있어야 한다.</li>\n<li>소비자: 버퍼가 비면 기다려야 = 찬(full) 공간이 있어야 한다.</li>\n</ul>\n</li>\n<li>어떻게 해결하지?\n<ul>\n<li>무한루프가 아니라 아예 감옥에 가둬버리자!</li>\n<li>세마포를 사용한 busy-wait 회피</li>\n<li>생산자: empty.acquire() // # of permit = BUF_SIZE</li>\n<li>소비자: full.acquire() // # of permit = 0</li>\n</ul>\n</li>\n</ul>\n<br/>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/****** 버퍼 ******/</span>\n<span class=\"hljs-keyword\">import</span> java.util.concurrent.Semaphore;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Buffer</span> </span>{\n  <span class=\"hljs-keyword\">int</span>[] buf;\n  <span class=\"hljs-keyword\">int</span> size;\n  <span class=\"hljs-keyword\">int</span> count;  <span class=\"hljs-comment\">// 버퍼의 현재 자원 크기</span>\n  <span class=\"hljs-keyword\">int</span> in; <span class=\"hljs-comment\">// 생산자 insert 할 버퍼의 위치</span>\n  <span class=\"hljs-keyword\">int</span> out;  <span class=\"hljs-comment\">// 소비자가 remove 할 버퍼의 위치</span>\n  Semaphore mutex;   <span class=\"hljs-comment\">// 임계구역에 1개만 들어가게 하려고</span>\n  Semaphore empty;\n  Semaphore full;\n\n  Buffer(<span class=\"hljs-keyword\">int</span> size) {\n    buf = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[size];\n    <span class=\"hljs-keyword\">this</span>.size = size;\n    count = in = out = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">this</span>.mutex = <span class=\"hljs-keyword\">new</span> Semaphore(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-keyword\">this</span>.empty = <span class=\"hljs-keyword\">new</span> Semaphore(size);\n    <span class=\"hljs-keyword\">this</span>.full = <span class=\"hljs-keyword\">new</span> Semaphore(<span class=\"hljs-number\">0</span>);\n  }\n  <span class=\"hljs-comment\">// 생산자</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> item)</span> </span>{\n    <span class=\"hljs-comment\">/* check if buf is full */</span>\n    <span class=\"hljs-keyword\">while</span> (count == size)\n    ;\n    <span class=\"hljs-keyword\">try</span> {\n      empty.acuire();\n      mutex.acquire();\n      <span class=\"hljs-comment\">/****** S : 임계구역 *****/</span>\n      buf[in] = item;\n      in = (in+<span class=\"hljs-number\">1</span>)%size; <span class=\"hljs-comment\">//circular</span>\n      count++;\n      <span class=\"hljs-comment\">/****** E : 임계구역 *****/</span>    \n    } <span class=\"hljs-keyword\">catch</span>(InterruptedException) {}    \n    mutex.release();\n    full.release();\n  }\n  <span class=\"hljs-comment\">// 소비자</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">/* check if buf is empty */</span>\n    <span class=\"hljs-keyword\">while</span> (count == <span class=\"hljs-number\">0</span>)\n    ;\n    <span class=\"hljs-keyword\">try</span> {\n      full.acquire();\n      mutex.acquire();\n      <span class=\"hljs-comment\">/****** S : 임계구역 *****/</span>\n      <span class=\"hljs-keyword\">int</span> item = buf[out];\n      out = (out+<span class=\"hljs-number\">1</span>)%size;\n      count--;\n      <span class=\"hljs-keyword\">return</span> item;\n      <span class=\"hljs-comment\">/****** E : 임계구역 *****/</span>\n    } <span class=\"hljs-keyword\">catch</span>(InterruptedException) {}    \n    mutex.release();\n    empty.release();\n    <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n  }\n}\n</code></pre>\n<h2>Readers-Writers Problem</h2>\n<ul>\n<li>공통 데이터베이스\n<ul>\n<li>Readers: read data, never modify it</li>\n<li>Writers: read data and modifiy it</li>\n<li>상호배타: 한 번에 한 개의 프로세스만 접근하는 것 효율성이 안 좋다.</li>\n</ul>\n</li>\n<li>효율성을 높이려면?\n<ul>\n<li>데이터베이스 읽고 쓰기는 임계 구역 안에서 발생한다.</li>\n<li>그러므로 Writers은 당연히 상호 배타 해야한다.</li>\n<li>그러나 Reader1이 DB 읽고 있으면 Reader2도 읽을 수 있게 해줘야 효율성에 좋다!</li>\n</ul>\n</li>\n<li>변종\n<ul>\n<li>The first R/W problem (readers-preference) : 항상 readers에게 우선권을 주는 것. 예) 현재 Reader1이 DB를 읽고 있다고 가정해보자. Writer1의 경우는 상호 배타되어서 접근할 수 없다. 잠시 후 Reader2가 접근하면 Reader2는 늦게 왔음에도 불구하고 DB에 접근할 수 있다.</li>\n<li>The second R/W problem (writers-preference) : writers에게 우선권 주는 것</li>\n<li>The Third R/W problem : 우선권 아예 안 주는 것</li>\n</ul>\n</li>\n</ul>\n<h2>Dining Philosopher Problem</h2>\n<p><img src=\"/assets/images/2020-01-14-img/1.png\" alt=\"process tree\"><br/></p>\n<blockquote>\n<p>5명의 철학자가 원탁에 앉아 있고 각자의 앞에는 스파게티가 있다. 그리고 양 옆에는 젓가락이 하나씩 있다. 각각의 철학자는 스파게티를 먹으려면 젓가락을 2개를 사용해야 하며, 다른 철학자에게 말을 걸 수 없고 젓가락을 빼앗을 수도 없다.\n<br/><br/> 이제 5명의 철학자 모두가 갑자기 배가 고파서 동시에 왼쪽 젓가락을 집어든다고 생각해보자. 철학자들은 젓가락을 공유할 수 없고 자신의 오른쪽에 앉은 철학자가 젓가락을 놓을 때까지 기다린다. 오른쪽 젓가락을 빼앗을 방법도 없어서 철학자들의 계속 대기만 한다…</p>\n</blockquote>\n<ul>\n<li>식사하는 철학자 문제\n<ul>\n<li>5명의 철학자, 5개의 젓가락, 생각 → 식사 → 생각 → 식사</li>\n<li>식사하려면 2개의 젓가락 필요</li>\n</ul>\n</li>\n<li>프로그래밍\n<ul>\n<li>젓가락: 세마포 (# of permit = 1) -&gt; 젓가락을 기준으로 2명 중 1명만 사용할 수 있으니깐 1로 한다.</li>\n<li>젓가락과 세마포에 일련번호: 0 ~ 4</li>\n<li>왼쪽 젓가락 → 오른쪽 젓가락</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/*********철학자*********/</span>\n<span class=\"hljs-keyword\">import</span> java.util.concurrent.Semaphore;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Philosopher</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Thread</span> </span>{\n  <span class=\"hljs-keyword\">int</span> id; <span class=\"hljs-comment\">// philosopher id</span>\n  Semaphore lstick, rstick; <span class=\"hljs-comment\">// left, right chopsticks</span>\n  Philosopher(<span class=\"hljs-keyword\">int</span> id, Semaphore lstick, Semaphore rstick) {\n    <span class=\"hljs-keyword\">this</span>.id = id;\n    <span class=\"hljs-keyword\">this</span>.lstick = lstick;\n    <span class=\"hljs-keyword\">this</span>.rstick = rstick;\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">try</span> {\n      <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-keyword\">true</span>) {\n        lstick.acquire();\n        rstick.acquire();\n        eating();\n        lstick.release();\n        rstick.release();\n        thinking();\n      }\n    }<span class=\"hljs-keyword\">catch</span> (InterruptedException e) { }\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">eating</span><span class=\"hljs-params\">()</span> </span>{\n    System.out.println(<span class=\"hljs-string\">\"[\"</span> + id + <span class=\"hljs-string\">\"] eating\"</span>);\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">thinking</span><span class=\"hljs-params\">()</span> </span>{\n    System.out.println(<span class=\"hljs-string\">\"[\"</span> + id + <span class=\"hljs-string\">\"] thinking\"</span>);\n  }\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/*********메인*********/</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>{\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> num = <span class=\"hljs-number\">5</span>; <span class=\"hljs-comment\">// number of philosphers &amp; chopsticks</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n    <span class=\"hljs-keyword\">int</span> i;\n    <span class=\"hljs-comment\">/* chopsticks */</span>\n    Semaphore[] stick = <span class=\"hljs-keyword\">new</span> Semaphore[num];\n    <span class=\"hljs-keyword\">for</span> (i=<span class=\"hljs-number\">0</span>; i&lt;num; i++)\n      stick[i] = <span class=\"hljs-keyword\">new</span> Semaphore(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-comment\">/* philosophers */</span>\n    Philosopher[] phil = <span class=\"hljs-keyword\">new</span> Philosopher[num];\n    <span class=\"hljs-keyword\">for</span> (i=<span class=\"hljs-number\">0</span>; i&lt;num; i++)\n      phil[i] = <span class=\"hljs-keyword\">new</span> Philosopher(i, stick[i], stick[(i+<span class=\"hljs-number\">1</span>)%num]);\n    <span class=\"hljs-comment\">/* let philosophers eat and think */</span>\n    <span class=\"hljs-keyword\">for</span> (i=<span class=\"hljs-number\">0</span>; i&lt;num; i++)\n      phil[i].start();\n  }\n}\n</code></pre>\n<ul>\n<li>위 코드는 프로그램이 돌다가 멈춘다… 왜!!!\n<ul>\n<li>잘못된 결과: starvation -&gt; 모든 철학자가 식사를 하지 못해 굶어 죽는 상황</li>\n<li>이유 = <span class=\"clr-note\">교착상태 (deadlock)</span></li>\n</ul>\n</li>\n</ul>\n",
		"updatedAt": "2020-01-22T18:18:24.657Z",
		"id": "operating-system-10",
		"filename": "computer-science\\operating-system-10.json"
	},
	{
		"layout": "post-content",
		"title": "운영체제 - 인터럽트 기반 운영체제",
		"date": "2019-12-23T00:00:00.000Z",
		"tags": [
			"os"
		],
		"categories": [
			"operating-system"
		],
		"body": "<p>경성대학교 양희재 교수님 강의를 듣고 정리했습니다.<br>\n인터럽트 기반 운영체제에 대해 공부했습니다.</p>\n<hr>\n<h1># 인터럽트 기반 시스템(Interrupt-Based System)</h1>\n<p>현대 운영체제는 인터럽트 기반 시스템이다.</p>\n<h2>전원을 키면?</h2>\n<p>메인메모리가 비워져 있는 상태에서 CPU가 ROM의 부트로더를 실행하면 하드디스크의 운영체제가 메인 메모리에 올라가게 된다. 운영체제가 메인 메모리에 올라간 것을 <code class=\"codetainer\">부팅</code>이라고 부른다.</p>\n<h2>부팅 끝난 후 운영체제의 상태는?</h2>\n<p>부팅이 끝나면 운영체제는 메모리에 상주하게 되고 이벤트(인터럽트)를 기다리는 대기 상태가 된다. 이 운영체제에는 여러 개의 코드가 있고 이 코드는 인터럽트(하드웨어, 소프트웨어, 내부)가 발생할 때 실행된다.</p>\n<h2>하드웨어 인터럽트 - 키보드, 마우스…</h2>\n<p>마우스로 예를 들어 보자. 우리가 마우스를 움직이면 마우스에서 전기 신호가 발생하여 그 신호가 CPU의 인터럽트 선으로 전달된다. <span class=\"clr-note\">CPU는 인터럽트 신호를 받으면 지금 하던 일을 중지하고 운영체제에 있는 인터럽트 서비스 루틴(ISR)을 실행시킨다.</span> <code class=\"codetainer\">인터럽트 서비스 루틴</code>은 해당 인터럽트가 오면 어떤 일을 수행할 지 코드해놓은 프로그램이다. 우리는 이 인터럽트와 인터럽트 서비스 루틴 덕분에 마우스를 움직이면 화면의 마우스 커서가 움직이게 할 수 있는 것이다. 다른 예시로 hwp 아이콘을 더블 클릭하는 경우를 생각해보자. 더블 클릭으로 인터럽트가 발생하면 CPU는 OS의 더블클릭 ISR을 실행한다. 더블 클릭 인터럽트 서비스 루틴은 하드디스크의 HWP 실행 파일을 메인 메모리에 올려서 CPU가 실행할 수 있도록 한다.</p>\n<h2>소프트웨어 인터럽트</h2>\n<p>hwp 프로그램 실행 중 memo.hwp 파일을 읽어오고 싶은 경우를 생각해보자. 하드디스크를 뒤져서 memo.hwp를 메모리에 올려야하는 데 이 작업은 hwp 프로그램이 직접 수행하지않는다. 인터럽트를 발생시켜 운영체제의 ISR을 실행하여 메모리에 올리는 것이다. ISR이 실행되어 memo.hwp를 다 읽으면 다시 hwp 프로그램으로 돌아온다. <span class=\"clr-note\">정리하자면, 사용자 프로그램에서 소프트웨어 인터럽트를 걸면 운영체제 안의 특정 코드(ISR)를 실행하고 이 코드 실행이 끝나면 다시 사용자 프로그램으로 돌아온다.</span></p>\n<h2>내부 인터럽트</h2>\n<p>하나의 예시로 <span class=\"clr-note\">divide by zero</span>를 들 수 있다. <code class=\"codetainer\">int i=5, j=0; i=i/j;</code> 다음과 같이 0으로 나누는 연산을 하면 i에 값을 저장할 수 없게 된다. 이는 곧 그 다음 코드를 실행할 수 없다는 의미다. 컴퓨터는 이러한 경우, 프로그램을 강제 종료시키고 싶어진다. 그래서 CPU는 내부적으로 인터럽트를 발생한 것으로 인식하여 프로그램을 종료시키는 ISR을 실행시킨다.</p>\n",
		"updatedAt": "2020-01-22T18:18:24.677Z",
		"id": "operating-system-3",
		"filename": "computer-science\\operating-system-3.json"
	},
	{
		"layout": "post-content",
		"title": "운영체제 - 이중모드, 하드웨어 보호",
		"date": "2019-12-25T00:00:00.000Z",
		"tags": [
			"os"
		],
		"categories": [
			"operating-system"
		],
		"body": "<p>경성대학교 양희재 교수님 강의를 듣고 정리했습니다.<br>\n사용자 모드와 관리자 모드, 하드웨어 보호에 대해 공부했습니다.</p>\n<hr>\n<h1># 이중모드(Dual Mode)</h1>\n<h2>이중모드의 등장 배경은?</h2>\n<p>하나의 서버 컴퓨터를 여러 사람이 동시에 사용하는 또는 한 사람이 여러 개의 프로그램을 동시에 사용하는 환경에서 한 사람의 고의/실수 프로그램은 전체에 영향을 끼치게 된다. 예를 들어, 한 사용자 프로그램에서 <code class=\"codetainer\">STOP, HALT, RESET, SET_TIMER, SET_HW</code>등의 명령을 실행한다면 컴퓨터 전체가 영향을 받는다. 즉, <span class=\"clr-note\">시스템에 치명적인 명령은 관리자만 실행할 수 있도록</span> 하기 위해 이중모드(사용자모드, 관리자모드)가 등장하게 된 것이다.</p>\n<h2>이중모드란?</h2>\n<p><code class=\"codetainer\">시스템(system) 모드 = 관리자(supervisor) 모드 = 모니터(monitor) 모드 = 특권(priviliged) 모드</code> 와 <code class=\"codetainer\">사용자 모드</code>가 있다. 시스템 모드일 때, <code class=\"codetainer\">STOP, HALT</code> 와 같은 <code class=\"codetainer\">특권 명령</code>을 내릴 수 있고 사용자 프로그램에서는 치명적 명령을 사용 못하게 막는다.</p>\n<h2>이중모드는 어떻게 동작할까?</h2>\n<p>CPU에 있는 <code class=\"codetainer\">레지스터</code>는 비트를 가지고 있으며 각 비트는 <code class=\"codetainer\">carry, negative, zero, overflow</code> 발생을 알려주는 플래그 역할을 한다. 여기에 이중모드를 위한 비트를 추가하여 <span class=\"clr-note\">시스템 모드면 1</span>을 <span class=\"clr-note\">사용자 모드면 0</span>으로 표시한다.      <br/><br/>\n<img src=\"/assets/images/2019-12-25-img/dual-mode.png\" alt=\"이중모드\"><br/></p>\n<ul>\n<li>운영체제 서비스를 실행될 때는 <span class=\"clr-note\">관리자 모드</span></li>\n<li>사용자 프로그램 실행될 때는 <span class=\"clr-note\">사용자 모드</span></li>\n<li>하드웨어/소프트웨어 인터럽트 발생하면 <span class=\"clr-note\">관리자 모드</span></li>\n<li>운영체제 서비스가 끝나면 다시 <span class=\"clr-note\">사용자 모드</span></li>\n</ul>\n<h2>이중모드 예시</h2>\n<p>전원을 켰을 때 하드 디스크에 있는 운영체제가 메인 메모리에 올라가는 것은 <strong>시스템 모드</strong>에서 동작한다. 부팅이 끝나면 <strong>사용자 모드</strong>가 된다. 게임 아이콘을 더블클릭하여 인터럽트가 발생하면 다시 <strong>시스템 모드</strong>가 되어 인터럽트 서비스 루틴이 게임을 메인 메모리에 올리고 cpu가 실행할 수 있도록 한다. 다시 <strong>사용자 모드</strong>로 돌아오고 열심히 게임을 한다. 이제 게임 스코어를 하드디스크에 저장해보자. 게임 프로그램이 직접 하드디스크에 저장하는 것이 아니라 소프트웨어 인터럽트를 걸어 CPU가 지금 하던 일을 멈추고 운영체제의 ISR로 점프해서 실행하도록 한다. 이 때는 <strong>시스템 모드</strong>이다. ISR이 완료되면 레지스터 비트를 0으로 하여 <strong>사용자 모드</strong>로 만들고 다시 게임으로 돌아오게 된다.</p>\n<p>하드웨어 인터럽트도 마찬가지다. <strong>사용자 모드</strong>에서 마우스를 움직이게 되면 CPU로 인터럽트를 보내 <strong>시스템 모드</strong>로 바꾼 후 ISR을 실행한다. 완료되면 다시 <strong>사용자 모드</strong>가 된다. 즉, <span class=\"clr-note\">하나의 프로그램이 실행되는 동안 사용자 모드, 시스템 모드가 계속 반복된다.</span></p>\n<h2>만약 사용자 프로그램에서 특권 명령을 내리면?</h2>\n<p>CPU는 레지스터의 모니터 비트를 확인하여 특권 명령이 사용자 모드일 때 내려지면 인터럽트를 발생시킨다. 운영체제의 인터럽트 서비스 루틴이 실행되고 이 ISR은 잘못된 시도를 한 프로그램을 강제 종료시켜 메모리에서 사라지게 한다.</p>\n<h1># 하드웨어 보호</h1>\n<h2>입출력 장치 보호</h2>\n<p>사용자 A가 프린터를 사용 중인 상황에서 사용자 B가 프린트 출력 명령을 내리면 어떻게 될까? 운영체제가 없다면 A 사용자꺼 한 줄, B 사용자꺼 한 줄…식으로 출력이 될 것이다. 이같은 프린트 혼선, 리셋 등의 상황이 적절한가? 다른 예시로 하드디스크에 저장된 A의 정보를 B가 마음대로 읽고 쓰는 상황을 생각해보자. 이 것도 적절한가? 답은 <span class=\"clr-note\">NO!!</span></p>\n<p><strong>어떻게 해야할까?</strong> 컴퓨터는 바로 이렇게 해결했다.</p>\n<p>입출력 명령인 <code class=\"codetainer\">IN, OUT</code>을 특권 명령으로 하여 사용자가 직접 입출력 명령을 내릴 수 없도록 했다. 만약 사용자가 직접 내리면 <code class=\"codetainer\">Privileged instruction violation</code>이기에 강제로 프로그램을 종료시킨다. 즉, 사용자가 입출력을 하기 위해서는 <code class=\"codetainer\">소프트웨어 인터럽트</code>를 발생시켜 운영체제에 요청해야한다. 인터럽트에 의해 CPU가 시스템 모드로 전환하고 운영체제의 ISR을 실행하면 운영체제가 입출력을 대행한다. ISR에는 요청이 적절한 지를 확인하는 코드가 있어 올바른 요청에만 실행된다. 만약, 올바른 요청이 아니면 운영체제는 이를 거부한다. ISR이 완료되면 다시 사용자 모드로 복귀된다.</p>\n<h2>메모리 보호</h2>\n<p>메인 메모리에는 운영체제와 여러 개의 사용자 프로그램이 동시에 있기 때문에 다른 사용자 메모리 또는 운영체제에 접근하는 것을 막아야 한다. 보호하지 않으면 다른 사용자 정보나 프로그램을 해킹하거나 운영체제를 해킹하는 경우가 생긴다.</p>\n<p><strong>어떻게 메모리를 보호할까?</strong> 컴퓨터는 바로 이렇게 해결했다.</p>\n<p>CPU와 메인 메모리 사이는 Bus로 연결되어있고 CPU -&gt; 메모리는 <code class=\"codetainer\">Address Bus</code>, 메모리 -&gt; CPU는 <code class=\"codetainer\">Data Bus</code>로 부른다. 컴퓨터는 다른 메모리 영역의 침범을 막기 위해 Address Bus에 <code class=\"codetainer\">MMU(Memory Management Unit)</code>을 두었고 문지기 역할을 하도록 했다. MMU에는 <code class=\"codetainer\">Base, Limit</code>가 있고 값 설정은 특권 명령으로 운영체제만 바꿀 수 있다. MMU는 Base~Limit 사이면 통과시키고 범위 밖이면 CPU로 인터럽트 신호를 발생시켜 해당 명령을 내린 프로그램을 종료시킨다. 이처럼 다른 사용자 또는 운영체제 영역 메모리에 접근하려는 것을 <code class=\"codetainer\">Segment Violation</code> 이라고 한다.</p>\n<h2>cpu 보호</h2>\n<p>한 사용자가 <code class=\"codetainer\">while(n = 1)</code> 과 같은 명령을 실행하면 CPU를 계속 독점하여 다른 사용자의 프로그램을 실행할 수 없게 된다. 이를 막기 위해 CPU 보호가 필요한 것이다. <span class=\"clr-note\">컴퓨터는 Timer를 두어 일정 시간 경과 시 타이머 인터럽트를 발생시키는 방법으로 해결했다.</span> 일정 신호 주기로 타이머가 CPU에 인터럽트를 걸게 되면 CPU는 ISR을 실행시켜 프로그램이 CPU를 너무 오랜 시간 독점하고 있는 지를 확인한다. 독점하고 있다고 판단되면 CPU를 강제 전환시켜 다른 프로그램을 실행토록 한다.</p>\n",
		"updatedAt": "2020-01-22T18:18:24.686Z",
		"id": "operating-system-4",
		"filename": "computer-science\\operating-system-4.json"
	},
	{
		"layout": "post-content",
		"title": "운영체제 - 운영체제 주요 서비스 간략하게!",
		"date": "2019-12-25T00:00:00.000Z",
		"tags": [
			"os"
		],
		"categories": [
			"operating-system"
		],
		"body": "<p>경성대학교 양희재 교수님 강의를 듣고 정리했습니다.<br>\n운영체제의 주요 서비스: 프로세스, 메모리, 파일관리, 시스템 호출 개론에 대해 공부했습니다.</p>\n<hr>\n<h1># 운영체제의 주요 서비스</h1>\n<ul>\n<li>프로세스 관리</li>\n<li>주 기억장치 관리(메인 메모리 관리)</li>\n<li>파일 관리(하드디스크의 파일)</li>\n<li>보조기억장치 관리</li>\n<li>입출력 장치 관리(프린트, 키보드, 마우스…)</li>\n<li>네트워킹</li>\n<li>보호</li>\n<li>기타…</li>\n</ul>\n<h2>프로세스 관리</h2>\n<p>메인 메모리에서 실행 중인 프로그램을 프로세스라고 한다.</p>\n<ul>\n<li>프로세스의 생성, 소멸(creation, deletion)</li>\n<li>프로세스 활동 일시 중지, 활동 재개(suspend, resume)</li>\n<li>프로세스간 통신(interprocess communication: IPC)</li>\n<li>프로세스간 동기화(synchromization)</li>\n<li>교착 상태 처리(deadlock handling)</li>\n</ul>\n<h2>주기억장치관리(메인메모리)</h2>\n<ul>\n<li>프로세스에게 메모리 공간 할당 (allocation)</li>\n<li>메모리의 어느 부분이 어느 프로세스에게 할당되었는가 추적 및 감시</li>\n<li>프로세스 종료 시 메모리 회수 (deallocation)</li>\n<li>메모리의 효과적 사용</li>\n<li>가상 메모리: 물리적 실제 메모리보다 큰 용량 갖도록</li>\n</ul>\n<h2>파일 관리</h2>\n<p>원래 디스크는 판 위의 Track과 sector의 집합이지만 파일이라는 논리적 관점으로 볼 수 있게 운영체제가 처리해준다.</p>\n<ul>\n<li>파일의 생성과 삭제 (file creation &amp; deletion)</li>\n<li>디렉토리(directory)의 생성과 삭제 (또는 폴더 folder)- 기본동작지원: open, close, read, write, create, delete</li>\n<li>Track/sector – file 간의 매핑(mapping) – 백업(backup)</li>\n</ul>\n<h2>보조기억장치 관리</h2>\n<p>하드디스크, 플래시 메모리.</p>\n<ul>\n<li>빈 공간 관리 (free space management) - 포맷 후 비워져있는 Block(섹터/트랙 집합)은 사용하다보면 비워져있는 공간, 사용되고 있는 공간으로 나눠진다. 이 공간을 관리하는 것</li>\n<li>저장공간 할당 (storage allocation)</li>\n<li>디스크 스케쥴링 (disk scheduling) : 어떻게 하면 헤더를 적게 움직이면서 원하는 트랙이나 섹터를 읽을 수 있을까?</li>\n</ul>\n<h2>입출력 장치 관리</h2>\n<ul>\n<li>장치 드라이브</li>\n<li>입출력 장치의 성능 향상 : <span class=\"clr-note\">buffering</span>(입출력 장치에서 읽은 내용을 일단 메모리에 가져오는 것, 한번 메모리에 가져오면 일단 빠르게 읽을 수 있음), <span class=\"clr-note\">caching</span>, <span class=\"clr-note\">spooling</span>(메모리 대신에 하드디스크를 중간 매체로 사용하는 것, 프린트로 출력할 내용을 디스크에 저장해서 cpu가 다른 일 할 수 있게)</li>\n</ul>\n<h2>시스템 콜</h2>\n<p>운영체제 서비스를 받기 위한 호출</p>\n<ul>\n<li><span class=\"clr-note\">Process</span>: end, abort, load, execute, create, terminate, get/set\nattributes, wait event, signal event</li>\n<li><span class=\"clr-note\">Memory</span>: allocate, free</li>\n<li><span class=\"clr-note\">File</span>: create, delete, open, close, read, write, get/set attributes</li>\n<li><span class=\"clr-note\">Device</span>: request, release, read, write, get/set attributes,\nattach/detache devices</li>\n<li><span class=\"clr-note\">Information</span>: get/set time, get/set system data</li>\n<li><span class=\"clr-note\">Communication</span>: socket, send, receive</li>\n</ul>\n",
		"updatedAt": "2020-01-22T18:18:24.695Z",
		"id": "operating-system-5",
		"filename": "computer-science\\operating-system-5.json"
	},
	{
		"layout": "post-content",
		"title": "운영체제 - 프로세스 관리",
		"date": "2019-12-25T00:00:00.000Z",
		"tags": [
			"os"
		],
		"categories": [
			"operating-system"
		],
		"body": "<p>경성대학교 양희재 교수님 강의를 듣고 정리했습니다.<br>\n프로세스의 정의, CPU 스케쥴러, 멀티프로그래밍에 대해 공부했습니다.</p>\n<hr>\n<h1># 프로세스</h1>\n<h2>프로그램 vs 프로세스</h2>\n<p><code class=\"codetainer\">Process = task = job</code><br>\n게임 프로그램이 하드디스크에 있으면 아무 것도 할 수 없다. 게임을 하기 위해 더블 클릭하면 게임 프로그램이 메인 메모리에 올라와서 실행 된다. 이렇게 실행 중인 프로그램을 <code class=\"codetainer\">프로세스</code>라고 한다</p>\n<h2>프로세스 상태</h2>\n<p>하나의 컴퓨터는 여러 개의 프로세스를 돌리고 CPU는 일정 시간을 나눠주어 이 프로세스들을 관리한다. 이 때, 프로세스는 <code class=\"codetainer\">new, ready, running, waiting, terminated</code> 상태를 겪게 된다.</p>\n<p><img src=\"/assets/images/2019-12-25-img/process.png\" alt=\"프로세스 상태\"><br/></p>\n<ul>\n<li>\n<p>new : 하드디스크의 프로그램이 메인 메모리에 올라왔을 때</p>\n</li>\n<li>\n<p>ready : 모든 초기화를 끝내고 실행 준비가 되었을 때</p>\n</li>\n<li>\n<p>running : 실제로 CPU에서 실행하고 있을 때</p>\n</li>\n<li>\n<p>waiting : 다시 CPU 할당 받을 때까지 기다릴 때</p>\n</li>\n<li>\n<p>terminated : 프로세스가 종료된 상태</p>\n</li>\n<li>\n<p>(1) : 프린트 출력 같은 I/O 발생 시 Waiting으로 감</p>\n</li>\n<li>\n<p>(2) : I/O 완료되면 다시 Ready로 감</p>\n</li>\n<li>\n<p>(3) : Time sharing system 에서는 일정 주기마다 프로세스 전환 인터럽트가 발생하는 데, 프로세스에게 주어진 CPU 사용 시간이 지나면 자동으로 이 프로세스는 Ready 상태로 가고 다른 프로세스가 running 상태가 된다.</p>\n</li>\n</ul>\n<h1># PCB(Process Control Block)</h1>\n<p>사람으로 비유하면 주민등록증과 같고 프로세스를 잘 관리하기 위해서 PCB가 필요하다.</p>\n<ul>\n<li>하나의 프로세스에 하나의 PCB가 있다.(PCB는 운영체제의 프로세스 관리 부서에 있음)</li>\n<li><span class=\"clr-note\">Task Control Block(TCB)</span> 라고도 한다.</li>\n<li>프로세스에 대한 모든 정보가 들어있다.</li>\n<li><span class=\"clr-note\">process state(running, ready, waiting, …)</span></li>\n<li><span class=\"clr-note\">PC</span> : 다시 CPU 돌아왔을 때, 그 당시의 PC 값이 필요하다.</li>\n<li><span class=\"clr-note\">registers</span> : CPU가 다른 프로그램 실행하다가 다시 돌아왔을 때, 어디서부터 다시 실행할 건지 알아야 한다.</li>\n<li><span class=\"clr-note\">MMU info (base, limit)</span> : 프로세스 스위칭 할 때마다 값을 바꿔줘야 한다</li>\n<li><span class=\"clr-note\">CPU time</span> : 현재까지 이 프로세스가 CPU 얼마나 사용했는 지</li>\n<li><span class=\"clr-note\">process id</span> : PID 프로세스마다 번호를 붙임</li>\n<li><span class=\"clr-note\">list of open files</span> : 프로세스가 지금 어떤 파일들을 사용하고 있는 지</li>\n<li>등…</li>\n</ul>\n<h1># Queues</h1>\n<h2>Job Queue</h2>\n<p>하드디스크에 비해 메인 메모리 크기는 너무나 작아서 바로 메인 메모리에 못 올라가는 경우가 생긴다. 이 때 잡들은 큐에 줄 서게 되는 데, 이 것은 <code class=\"codetainer\">Job Queue</code> 라고 한다. 큐에 있는 작업들을 어떤 순서대로 실행할 지를 정하는 것을 <code class=\"codetainer\">Job scheduler(Long-term scheduler)</code> 라고 한다.</p>\n<h2>Ready Queue</h2>\n<p>메인 메모리에 올라왔다고 바로 CPU 서비스 받는 것은 아니다. 또 <code class=\"codetainer\">Ready Queue</code>에 줄 서야 한다. 여기의 잡들도 <code class=\"codetainer\">CPU scheduler(short-term scheduler)</code>에 의해 순서가 정해진다.</p>\n<h2>Device Queue</h2>\n<p>I/O, 하드 디스크 사용을 위해서도 <code class=\"codetainer\">Device Queue</code>에 줄 선다. 여기 잡을 관리하는 것은 <code class=\"codetainer\">Device scheduler</code>다.</p>\n<h1># Multiprogramming</h1>\n<h2>Degree of multiprogramming</h2>\n<p>메인 메모리에 몇 개의 프로세스가 올라가 있는 지.</p>\n<h2>I/O-bound vs CPU-bound process</h2>\n<p>프로세스는 크게 <code class=\"codetainer\">I/O-bound process</code>와 <code class=\"codetainer\">CPU-bound process</code>로 나눌 수 있다. I/O-bound는 주로 입출력 작업을 하는 프로세스로 문서편집 프로그램이 대표적이다. CPU-bound는 연산 작업이 많아 주로 CPU를 사용하는 경우며 예시로 슈퍼 컴퓨터 쓰는 일기 예보 프로그램을 들 수 있다.</p>\n<h2>Medium-term scheduler</h2>\n<p>short-term 보다는 적게 long-term 보다는 많게 일어난다. 운영체제는 메인 메모리를 감시하여 메모리에는 올라와있지만 아무 활동을 안하는 프로세스를 디스크에 쫒아낸다. 빈 메모리에는 새로운 프로그램을 올리거나 다른 프로세스에게 할당해준다. 이렇게 프로세스 이미지를 디스크로 쫒아내는 것을 <code class=\"codetainer\">Swapping Out</code> 이라고 하며 반대로 다시 프로세스를 사용하기 위해 메인 메모리에 올리면 <code class=\"codetainer\">Swapping In</code> 이라고 한다. 디스크를 프로세스 이미지를 쫒아내는 목적으로 사용하면 이를 <code class=\"codetainer\">Swap</code> 이라고 한다.</p>\n<h2>Context switching(문맥전환)</h2>\n<p>CPU는 메인 메모리의 여러 프로세스를 동시에 서비스할 수 없어서 Process1을 사용하다가 Process2로 넘어가야한다. 이처럼 프로세스를 전환하는 것을 문맥전환이라고 한다.</p>\n<ul>\n<li><span class=\"clr-note\">Scheduler</span> : 큐에서 기다리는 잡 중에 무엇을 선택해서 작업할 지</li>\n<li><span class=\"clr-note\">Dispatcher</span> : CPU가 프로세스1을 서비스하다가 스케줄러에 의해 프로세스2로 문맥전환을 하려는 상황을 생각해보자. 운영체제는 안전한 문맥전환을 위해 Dispatcher 프로그램을 통해 다음의 2가지 일을 한다. 첫째로, 프로세스1의 현재 상태와 MMU(BASE, LIMIT) 정보를 프로세스1을 위한 PCB에 저장한다. 그 다음, 프로세스2의 정보를 복원하여 이전에 중지된 위치에서 재개할 수 있게 한다.</li>\n<li><span class=\"clr-note\">Context switching overhead</span> : 정보를 저장하고 복원하는 과정에서 오버헤드(부담)가 생기기 마련이다. 컴퓨터는 이를 Context switching overhead라고 부른다.</li>\n</ul>\n",
		"updatedAt": "2020-01-22T18:18:24.702Z",
		"id": "operating-system-6",
		"filename": "computer-science\\operating-system-6.json"
	},
	{
		"layout": "post-content",
		"title": "운영체제 - CPU Scheduling",
		"date": "2019-12-26T00:00:00.000Z",
		"tags": [
			"os"
		],
		"categories": [
			"operating-system"
		],
		"body": "<p>경성대학교 양희재 교수님 강의를 듣고 정리했습니다.<br>\nCPU 스케줄링 용어 및 척도, 알고리즘에 대해 공부했습니다.</p>\n<hr>\n<h1># CPU 스케줄링 관련 용어 정리</h1>\n<h2><span class=\"clr-note\">Preemptive(선점) vs Non-preemptive(비선점)</span></h2>\n<p><code class=\"codetainer\">Preemptive(선점)</code>은 I/O 인터럽트, 프로세스 실행 완료의 경우가 아님에도 CPU 서비스를 받고 있는 프로세스를 강제로 쫒아내 다른 프로세스를 실행하는 것을 말한다. <span class=\"clr-grey\">예) 응급실에서 응급 환자를 우선 치료하는 것</span></p>\n<p><code class=\"codetainer\">Non-preemptive(비선점)</code>은 프로세스 실행 중 I/O 인터럽트가 발생하거나 프로세스 실행 완료되기 전에는 절대 문맥전환 일어나지 않는 것을 말한다. <span class=\"clr-grey\">예) 은행 </span></p>\n<h2><span class=\"clr-note\">Scheduling criteria</span></h2>\n<p>스케줄링의 성능 판단을 위한 척도</p>\n<ul>\n<li>CPU Utilization (CPU 이용률, %): CPU가 얼마나 쉬지 않고 일하는 가?</li>\n<li>Throughput (처리율, jobs/sec) : 시간 당 몇개의 작업을 처리하는 가?</li>\n<li>Turnaround time (반환시간, sec) : 프로세스의 실행 시작 후, 완전히 종료되기까지의 시간. 프로세스는 보통 한번에 실행이 완료되지 않고 문맥전환이 발생한다는 사실을 기억해두고 반환시간을 이해하자.</li>\n<li>Waiting time (대기시간, sec) : CPU 서비스 받기 위해 <code class=\"codetainer\">Ready Queue</code>에서 얼마나 기다렸나?</li>\n<li>Response time (응답시간, sec) : 대화형 시스템에서 가장 중요한 척도로 명령을 내렸을 때, 처음 응답이 나오는 데까지 걸린 시간이다</li>\n</ul>\n<h1># CPU 스케쥴링 알고리즘</h1>\n<h2><span class=\"clr-note\">1. First-Come, First-Served (FCFS)</span></h2>\n<p><img src=\"/assets/images/2019-12-26-img/1.png\" alt=\"FCFS\"><br/>\n<strong>AWT = (0+24+27)/3 = 17 msec</strong><br/>\n<strong>최적은 3 msec!</strong>\n<br/><br/><br/></p>\n<ul>\n<li>먼저 들어온 순서대로 서비스 받는다(단순, 공평)</li>\n<li>Average Waiting Time(AWT) 면에서 좋지 않을 수 있다.</li>\n<li>Convoy Effect (호위효과) : <code class=\"codetainer\">CPU Burst Time</code>이 긴 프로그램이 앞에 있으면 뒤 프로그램이 영향을 크게 받음</li>\n<li>Non-preemptive(비선점)스케줄링이다.</li>\n</ul>\n<h2><span class=\"clr-note\">2. Shortest-Job-First (SJF)</span></h2>\n<p><img src=\"/assets/images/2019-12-26-img/2.png\" alt=\"SJF\"><br/>\n<strong>AWT = (3+16+9+0)/4 = 7 msec</strong>\n<br/><br/><br/>\nAWT 줄이는 면에서는 제일 좋지만 비현실적이다. 실제로 프로세스가 CPU를 얼마나 썼는 지 계산하려면 과거에 CPU를 얼마나 사용했는 지를 기억하고 있어야 하고 미래는 이정도 쓰겠다 계산하여 예측해야한다. 또, 이 예측이 맞는 지 일일이 계산해야한다. 실제로는 문맥 전환이 잦기 때문에 이런 작업은 <span class=\"clr-note\">오버헤드를 증가시킨다.</span></p>\n<p><img src=\"/assets/images/2019-12-26-img/3.png\" alt=\"SJF\"><br/>\n<strong>Preemptive: AWT = (9+0+15+2)/4 = 26/4 = 6.5 msec</strong><br/>\n<strong>Nonpreemptive: 7.75 msec</strong>\n<br/><br/><br/>\nSJF 정책은 Preemptive(선점)과 Non-preemptive(비선점) 두 가지로 만들 수 있고 Preemptive SJF는 <code class=\"codetainer\">Shortest-Remaining-Time-First (최소잔여시간 우선)</code> 라고도 한다.</p>\n<h2><span class=\"clr-note\">3. Priority Scheduling</span></h2>\n<p>정수 값으로 우선 순위를 정하고 우선 순위가 높을 프로세스를 먼저 서비스 해주는 방법이다. 일반적으로 값이 낮을 수록 높은 우선 순위를 가진다.</p>\n<p><img src=\"/assets/images/2019-12-26-img/4.png\" alt=\"SJF\"><br/>\n<strong>AWT = 8.2 msec</strong>\n<br/><br/></p>\n<ol>\n<li>우선순위 정하는 방법<br/></li>\n</ol>\n<p>내부적</p>\n<ul>\n<li>time limit : time limit 짧은 프로세스</li>\n<li>memory requirement: 메모리 작게 차지하는 프로세스</li>\n<li>i/o to CPU burst : I/O 처리 시간 길고 CPU 처리 시간 짧은 프로세스</li>\n</ul>\n<p>외부적</p>\n<ul>\n<li>amount of funds being paid : 돈 많이 낸 프로세스 <span class=\"clr-grey\">예) 컴퓨터를 여러 학과가 쓴다면 등록금 많이 낸 학과가 우선순위</span></li>\n<li>political factors : 정치적 요소 <span class=\"clr-grey\">예) 학생</span></li>\n</ul>\n<ol start=\"2\">\n<li>\n<p>Preemptive, Nonpreemptive 둘다 가능하다.<br/></p>\n</li>\n<li>\n<p>문제점 - starvation (기아) <br/></p>\n</li>\n</ol>\n<p>어떤 프로세스의 우선 순위가 너무 낮아서 아무리 기다려도 CPU 서비스를 받지 못하는 상황을 <code class=\"codetainer\">starvation(기아)</code>라고 한다. 외부에서 그 프로세스보다 우선 순위가 높은 프로세스가 계속 들어올 경우에 발생한다. 해결법으로 <code class=\"codetainer\">againg</code>을 쓰는 데, 이는 운영체제가 주기적으로 Ready Queue를 조사해서 어떤 JOB이 너무 오래 기다리고 있다면 점진적으로 우선순위를 높여주는 방법이다.</p>\n<h2><span class=\"clr-note\">4. Round-Robin</span></h2>\n<ul>\n<li>Time-sharing system (시분할/시공유 시스템)에서 쓴다.</li>\n<li>Time quantum 시간양자 = time slice (10 ~ 100msec) 주기로 메인 메모리의 프로세스를 실행한다. 만약 Time quantum이 100msec면 1초에 100번 문맥전환이 일어난다는 것</li>\n<li>오직 Preemptive scheduling 정책만 있다.</li>\n<li>Time quantum에 의존적이므로 좋은 성능을 위해서는 Time quantum의 크기를 잘 고려해야한다.</li>\n</ul>\n<p><img src=\"/assets/images/2019-12-26-img/5.png\" alt=\"SJF\"><br/></p>\n<p>위와 같이 Time quantum을 무한대로 하면 FCFS 알고리즘과 같아진다. 반대로 0으로 수렴시키면 Process sharing이라고 하는 데, 이는 스위칭이 빈번하게 일어나 프로세스들이 거의 동시에 도는 것처럼 느껴진다. 문맥전환이 빈번하므로 Context switching overhead가 크다.</p>\n<p><img src=\"/assets/images/2019-12-26-img/6.png\" alt=\"SJF\"><br/>\n위와 같이 Time quantum 크기에 따라 Average turnaround time (ATT)가 어떻게 되는 지 계산을 해보라.</p>\n<h2><span class=\"clr-note\">5. Multilevel Queue Scheduling</span></h2>\n<p><img src=\"/assets/images/2019-12-26-img/7.png\" alt=\"SJF\"><br/></p>\n<p>프로세스를 성격에 따라 그룹화하여 여러 개의 큐에 그룹별로 JOB을 줄 세우는 방법이다. 각 큐는 절대적 우선 순위를 가지고 있으며 CPU 시간을 큐에 차등으로 배분한다. 또한, 각 큐는 독립된 스케줄링 정책을 가진다.</p>\n<h2><span class=\"clr-note\">6. Multilevel Feedback Queue Scheduling</span></h2>\n<p><img src=\"/assets/images/2019-12-26-img/8.png\" alt=\"SJF\"><br/></p>\n<p>복수 개의 큐를 둔다는 점은 Multilevel Queue Scheduling와 비슷하나 모든 프로세스가 하나의 입구로 진입한다는 차이점이 있다. 프로세스가 너무 많은 CPU를 사용하면 다른 큐에 줄 세우고 기아 상태가 우려되는 JOB이 있다면 우선순위가 높은 큐에 다시 줄 세우는 방식이다.</p>\n",
		"updatedAt": "2020-01-22T18:18:24.715Z",
		"id": "operating-system-7",
		"filename": "computer-science\\operating-system-7.json"
	},
	{
		"layout": "post-content",
		"title": "운영체제 - 프로세스 생성과 종료 및 쓰레드",
		"date": "2019-12-27T00:00:00.000Z",
		"tags": [
			"os"
		],
		"categories": [
			"operating-system"
		],
		"body": "<p>경성대학교 양희재 교수님 강의를 듣고 정리했습니다.<br>\n프로세스 생성과 종료 및 쓰레드에 대해 공부했습니다.</p>\n<hr>\n<h1># Process Creation(프로세스 생성)</h1>\n<h2>프로세스는 프로세스에 의해 만들어진다!</h2>\n<p>부팅 후 OS가 프로세스를 만들면 그 프로세스에 자식 프로세스가 만들어지고 또 자식의 자식 프로세스가 만들어진다.</p>\n<p><img src=\"/assets/images/2019-12-27-img/1.png\" alt=\"process tree\"><br/></p>\n<ul>\n<li>부모 프로세스(Parent process)</li>\n<li>자식 프로세스(Child process)</li>\n<li>형제 프로세스(Sibling process) : 부모가 같은 프로세스</li>\n<li>프로세스 트리 (process tree) = 족보, 가계도</li>\n</ul>\n<h2>Process Identifier (PID)</h2>\n<p>프로세스의 유니크 번호로 주민등록번호와 비슷한 개념이다. 절대 PID 중복되면 안됀다. cf) PPID : 부모 프로세스의 PID</p>\n<h2>프로세스 생성</h2>\n<ul>\n<li>fork() system call – 부모 프로세스 복사해서 새로운 프로그램을 만든다.</li>\n<li>exec() – 새로 만들어진 프로그램의 실행파일을 메모리로 가져온다.</li>\n</ul>\n<h1># Process Termination(프로세스 종료)</h1>\n<ul>\n<li>exit() system call - 프로세스를 종료시킨다. 해당 프로세스가 가졌던 모든 자원(메모리, 열었던 파일, 프린터같은 입출력 장치 등)을 회수해서 O/S에게 반환한다.</li>\n</ul>\n<h1># 쓰레드(Thread)</h1>\n<p>쓰레드란? <span class=\"clr-note\">프로그램 내부의 흐름, 맥</span>이다.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n    <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">int</span> m = <span class=\"hljs-number\">6</span>;\n    System.out.println(n+m);\n    <span class=\"hljs-keyword\">while</span> (n &lt; m) n++;\n    System.out.println(<span class=\"hljs-string\">\"Bye\"</span>);\n  }\n</code></pre>\n<p>이처럼 하나의 프로그램에는 보통 맥(쓰레드)이 하나 있으나 어떤 프로그램은 맥(쓰레드)이 여러 개가 있다. 하나의 프로그램에 2개 이상의 맥이 있으면 <span class=\"clr-note\">다중 쓰레드 (Multithreads)</span>라고 한다. 맥이 빠른 시간 간격으로 스위칭되기 때문에 여러 맥이 동시에 실행되는 것처럼 보인다.(=<code class=\"codetainer\">Concurrent</code> 동시성) cf) <code class=\"codetainer\">simultaneous</code>는 진짜로 동시에 실행되는 경우를 말하며 CPU가 하나면 일어날 수 없는 일이다.</p>\n<h2>예시</h2>\n<p>Web browser(화면 출력하는 쓰레드 + 데이터 읽어오는 쓰레드), Word processor(화면 출력하는 쓰레드 + 키보드 입력 받는 쓰레드 + 철자/문법\n오류 확인 쓰레드), 음악 연주기, 동영상 플레이어, Eclipse IDE</p>\n<p>우리가 이전 포스팅에서는 <code class=\"codetainer\">Process1 -&gt; Process2 -&gt; Process3…</code>로 프로세스가 스위칭된다고 했지만 사실 운영체제는 다중 스레드를 지원하고 있어서 다음과 같은 흐름을 가진다. <code class=\"codetainer\">Thread1 of Process1 -&gt; Thread2 of Process1 -&gt; Thread1 of Process2 -&gt; Thread2 of Process2 -&gt; Thread3 of Process2 …</code></p>\n<h2>쓰레드 구조</h2>\n<p><img src=\"/assets/images/2019-12-27-img/2.JPG\" alt=\"process\"><br/></p>\n<ul>\n<li>프로세스의 메모리 공간 공유 (code, data)</li>\n<li>프로세스의 자원 공유 (file, i/o, …)</li>\n<li>비공유: 개별적인 PC(program counter), SP(stack pointer), registers, stack</li>\n</ul>\n<p><img src=\"/assets/images/2019-12-27-img/3.JPG\" alt=\"process\"><br/></p>\n<p><strong>vs 프로세스</strong> <br/>\n프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당받는다. 즉, 각 프로세스는 별도의 주소 공간에서 실행되고 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다. 다른 프로세스의 자원에 접근하려면 <code class=\"codetainer\">프로세스 간의 통신(IPC, inter-process communication, 파일, 소켓, 파이프…)</code>을 사용해야 한다.</p>\n<h1># 잠깐 컴퓨터 구조 지식을 채워보자.</h1>\n<h2>Register(레지스터)</h2>\n<p>CPU 내부에서 처리할 명령어나 연산의 중간 결과값 등을 일시적으로 기억하는 임시 기억장소다.</p>\n<ul>\n<li>데이터 레지스터(data register) : CPU가 처리하는 데이터를 임시로 저장</li>\n<li><code class=\"codetainer\">주소 레지스터(address register)</code> : 기억장치를 액세스할 주소를 저장하며 포인터(Pointer)라고도 한다. 스택 포인터(SP, Stack Pointer), 베이스 포인터(BP, Base Pointer), 인덱스 포인터(IX, Index Pointer)가 있다.</li>\n<li>범용 레지스터(GPR) :주소 레지스터 혹은 데이터 레지스터로 사용될 수 있는 레지스터</li>\n</ul>\n<h2>PC</h2>\n<p>프로그램 카운터(Program counter, PC)는 마이크로프로세서(중앙 처리 장치) 내부에 있는 레지스터 중의 하나로서, 다음에 실행될 명령어의 주소를 가지고 있어 실행할 기계어 코드의 위치를 지정한다. 때문에 명령어 포인터라고도 한다.</p>\n<h2>버스</h2>\n<p>CPU, 메모리, I/O 장치 등과 상호 필요한 정보를 교환하기 위해 연결된 공동의 전송선이다.</p>\n",
		"updatedAt": "2020-01-22T18:18:24.728Z",
		"id": "operating-system-8",
		"filename": "computer-science\\operating-system-8.json"
	},
	{
		"layout": "post-content",
		"title": "운영체제 - 프로세스 동기화 1",
		"date": "2020-01-06T00:00:00.000Z",
		"tags": [
			"os"
		],
		"categories": [
			"operating-system"
		],
		"body": "<blockquote>\n<ol>\n<li>프로세스 동기화란?</li>\n<li>임계구역이란?</li>\n<li>세마포란?</li>\n</ol>\n</blockquote>\n<h1>프로세스 동기화(Process Synchronization, Thread Synchronization)</h1>\n<p>프로세스들이 서로 공유하는 데이터에 동시에 접근할 때 순서대로 실행하여 <strong>일관성있는 데이터를 유지</strong>하는 것</p>\n<ul>\n<li>Independent : 프로세스1과 프로세스2가 관계가 없을 때</li>\n<li>Cooperating : 다른 프로세스에게 영향을 미치거나 다른 프로세스로부터 영향을 받을 때</li>\n<li>프로세스 간 통신 : 전자 우편, 파일 전송</li>\n<li>프로세스 간 자원 공유 : 메모리 상의 자료, 데이터베이스 등</li>\n<li>실생활 예 : 명절 기차표 예약, 대학 온라인 수강신청, 실시간 주식 거래</li>\n</ul>\n<h2>프로세스/쓰레드 동기화를 하려면?</h2>\n<ul>\n<li>임계구역 문제 해결(틀린 답이 나오지 않도록)</li>\n<li>프로세스 실행 순서 제어(원하는 대로)</li>\n<li>busy wait 등 비효율성은 제거</li>\n</ul>\n<h2>동기화 도구</h2>\n<ul>\n<li>세마포(Semaphores)</li>\n<li>모니터(Monitors)</li>\n<li>Misc.</li>\n</ul>\n<h2>은행 계좌 예시</h2>\n<p>아래의 코드는 공통 변수(balance)에 대해 동시 업데이트를 수행하여 0이 아닌 잘못된 결과값이 출력된다. 이는 한번에 한 쓰레드만 업데이트하도록 하여 해결할 수 있다. -&gt; <strong>임계구역 문제</strong></p>\n<pre><code class=\"language-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>{\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException </span>{\n  BankAccount b = <span class=\"hljs-keyword\">new</span>\n  BankAccount();\n  Parent p = <span class=\"hljs-keyword\">new</span> Parent(b);\n  Child c = <span class=\"hljs-keyword\">new</span> Child(b);\n  p.start();\n  c.start();\n  p.join();\n  c.join();\n  System.out.println( <span class=\"hljs-string\">\"\\nbalance = \"</span> + b.getBalance());\n  }\n} \n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BankAccount</span> </span>{\n  <span class=\"hljs-keyword\">int</span> balance;\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">deposit</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> amount)</span> </span>{\n    <span class=\"hljs-keyword\">int</span> temp = balance + amount;\n    System.out.print(<span class=\"hljs-string\">\"+\"</span>) \n    balance = temp; <span class=\"hljs-comment\">// 임계구역</span>\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">withdraw</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> amount)</span> </span>{\n    <span class=\"hljs-keyword\">int</span> temp = balance - amount; \n    System.out.print(<span class=\"hljs-string\">\"-\"</span>) \n    balance = temp; <span class=\"hljs-comment\">// 임계구역</span>\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getBalance</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> balance;\n  }\n}\n\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Parent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Thread</span> </span>{\n  BankAccount b;\n  Parent(BankAccount b) {\n    <span class=\"hljs-keyword\">this</span>.b = b;\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">100</span>; i++)\n    b.deposit(<span class=\"hljs-number\">1000</span>);\n  }\n} \n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Child</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Thread</span> </span>{\n  BankAccount b;\n  Child(BankAccount b) {\n    <span class=\"hljs-keyword\">this</span>.b = b;\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">100</span>; i++)\n    b.withdraw(<span class=\"hljs-number\">1000</span>);\n  }\n}\n</code></pre>\n<h1>임계구역 문제(The Critical-Section Problem)</h1>\n<h2>임계구역(Critical Section)</h2>\n<p>여러 개의 스레드로 구성된 시스템에서 각 스레드가 같이 사용하는 변수, 테이블, 파일을 바꾸는 코드 영역을 임계구역이라고 한다. 예) 은행 계좌 예시에서 balance 값을 바꾸는 코드가 임계구역이다.</p>\n<h2>임계구역 문제 해결방법 - 아래 3가지 다 만족해야한다!</h2>\n<ul>\n<li>Mutual exclusion (상호배타): 오직 한 쓰레드만 진입<br/>예) Parent 스레드가 임계구역 실행 중에는 Child 스레드는 임계구역에 들어갈 수 없다.</li>\n<li>Progress (진행): 진입 결정은 유한 시간 내<br/>예) 임계구역에 어떤 스레드가 먼저 진입할지에 대한 결정은 유한 시간 내에 결정되어야 한다.</li>\n<li>Bounded waiting (유한대기): 어느 쓰레드라도<br/>예) 어느 스레드라도 기다리고 있으면 유한한 시간내에 임계구역에 들어갈 수 있다.</li>\n</ul>\n<h1>세마포 (Semaphore)</h1>\n<p>동기화 문제 해결을 위한 소프트웨어 도구로 <span class=\"clr-note\">정수형 변수 + 두 개의 동작 (P, V)</span>으로 이루어져있다.</p>\n<h2>동작</h2>\n<ul>\n<li>P: Proberen (test) → <strong>acquire()</strong></li>\n<li>V: Verhogen (increment) → <strong>release()</strong></li>\n</ul>\n<h2>구조</h2>\n<ul>\n<li>acquire() : 임계구역 전에 호출하여 value가 조건에 맞으면 <strong>프로세스(or 스레드)를 list(큐)에 넣는다.</strong> 큐에 들어간 프로세스는 다른 프로세스에 의해 release()가 호출될 때까지 Block된다. 즉 임계구역을 실행할 수 없게 된다. (Block이 된다 == Ready Queue에 들어가지 못한다)</li>\n<li>release() : value 조건에 맞으면 list에서 <strong>프로세스를 꺼내서 깨운다.</strong> 깨운다는 것은 Ready Queue(cpu 서비스 기다리는 줄)에 넣는 다는 것을 의미한다.</li>\n</ul>\n<pre><code class=\"language-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Semaphore</span> </span>{\n  <span class=\"hljs-keyword\">int</span> value; <span class=\"hljs-comment\">// number of permits</span>\n\n  Semaphore(<span class=\"hljs-keyword\">int</span> value) {\n  ... }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">acquire</span><span class=\"hljs-params\">()</span> </span>{\n    value--;\n    <span class=\"hljs-keyword\">if</span> (value &lt; <span class=\"hljs-number\">0</span>) {\n      add <span class=\"hljs-keyword\">this</span> process/thread to list;\n      block;\n    }\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">release</span><span class=\"hljs-params\">()</span> </span>{\n    value++;\n    <span class=\"hljs-keyword\">if</span> (value &lt;= <span class=\"hljs-number\">0</span>) {\n      remove a process P from list;\n      wakeup P;\n    }\n  }\n}\n\n</code></pre>\n<h2>세마포의 사용 - 상호 배타(Mutual exclusion)</h2>\n<p>sem.value = 1로 두어 임계구역에는 프로세스 한 개만 들어갈 수 있도록 한다.</p>\n<p><img src=\"/assets/images/2020-01-06-img/1.png\" alt=\"process tree\"><br/></p>\n<p>아래 코드는 은행 계좌 예시의 BankAccount 클래스를 수정한 것으로 임계구역 문제를 해결한다.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> java.util.concurrent.Semaphore;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BankAccount</span> </span>{\n  <span class=\"hljs-keyword\">int</span> balance;\n  Semaphore sem;\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">BankAccount</span> <span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.sem = <span class=\"hljs-keyword\">new</span> Semaphore(<span class=\"hljs-number\">1</span>)\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">deposit</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> amount)</span> </span>{\n    <span class=\"hljs-keyword\">try</span> {\n      sem.acquire()\n    } <span class=\"hljs-keyword\">catch</span>(InterruptedException) {}\n    \n    <span class=\"hljs-keyword\">int</span> temp = balance + amount;\n    System.out.print(<span class=\"hljs-string\">\"+\"</span>) \n    balance = temp;\n    sem.release()\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">withdraw</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> amount)</span> </span>{\n    <span class=\"hljs-keyword\">try</span> {\n      sem.acquire()\n    } <span class=\"hljs-keyword\">catch</span>(InterruptedException) {}\n    <span class=\"hljs-keyword\">int</span> temp = balance - amount; \n    System.out.print(<span class=\"hljs-string\">\"-\"</span>) \n    balance = temp;\n    sem.release()\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getBalance</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> balance;\n  }\n}\n\n</code></pre>\n<ol>\n<li>Parent 프로세스가 deposit()을 호출하면 acquire() 메소드가 실행된다. 이는 value를 0으로 만드나 조건이 false라 바로 빠져나와 임계구역을 실행한다.</li>\n<li>문맥 전환에 의해 Child 프로세스의 witdhdraw()가 호출되면 acquire()이 호출된다. value를 -1로 만들어 조건이 true가 되어 Child 프로세스는 큐에 들어가고 Block 된다. 즉, 임계구역을 못 간다.</li>\n<li>Parent 프로세스가 임계구역 실행을 완료한 후 release()를 호출하면 큐의 프로세스 하나를 뺀다. 즉, Child 프로세스를 깨워 Ready Queue로 보낸다.</li>\n</ol>\n<h2>세마포의 사용 - 프로세스 실행 순서 제어(Ordering)</h2>\n<p>CPU 스케줄링 알고리즘에 관련없이 P1에 들어간 S1 코드가 P2의 S2 코드보다 먼저 실행되게 하고 싶을 때? 세마포를 사용하자!</p>\n<p><img src=\"/assets/images/2020-01-06-img/2.png\" alt=\"process tree\"><br/></p>\n<p>항상 입금이 먼저 되게 BankAccount 클래스를 수정해보자.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> java.util.concurrent.Semaphore;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BankAccount</span> </span>{\n  <span class=\"hljs-keyword\">int</span> balance;\n  Semaphore sem;\n  Semaphore sem2;\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">BankAccount</span> <span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.sem = <span class=\"hljs-keyword\">new</span> Semaphore(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-keyword\">this</span>.sem2 = <span class=\"hljs-keyword\">new</span> Semaphore(<span class=\"hljs-number\">0</span>)\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">deposit</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> amount)</span> </span>{\n    <span class=\"hljs-keyword\">try</span> {\n      sem.acquire()\n    } <span class=\"hljs-keyword\">catch</span>(InterruptedException) {}\n    \n    <span class=\"hljs-keyword\">int</span> temp = balance + amount;\n    System.out.print(<span class=\"hljs-string\">\"+\"</span>) \n    balance = temp;\n    sem.release()\n    sem2.release()\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">withdraw</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> amount)</span> </span>{\n    <span class=\"hljs-keyword\">try</span> {\n      sem2.acquire()\n      sem.acquire()      \n    } <span class=\"hljs-keyword\">catch</span>(InterruptedException) {}\n    <span class=\"hljs-keyword\">int</span> temp = balance - amount; \n    System.out.print(<span class=\"hljs-string\">\"-\"</span>) \n    balance = temp;\n    sem.release()\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getBalance</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> balance;\n  }\n}\n\n</code></pre>\n<p>이제 입출금 교대로 되게 BankAccount 클래스를 수정해보자.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> java.util.concurrent.Semaphore;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BankAccount</span> </span>{\n  <span class=\"hljs-keyword\">int</span> balance;\n  Semaphore sem;\n  Semaphore dsem;\n  Semaphore wsem;\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">BankAccount</span> <span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.sem = <span class=\"hljs-keyword\">new</span> Semaphore(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-keyword\">this</span>.dsem = <span class=\"hljs-keyword\">new</span> Semaphore(<span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-keyword\">this</span>.wsem = <span class=\"hljs-keyword\">new</span> Semaphore(<span class=\"hljs-number\">0</span>);\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">deposit</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> amount)</span> </span>{\n    <span class=\"hljs-keyword\">try</span> {\n      sem.acquire();\n    } <span class=\"hljs-keyword\">catch</span>(InterruptedException) {}\n    \n    <span class=\"hljs-keyword\">int</span> temp = balance + amount;\n    System.out.print(<span class=\"hljs-string\">\"+\"</span>) \n    balance = temp;\n    sem.release();\n    wsem.release();\n    <span class=\"hljs-keyword\">try</span> {\n      dsem.acquire();\n    } <span class=\"hljs-keyword\">catch</span>(InterruptedException) {}\n    \n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">withdraw</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> amount)</span> </span>{\n    <span class=\"hljs-keyword\">try</span> {\n      wsem.acquire();     \n      sem.acquire();    \n    } <span class=\"hljs-keyword\">catch</span>(InterruptedException) {}\n    <span class=\"hljs-keyword\">int</span> temp = balance - amount; \n    System.out.print(<span class=\"hljs-string\">\"-\"</span>) \n    balance = temp;\n    sem.release();\n    dsem.release();\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getBalance</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> balance;\n  }\n}\n\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:18:24.737Z",
		"id": "operating-system-9",
		"filename": "computer-science\\operating-system-9.json"
	},
	{
		"layout": "post-content",
		"title": "mssql 쿼리 팁 - 여러 행의 데이터를 한 칼럼에 담기",
		"date": "2018-01-26T00:00:00.000Z",
		"tags": [
			"mssql"
		],
		"category": [
			"sql"
		],
		"body": "<table class=\"half\">\n<thead>\n\t<tr><th>IDX</th><th>NAME </th></tr>\n</thead>\n<tbody>\n\t<tr><td>1</td><td>A</td></tr>\n\t<tr><td>1</td><td>B</td></tr>\n\t<tr><td>1</td><td>C</td></tr>\n\t<tr><td>2</td><td>B</td></tr>\n\t<tr><td>2</td><td>D</td></tr>\n</tbody>\n</table>\n<p>위 테이블을 아래와 같이 출력하고 싶다.</p>\n<table class=\"half\">\n<thead>\n\t<tr><th>IDX</th><th>NAME </th></tr>\n</thead>\n<tbody>\n\t<tr><td>1</td><td>A,B,C</td></tr>\n\t<tr><td>2</td><td>B,D</td></tr>\t\n</tbody>\n</table> \n<p><br/><br/></p>\n<pre><code class=\"language-sql\"><span class=\"hljs-keyword\">SELECT</span> \n\t<span class=\"hljs-keyword\">DISTINCT</span> IDX,\n\t<span class=\"hljs-keyword\">STUFF</span>\n\t( (\n\t\t<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-string\">','</span> + <span class=\"hljs-keyword\">NAME</span> <span class=\"hljs-keyword\">FROM</span> TB_NAME A <span class=\"hljs-keyword\">WHERE</span> A.IDX = B.IDX\n\t\t<span class=\"hljs-keyword\">FOR</span> <span class=\"hljs-keyword\">XML</span> <span class=\"hljs-keyword\">PATH</span>(<span class=\"hljs-string\">''</span>)\n\t),<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">''</span>) <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">NAME</span>\n<span class=\"hljs-keyword\">FROM</span> TB_NAME B\n</code></pre>\n<p>STUFF(STRING,1,1,’’) - 맨 앞 문자 한개 제거</p>\n<h1>STUFF 함수</h1>\n<p><a href=\"https://docs.microsoft.com/ko-kr/sql/t-sql/functions/stuff-transact-sql\">참고페이지</a></p>\n<p>STUFF ( character_expression , start , length , replaceWith_expression )</p>\n<table>\n<thead>\n\t<tr><th>인수</th><th>설명</th></tr>\n</thead>\n<tbody>\n\t<tr><td>start</td><td>삭제 및 삽입 시작 위치, 0, 음수면 NULL이 반환된다.</td></tr>\n\t<tr><td>length</td><td>삭제 할 문자 수 지정, 0, 음수면 NULL이 반환된다.</td></tr>\t\n\t<tr><td>replaceWith_expression </td><td>''이면 아무것도 삽입하지 않고 문자를 제거</td></tr>\t\n</tbody>\n</table>\n",
		"updatedAt": "2020-01-22T18:22:31.380Z",
		"id": "2018-01-26-mssql-tip-1",
		"filename": "db\\2018-01-26-mssql-tip-1.json"
	},
	{
		"layout": "post-content",
		"title": "mssql 쿼리 팁 - group by 없이 카운트하는 방법 & 페이징 처리를 위한 전체 레코드 갯수 구하기",
		"date": "2019-03-07T00:00:00.000Z",
		"tags": [
			"mssql"
		],
		"category": [
			"sql"
		],
		"body": "<p>프로시저 속도 개선하는 과정에서 배웠던 sql 팁으로, group by 없이 칼럼과 함께 갯수를 출력하는 방법과\n페이징 처리에 필요한 전체 레코드 갯수를 구하는 방법에 대한 내용입니다.</p>\n<hr>\n<p>관리자 페이지 유지보수 중에 한 프로시저의 실행속도가 굉장히 느린 것을 발견했다.<br>\n실무자에게 확인해 본 결과 페이지 넘길 때마다 기본 일분은 기다린다는 답을 받았다.<br>\n이 프로시저는 어떤 정보를 프로시저 내에서 페이징 처리를 하여 조회하는 쿼리로 4개의 left outer join 과 복잡한 case 조건의 where 절을 가졌다.<br>\n심지어 left join 되는 테이블은 조건과 그룹 처리를 하는 서브쿼리로 구성되었다.</p>\n<h1>Group by 없이 칼럼과 함께 갯수 출력하기</h1>\n<span class=\"clr-grey\">\n처음에는 left join 때문이라고 생각했으나 아니였다.      \n진짜 원인은 select 절에서 각 그룹의 갯수를 조회하는 서브쿼리의 문제였다.    \n이를 left outer join 으로 바꿔봤지만 해결되지 않았고 Group by 처리하자니 조회할 컬럼 값이 너무 많았다.    \n고민하다가 검색을 통해 좋은 방법을 찾았다.  \n</span>\n<pre><code class=\"language-sql\">count(yy) over (partition by xx)\n</code></pre>\n<p>위는 Group by 없이 컬럼값들과 함께 갯수를 출력할 수 있는 쿼리이다.</p>\n<pre><code class=\"language-sql\">count(seq) over (partition by groupSeq)\n</code></pre>\n<p>이를 참고해 select에서 서브쿼리로 조회하던 방식을 위와 같이 수정했더니 실행시간이 13초에서 3초 정도로 줄었다</p>\n<h1>페이징 처리에 필요한 전체 레코드 갯수를 구하는 방법</h1>\n<p><a href=\"https://m.blog.naver.com/monkeychoi/220629982940\">전체갯수구하기 참고 블로그</a></p>\n<span class=\"clr-grey\">\n하지만 아직 한국인을 만족시킬 속도가 아니였기에 속도를 잡아먹는 또 다른 원인을 찾아보았다.     \n바로 전체 레코드 갯수를 구하는 부분이었다.  페이징처리를 위해서 전체 레코드 갯수를 구하는 건 필수였기에 해당 쿼리를 빼는 거는 불가능했다.   \n</span>\n<p>기존 페이징 쿼리</p>\n<pre><code class=\"language-sql\">;<span class=\"hljs-keyword\">WITH</span> myCTE <span class=\"hljs-keyword\">AS</span>\n(\n\t<span class=\"hljs-keyword\">SELECT</span>\n\t\t<span class=\"hljs-keyword\">COUNT</span>(*) <span class=\"hljs-keyword\">OVER</span>() <span class=\"hljs-keyword\">AS</span> TOTALCNT,\t<span class=\"hljs-comment\">-- 이 쿼리때문에 느려짐</span>\n\t\tROW_NUMBER() <span class=\"hljs-keyword\">OVER</span> (<span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> GroupSeq <span class=\"hljs-keyword\">DESC</span>, seq <span class=\"hljs-keyword\">ASC</span>) <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">ROWNUM</span>,\n\t\t*\n\t<span class=\"hljs-keyword\">FROM</span> DBO.MY_BOARD\n)\n<span class=\"hljs-keyword\">SELECT</span> * <span class=\"hljs-keyword\">FROM</span> myCTE <span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-keyword\">ROWNUM</span> <span class=\"hljs-keyword\">BETWEEN</span> (@I_PAGE <span class=\"hljs-number\">-1</span>) * @I_PAGESIZE) + <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">AND</span> @I_PAGE * @I_PAGESIZE\n</code></pre>\n<p>수정 후 쿼리</p>\n<pre><code class=\"language-sql\">;<span class=\"hljs-keyword\">WITH</span> myCTE <span class=\"hljs-keyword\">AS</span>\n(\n\t<span class=\"hljs-keyword\">SELECT</span>\t\t\n\t\tROW_NUMBER() <span class=\"hljs-keyword\">OVER</span> (<span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> GroupSeq <span class=\"hljs-keyword\">DESC</span>, seq <span class=\"hljs-keyword\">ASC</span>) <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">ROWNUM</span>,\n\t\t*\n\t<span class=\"hljs-keyword\">FROM</span> DBO.MY_BOARD\n)\n<span class=\"hljs-keyword\">SELECT</span> *, (<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">COUNT</span>(*) <span class=\"hljs-keyword\">FROM</span> myCTE) <span class=\"hljs-keyword\">AS</span> TOTALCNT \n<span class=\"hljs-keyword\">FROM</span> myCTE <span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-keyword\">ROWNUM</span> <span class=\"hljs-keyword\">BETWEEN</span> (@I_PAGE <span class=\"hljs-number\">-1</span>) * @I_PAGESIZE) + <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">AND</span> @I_PAGE * @I_PAGESIZE\n</code></pre>\n<p>위와 같이 쿼리를 수정한 결과 실행시간이 3초에서 1초로 줄었다.</p>\n",
		"updatedAt": "2020-01-22T18:24:29.837Z",
		"id": "2019-03-07-mssql-speed-improvement",
		"filename": "db\\2019-03-07-mssql-speed-improvement.json"
	},
	{
		"title": "완전 초보를 위한 가상화 개념",
		"date": "2020-02-19T00:00:00.000Z",
		"tags": null,
		"category": "infra",
		"body": "<p>이 포스팅은 완전 초보를 위한 글로 “무슨 이거까지 설명해?” 라는 생각이 들 수 있어요. 초보가 정리한 거라 오류가 있을 수도 있으니 발견하시면 코멘트 주세요! 😊</p>\n<blockquote>\n<p>Windows 운영체제 위에서 Linux를 사용하기 위해 가상머신을 설치해본 적이 있나요? 주로 VM웨어사가 만든 하이퍼바이저 기반 가상머신 소프트웨어인 VM웨어 워크스테이션을 사용했을 거예요. 이처럼 하이퍼바이저(hypervisor)는 호스트 컴퓨터(여기선 윈도우 환경)에서 리눅스와 같은 다수의 운영체제를 동시에 실행할 수 있는 플랫폼을 제공해줘요.</p>\n</blockquote>\n<p>위 글에서 언급된 <strong>가상화</strong>, <strong>가상머신</strong>, <strong>하이퍼바이저</strong>를 설명할 수 있나요? 있다면, 고수네요. 부럽…🤣 초보인 저와 또 다른 초보를 위해 차근차근 정리해볼게요.</p>\n<br/>\n<hr>\n<br/>\n<h2>1. 가상화(virtualization)</h2>\n<p>가상화는 컴퓨팅 리소스(서버, 데이터베이스, 스토리지, 애플리케이션 등)를 <strong>추상화</strong>하여 다수의 운영 체제 또는 애플리케이션 이미지를 하나의 물리적 서버에서 공유할 수 있도록 하는 프로세스예요. 물리적 컴퓨터 수를 줄일 수 있어 <strong>비용 절감</strong>에 효과적인데요. 대부분의 서버는 단지 용량의 10~15%만 사용하는 데 가상화를 통해 서버 효용률을 70% 이상으로 올릴 수 있기 때문이죠.</p>\n<h2>2. 가상 머신(virtual machine, VM)</h2>\n<p><strong>가상머신</strong>은 컴퓨팅 환경을 소프트웨어로 구현한 것으로 컴퓨터를 <strong>에뮬레이션</strong>하는 소프트웨어예요.\n에뮬레이터 역할을 하는 거죠. 가상 머신은 CPU를 포함한 모든 하드웨어를 가상화하여 가상머신상에서 운영체제나 응용 프로그램을 설치하고 실행할 수 있게 해요.</p>\n<p><span class=\"clr-grey\">에뮬레이션은 한 시스템을 복제하여 그 시스템을 흉내 내는 것으로 가상화 구현에서는 CPU를 포함한 모든 하드웨어를 가상화하는 것을 말해요. 즉, 옵코드가 달라도 실행 가능하죠. PC에서 실행되는 수많은 게임 에뮬레이터도 이런 가상화 기술 중 하나예요. 느리다는 단점이 있긴 하죠.</span></p>\n<h2>3. 하이퍼바이저(hypervisor)</h2>\n<p>호스트 컴퓨터에서 다수의 게스트 OS를 동시에 실행할 수 있게 하는 소프트웨어로 가상화 머신 모니터 또는 가상화 머신 매니저라고 불러요. 하이퍼바이저는 아래와 같이 2가지 타입으로 나눠져요.\n<br/><br/></p>\n<div style=\"text-align:center\">\n<p><img src=\"/assets/images/2020-02-19-img/Hyperviseur.png\" alt=\"process tree\">\n<br/>\n<span class=\"clr-grey\">위키피디아 하이퍼바이저</span></p>\n</div>\n<br/>\n<h3>타입 2 (호스트형)</h3>\n<p>일반 프로그램과 같이 하이퍼바이저는 호스트 OS 위에서 실행돼요. VM 내부에서 동작되는 게스트 OS는 하드웨어에서 3번째 수준으로 실행되는 거죠. 타입1에 비해 오버헤드가 크지만, 게스트 OS 종류에 대한 제약이 없고 데스크탑, 노트북에서도 운영할 수 있어요.</p>\n<BR/>\n<h3>타입 1 (native 또는 bare-metal)</h3>\n<p>타입2와 달리 <strong>호스트 OS 없이</strong> 하드웨어 위에 하이퍼바이저가 바로 위치해요. 별도의 호스트 OS가 없기에 오버헤드가 적고 하드웨어를 직접 제어하기 때문에 효율적으로 리소스를 사용할 수 있어요. 하지만 여러 하드웨어 드라이버를 세팅해야 하므로 설치가 어려워요. VM 내부의 게스트 OS는 하드웨어 위에서 2번째 수준으로 실행되는 거죠.</p>\n<p><span class=\"clr-grey\">네이티브형 하이퍼바이저는 전가상화, 반가상화 방식으로 세분화할 수 있어요. 하이퍼바이저를 통해 가상 머신 내의 게스트 OS가 호스트 시스템을 활용한다는 점을 같지만, 하드웨어와 인터랙션하는 방식에 차이가 있어요.</span></p>\n<p><strong>1) 전가상화(Full-virtualization, Native-virtualization)</strong></p>\n<p>동일한 아키텍처에서 실행되는 게스트 OS를 <strong>수정없이</strong> 그대로 띄워주는데 필요한 하드웨어를 모두 에뮬레이션 하는 형식으로 가상화해요.</p>\n<ul>\n<li>게스트 OS는 하드웨어에 직접 액세스 하는 것으로 인식해요. 사실 이 하드웨어는 하이퍼 바이저가 하드웨어를 에뮬레이션한 복제품이죠. 그래서 게스트 OS는 하드웨어를 자신이 소유하고 있는 걸로 인식해요.</li>\n<li>하이퍼바이저는 게스트 OS가 하드웨어에 주는 명령을 감시해 &quot;하드웨어를 독점&quot;하는 명령이 발생하면 별도로 핸들링 해줘야 해요. 즉, 하이퍼바이저가 게스트 OS와 하드웨어 사이의 <strong>중재자</strong> 역할을 하죠. 그 전에 모든 게스트 OS는 &quot;DOM 0&quot;이라는 관리 머신을 거쳐 하이퍼바이저와 통신해요</li>\n<li>매번 하이퍼바이저와 통신하므로 CPU와 RAM처럼 I/O가 잦은 자원을 컨트롤 하기에는 번거롭기에 아래의 반가상화 방식이 출현했어요.</li>\n</ul>\n<p><strong>2) 반가상화(Para-virtualization)</strong></p>\n<p>하드웨어 에뮬레이션 없이 하이퍼바이저를 통해 하이퍼바이저가 제공하는 API를 이용한 OS를 실행할 수 있는 가상화해요. <strong>게스트 OS를 하이퍼바이저의 API를 이용할 수 있도록 수정</strong>해야해요. 게스트 OS를 수정해야 하므로 좀 번거롭죠.</p>\n<ul>\n<li>게스트 OS는 하드웨어에 하이퍼바이저가 제공한 API를 통해서 엑세스할 수 있어요.</li>\n<li>게스트 OS 입장에선 하드웨어를 소유하고 있지 않다는 것을 알고 있으므로 하드웨어를 독점하는 명령을 하지 않아요.</li>\n<li>각각의 게스트 OS는 필요한 자원을 직접 API를 통해 요청할 수 있으므로 모든 요청을 &quot;DOM 0&quot;가 한꺼번에 처리하여 하드웨어를 제어하는 전가상화 방식에 비해 성능이 좋아요.</li>\n</ul>\n<h2>4. 컨테이너 기반의 가상화(도커) - 추후 추가예정</h2>\n<p>OS레벨 가상화(OperatingSystem-level virtualization)는 OS상에서 같은 OS를 하나 더 사용하는것 처럼 꾸며주는 가상화로 가상화로 인한 속도저하가 없다고 생각해도 무방해요. 특히 OS레벨 가상화는 요즘 가장 핫한 방식인데, Container 를 사용해 SaaS, PaaS를 제공하는 Docker 와, 수많은 Container 관리를 용이하게 해주는 Kubernetes가 그 중심에 있다.</p>\n",
		"updatedAt": "2020-02-19T09:25:58.215Z",
		"id": "2020-02-19-aws",
		"filename": "infra\\2020-02-19-aws.json"
	},
	{
		"title": "AWS 연습하자 1탄 - AWS EC2 인스턴스에 Jenkins 서버 구축하기",
		"date": "2020-02-24T00:00:00.000Z",
		"tags": [
			"aws"
		],
		"category": "infra",
		"body": "<p>AWS 연습하기 1탄에서는 AWS EC2에 인스턴스를 생성하고 Jenkins를 구축하는 과정을 다뤄보겠습니다. AWS에서 제공하는 <a href=\"https://d1.awsstatic.com/Projects/P5505030/aws-project_Jenkins-build-server.pdf\">가이드</a>를 참고하여 실습을 진행했습니다.</p>\n<h1>AWS EC2 인스턴스를 생성하기</h1>\n<p>먼저 <a href=\"https://console.aws.amazon.com/ec2/\">Amazon EC2 console</a>로 이동해서 우측 상단의 Region을 서울로 설정합니다.</p>\n<p>인스턴스 생성에 앞서 키 페어부터 생성하도록 하겠습니다.\n왼쪽 네비게이션 바에서 <strong>네트워크 및 보안 -&gt; 키 페어 -&gt; 키 페어 생성</strong> 을 클릭합니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/1.png\" alt=\"process tree\"></p>\n<p>이름을 입력 후 파일 형식은 pem을 선택하고 키 페어 생성 버튼을 누르면 .pem 파일 형식의 개인키가 다운로드됩니다. 인스턴스 생성, 연결 시 필요하므로 <strong>꼭 잘 보관해두세요</strong>.</p>\n<blockquote>\n<p>윈도우 10은 openssh가 내장되어있어 ssh 명령어를 사용할 수 있습니다. ssh를 지원하지않는 경우라면 ppk를 사용하시면 됩니다.</p>\n</blockquote>\n<p>이제 인스턴스를 생성하겠습니다. <strong>EC2 대시보드 -&gt; 인스턴스 시작 섹션 -&gt; 인스턴스 시작</strong> 을 선택합니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/2.png\" alt=\"process tree\"></p>\n<p><strong>단계 1: AMI 선택</strong> 에서 Amazon Linux AMI 프리 티어 사용 가능한 AMI를 선택하세요.</p>\n<p><img src=\"/assets/images/2020-02-24-img/3.png\" alt=\"process tree\"></p>\n<p><strong>단계 2: 인스턴스 유형 선택</strong> 에서 디폴트로 선택된 t2.micro를 선택한 후 다음: 인스턴스 세부 정보 구성을 선택합니다.</p>\n<p><strong>단계 3: 인스턴스 세부 정보 구성</strong> 에서 디폴트 값을 그대로 사용하겠습니다. 다음:스토리지 추가를 선택합니다.</p>\n<p><strong>단계 4: 스토리지 추가</strong> 에서 프리티어는 최대 30GB의 EBS 범용(SSD) 또는 마그네틱 스토리지를 사용할 수 있습니다. 크기 항목에 8로 되어있는 것을 30으로 수정한 후 다음:태그 추가를 클릭합니다.</p>\n<p><strong>단계 5: 태그 추가</strong> 에서 여러 인스턴스를 태그로 검색이나 그룹짓기 위해 아래와 같이 태그를 추가합니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/4.png\" alt=\"process tree\"></p>\n<p><strong>단계 6: 보안 그룹 구성</strong> 에서 인스턴스 방화벽 역할을 하는 보안 그룹을 설정하겠습니다. 보안그룹에서 인바운드와 아웃바운드 트래픽을 인스턴스 레벨에서 컨트롤할 수 있습니다.</p>\n<p>우선 디폴트로 있는 SSH 유형의 소스를 내 IP로 변경합니다. SSH의 소스를 모든 IPv4(0.0.0.0/0)으로 설정하는 것은 보안상 추천하지않습니다.</p>\n<p>HTTP, HTTPS 유형을 추가하고 소스를 0.0.0.0/0으로 설정합니다. 외부에서 이 서버로 접속하려면 꼭 설정해야합니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/5.png\" alt=\"process tree\"></p>\n<p><strong>검토 및 시작 -&gt; 시작 -&gt; 기존 키 페어 선택 또는 새 키 페어 생성 모달</strong> 을 띄웁니다. 앞에서 키 my-key-pair 이름으로 키 페어를 생성해놨던 것을 여기서 사용할 것입니다. 아래와 같이 선택한 후 인스턴스 시작을 클릭합니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/6.png\" alt=\"process tree\"></p>\n<p>인스턴스 상태가 running이 되면 정상적으로 인스턴스 생성 및 실행이 완료된 것입니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/7.png\" alt=\"process tree\"></p>\n<h1>Jenkins 설치하기</h1>\n<p>방금 생성한 ec2 인스턴스에 젠킨스를 구축하려면 보안 그룹을 편집해야합니다.</p>\n<p>보안그룹에서 HTTPS 프로토콜을 제거하고 사용자 지정 TCP 규칙을 추가하겠습니다.</p>\n<p>스크롤을 오른쪽으로 해보면 보안그룹이 보입니다. 바로 밑의 링크를 클릭하여 인스턴스 보안그룹으로 이동합니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/8.png\" alt=\"process tree\"></p>\n<p>아래 사진과 같이 EC2 인스턴스를 생성할 때 설정한 보안 그룹의 내용을 확인할 수 있습니다. 이제 편집 버튼을 눌러서 수정하겠습니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/9.png\" alt=\"process tree\"></p>\n<p>HTTPS 프로토콜을 삭제하고 사용자 지정 TCP 규칙을 추가 후 포트 범위로는 8080을 입력합니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/10.png\" alt=\"process tree\"></p>\n<p>본격적으로 젠킨스를 설치하고 환경을 설정하겠습니다.</p>\n<p>윈도우10에서 cmd 창을 킨 다음 my-key-pair.pem이 있는 폴더로 이동합니다.</p>\n<pre><code>C:\\Users\\USER&gt;cd C:\\Users\\USER\\github\\project\\devrami-blog\\aws\n</code></pre>\n<p>개인키 my-key-pair.pem을 가지고 인스턴스에 접속하겠습니다.</p>\n<pre><code>ssh -i my-key-pair.pem ec2-user@퍼블릭DNS\n</code></pre>\n<p><strong>Are you sure you want to continue connecting\n(yes/no)?</strong> 가 뜨면 yes를 입력한 후 엔터를 누릅니다.</p>\n<p>아래와 같은 문구를 보게되면 인스턴스에 성공적으로 접속된 것입니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/11.png\" alt=\"process tree\"></p>\n<p>다음과 같이 커맨드를 입력합니다.</p>\n<pre><code>sudo yum update –y\n</code></pre>\n<blockquote>\n<ul>\n<li>Yum은 RPM 기반의 시스템을 위한 자동 업데이트 겸 패키지 설치/제거 도구</li>\n<li>RPM은 원래 레드햇에서 사용되었던 패키지 파일이었지만 현재는 많은 RPM 기반 배포판(RPM 패키지, RPM 패키지 관리 도구)이 사용되고 있습니다. 즉, RPM을 사용하면 각종 소프트웨어의 설치 및 업데이트를 굉장히 편하게 할 수 있습니다.</li>\n</ul>\n</blockquote>\n<p>AWS는 기본적으로 OS 설치시 타임존이 UTC로 맞춰져있어서 한국 시간에 맞추기위해 다음 작업을 추가로 하겠습니다.</p>\n<pre><code># 날짜확인\ndate\n\nsudo rm /etc/localtime\nsudo ln -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime\n\n</code></pre>\n<p>yum이 젠킨스 설치 위치를 알 수 있도록 젠킨스 레파지토리를 추가합니다.</p>\n<pre><code>sudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo\n</code></pre>\n<p>패키지를 설치할 수 있게 젠킨스 키 파일을 rpm에 추가한다.</p>\n<pre><code> sudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key\n</code></pre>\n<blockquote>\n<p>rpm 포맷은 전자서명을 첨부하여 위변조 여부를 확인할 수 있습니다. rpm 패키지가 위변조 되면 에러가 발생합니다. 다른 제조사가 서명했는데 서명자의 검증용 키가 없을 경우도 검증이 실패하게 되는 데 이럴 경우 --import 옵션을 이용하여 검증용 키를 rpm에 추가하면 됩니다.</p>\n</blockquote>\n<p>젠킨스를 설치하겠습니다.</p>\n<pre><code>sudo yum install jenkins -y\n</code></pre>\n<p>젠킨스 서버를 시작합니다.</p>\n<pre><code> sudo service jenkins start\n</code></pre>\n<blockquote>\n<p>다음과 같은 에러가 발생하면 자바 버전 문제로 자바8로 재 설치한 후 다시 서버를 시작하시면 됩니다.<br>\n<strong>Starting jenkins (via systemctl):  Job for jenkins.service failed because the control process exited with error code. See “systemctl status jenkins.service” and “journalctl -xe” for details.</strong></p>\n<pre><code>sudo yum remove java-1.7.0-openjdk\nsudo yum install java-1.8.0\n</code></pre>\n</blockquote>\n<h1>Jenkins 설정하기</h1>\n<p>브라우저에서 <a href=\"http://xn--DNS-z18m89ooo1b:8080\">http://퍼블릭DNS:8080</a> 로 접속하면 아래와 같은 화면이 보일 것입니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/12.png\" alt=\"process tree\"></p>\n<p>근데 매번 8080 포트 입력하기 귀찮죠? Nginx를 프록시로 사용해서 80포트로 들어오면 8080으로 연결되게 추가 설정을 진행하도록 하겠습니다.</p>\n<p>우선 Nginx를 설치해줍니다. nginx는 yum으로 설치할 수 없어서 아래처럼 설치해줍니다.</p>\n<pre><code>sudo amazon-linux-extras install nginx1\n</code></pre>\n<p>nginx 서비스를 시작합니다.</p>\n<pre><code>sudo service nginx start\n</code></pre>\n<p>이제 포트없이 퍼블릭 도메인으로 들어가보면 아래 화면처럼 보일 것입니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/17.png\" alt=\"process tree\"></p>\n<p>자! 그럼 젠킨스 서버로 프록시하기위해 추가 설정을 하도록하겠습니다.</p>\n<p>nginx 설정 파일에서 location에 proxy_pass 정보를 추가하겠습니다.</p>\n<pre><code>sudo vi /etc/nginx/nginx.conf\n</code></pre>\n<p>다음과 같이 입력하면됩니다.\n<img src=\"/assets/images/2020-02-24-img/18.png\" alt=\"process tree\"></p>\n<p>저장 후 nginx 서비스를 재시작하면 처음에 8080포트로 들어갔을 때 봤던 화면이 포트없이 접속해도 잘 보이는 것을 확인할 수 있을 것입니다.</p>\n<pre><code>sudo service nginx restart\n</code></pre>\n<p>이제 젠킨스 내부에서 설정을 해보겠습니다.</p>\n<p>접속을 위해 <strong>/var/lib/jenkins/secrets/initialAdminPassword</strong> 에 있는 패스워드를 찾습니다.</p>\n<pre><code> sudo cat /var/lib/jenkins/secrets/initialAdminPassword\n</code></pre>\n<p>위 커맨드로 나오는 내용을 복사하여 Administrator password에 입력한 후 continue 버튼을 클릭합니다.</p>\n<p>Customize Jenkins 페이지에서 <strong>Install suggested plugins</strong> 를 선택합니다. 플러그인 설치가 완료되면 Create First Admin User 페이지에서 관리자 계정을 생성합니다. 여기까지 완료했으면 이 페이지를 볼 수 있을 것입니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/13.png\" alt=\"process tree\"></p>\n<p><a href=\"/post/2020-02-25-how-to-use-aws\">AWS 연습하자 2탄 - Jenkins와 Github 연동하기</a> 로 이어집니다.</p>\n",
		"updatedAt": "2020-02-26T08:08:43.586Z",
		"id": "2020-02-24-how-to-use-aws",
		"filename": "infra\\2020-02-24-how-to-use-aws.json"
	},
	{
		"title": "AWS 연습하자 2탄 - Jenkins와 Github 연동",
		"date": "2020-02-25T00:00:00.000Z",
		"tags": [
			"aws"
		],
		"category": "infra",
		"body": "<blockquote>\n<p>AWS 연습하자 시리즈</p>\n<ul>\n<li><a href=\"/post/2020-02-24-how-to-use-aws\">AWS 연습하자 1탄 - AWS EC2 인스턴스에 Jenkins 서버 구축하기</a></li>\n</ul>\n</blockquote>\n<p>AWS 연습하기 2탄에서는 추가 설정과 Jenkins와 Github을 연동하는 과정을 다뤄보겠습니다.</p>\n<h1>Git 설치</h1>\n<p>연동에 앞서 Jenkins 서버에 git을 설치해두겠습니다.</p>\n<pre><code>sudo yum install git\n</code></pre>\n<h1>SSH 키 생성 및 등록</h1>\n<p>젠킨스와 깃허브를 연동하는 작업은 <a href=\"https://jojoldu.tistory.com/291?category=777282\">기억보다 기록을 - Jenkins로 Beanstalk + Multi Module 배포하기 - Jenkins와 Github 연동하기</a>를 99% 참고하여 진행했습니다.</p>\n<p>ssh 키를 생성합니다.</p>\n<pre><code>sudo ssh-keygen -t rsa -f id_rsa\n</code></pre>\n<p>아래 커맨드를 이용해 id_rsa 내용을 확인한 후 복사해둡니다.</p>\n<pre><code>sudo cat id_rsa\n</code></pre>\n<p>그 다음 다시 젠킨스 페이지로 돌아와서 <strong>Credentials -&gt; System -&gt; Global credentials -&gt; Add Credentials</strong>를 선택합니다.</p>\n<p>아래와 같이 설정한 후 저장합니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/19.png\" alt=\"process tree\"></p>\n<p>이제 공개키(id_rsa.pub)를 Github에 등록하겠습니다.\nJenkins로 관리할 Github 프로젝트로 이동한 뒤 <strong>Settings탭 -&gt; Deploy keys -&gt; Add deploy key</strong> 를 차례로 클릭합니다.</p>\n<p>Title에는 Jenkins 입력, key에는 아래 커맨드를 실행한 결과 값을 붙여넣습니다.</p>\n<pre><code>sudo cat id_rsa.pub\n</code></pre>\n<p>Allow write access는 체크 해제한 후 Add Key를 클릭합니다.</p>\n<p>이 작업만 해도 Build, Test, Code Clone 등을 다 할 수 있긴 합니다. PUSH 발생시에도 젠킨스가 PUSH 이벤트를 받을 수 있도록 Webhooks를 추가하겠습니다.</p>\n<p><strong>Settings 탭 -&gt; Webhooks -&gt; Add webhook</strong> 을 클릭합니다.</p>\n<p>Payload URL에 <a href=\"http://xn--Jenkins-2y31a954bf54a/github-webhook/\">http://Jenkins도메인/github-webhook/</a> 을 입력하고 Content type은 <strong>application/json</strong> 으로 변경해줍니다. Add webhook을 클릭하여 추가를 완료합니다.</p>\n<h1>Nodejs 설정</h1>\n<p>제가 연결할 프로젝트는 express 프레임워크가 적용된 nodejs 서버입니다. 우선 Node.js 툴을 설치해줘야합니다. <strong>메인페이지 -&gt; Jenkins 관리 -&gt; 플러그인 관리 -&gt; 설치가능 탭</strong> 을 클릭한 후 검색 창에 <strong>nodejs</strong> 라고 입력합니다. 리스트에서 NodeJS Plugin이 보이면 체크박스 선택 후 재시작없이 설치하기를 클릭합니다. 설치가 완료되면 다시 메인 페이지로 돌아갑니다.</p>\n<p>이제 Node.js 툴 설정을 진행하겠습니다. <strong>Jenkins 관리 -&gt; Global Tool Confituration</strong> 을 선택합니다.</p>\n<p><strong>NodeJS 섹션 -&gt; NodeJS installations…</strong> 를 클릭합니다.</p>\n<p>아래와 같이 입력한 후 저장합니다.\n저는 로컬에서 노드 버전이 12.14.1 여서 다음과 같이 선택했습니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/16.png\" alt=\"process tree\"></p>\n<h1>Item 생성 및 파이프라인 작성</h1>\n<p><strong>새로운 Item -&gt; 적당한 이름 입력 -&gt; Pipeline</strong> 선택 후 OK를 눌러줍니다.</p>\n<p>Build Triggers가 Github hook과 연동되도록 다음과 같이 선택합니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/20.png\" alt=\"process tree\"></p>\n<p>Pipeline 섹션에 Definition은 Pipeline script로 한 후 아래와 같이 입력하고 저장합니다. Pipeline 스크립트를 jenkinsfile로 관리하는 것은 뒤에서 다루도록 하겠습니다.</p>\n<pre><code>pipeline {\n   agent any\n\n   tools {\n      nodejs &quot;node&quot;\n   }\n\n   stages {\n      stage('Build') {\n         steps {\n            git 'https://github.com/devgaram/express-project-blog.git'\n         }\n      }\n      \n      stage('Install dependencies') {\n          steps {\n              sh 'npm install -g yarn'\n              sh 'yarn install'\n          }\n      }\n      stage('Test') {\n          steps {\n              echo 'test..'\n              // yarn test\n          }\n      }\n      stage('Upload S3') {\n          steps {\n              echo 'upload s3'\n          }\n      }\n      stage('Deploy') {\n          steps {\n              echo 'deploy'\n          }\n      }\n   }\n   post {\n        success {\n            echo 'successed'\n        }\n        failure {\n            echo 'failed'\n        }\n   }\n}\n\n</code></pre>\n<p>생성된 아이템으로 이동한 후 Build Now 버튼을 눌렀을 때 에러없이 완료되면 Github 연동은 성공적으로 된 것입니다.</p>\n<p><a href=\"/post/2020-02-26-how-to-use-aws\">AWS 연습하자 3탄 - Jenkins와 S3 버킷 &amp; AWS codeDeploy 연동으로 배포하기</a> 으로 이어집니다.</p>\n<p><a href=\"https://medium.com/@gustavo.guss/jenkins-starting-with-pipeline-doing-a-node-js-test-72c6057b67d4\">참고 블로그</a></p>\n",
		"updatedAt": "2020-02-26T10:05:54.100Z",
		"id": "2020-02-25-how-to-use-aws",
		"filename": "infra\\2020-02-25-how-to-use-aws.json"
	},
	{
		"title": "AWS 연습하자 3탄 - Jenkins와 S3 버킷 & AWS codeDeploy 연동으로 배포하기",
		"date": "2020-02-26T00:00:00.000Z",
		"tags": [
			"aws"
		],
		"category": "infra",
		"body": "<blockquote>\n<p>AWS 연습하자 시리즈</p>\n<ul>\n<li><a href=\"/post/2020-02-24-how-to-use-aws\">AWS 연습하자 1탄 - AWS EC2 인스턴스에 Jenkins 서버 구축하기</a></li>\n<li><a href=\"/post/2020-02-25-how-to-use-aws\">AWS 연습하자 2탄 - Jenkins와 Github 연동</a></li>\n</ul>\n</blockquote>\n<p>AWS 연습하기 3탄에서는 AWS S3와 Aws Codedeploy로 자동 배포 환경을 구축하는 과정을 다루겠습니다.</p>\n<h1>배포 서버인 EC2 인스턴스 생성</h1>\n<p><a href=\"/post/2020-02-24-how-to-use-aws\">AWS 연습하자 1탄</a>의 AWS EC2 인스턴스 생성하기 부분을 진행하여 인스턴스를 생성하고 오세요! 저는 Name 태그에 blog-server로 인스턴스를 생성했습니다.</p>\n<h1>AWS Code Deploy 계정 생성</h1>\n<p>여기서 생성한 계정을 가지고 Jenkins와 blog-server 인스턴스에서 설정을 진행할 것입니다.</p>\n<p><strong><a href=\"https://console.aws.amazon.com/iam/\">AWS IAM 콘솔</a> -&gt; 사용자 탭 -&gt; 사용자 추가</strong> 를 클릭합니다.</p>\n<p>사용자 이름을 입력하고 액세스 유형은 프로그래밍 방식 액세스를 선택합니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/29.png\" alt=\"process tree\"></p>\n<p>해당 계정이 사용할 수 있는 정책으로는 CodeDeploy와 S3 권한을 할당 받겠습니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/30.png\" alt=\"process tree\"></p>\n<p><img src=\"/assets/images/2020-02-24-img/31.png\" alt=\"process tree\"></p>\n<p><img src=\"/assets/images/2020-02-24-img/32.png\" alt=\"process tree\"></p>\n<p>.csv 다운로드 버튼을 클릭하여 비밀키를 잘 보관해둡니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/33.png\" alt=\"process tree\"></p>\n<h1>AWS S3 버킷 생성</h1>\n<p><strong><a href=\"https://s3.console.aws.amazon.com/s3/\">AWS S3 콘솔</a> -&gt; 버킷 만들기</strong> 를 클릭합니다.</p>\n<p>버킷 이름이 blog-server-bucket으로 하고 리전이 서울인지 확인합니다. 추가 옵션 없이 다음을 계속하여 버킷 생성을 완료합니다.</p>\n<h1>IAM Role 생성</h1>\n<p>blog-server EC2와 CodeDeploy에게 신뢰할 수 있는 권한을 설정하여 젠킨스가 정상적으로 배포할 수 있게 하겠습니다.</p>\n<blockquote>\n<p>CodeDeploy가 EC2 접근할 수 있도록 설정하는 것!</p>\n</blockquote>\n<p><strong><a href=\"https://console.aws.amazon.com/iam/\">AWS IAM 콘솔</a> -&gt; 역할 -&gt; 역할 만들기</strong> 를 클릭합니다.</p>\n<p>AWS 서비스를 누른 후 이 역할을 사용할 서비스 선택에서 <strong>EC2</strong>를 선택합니다. 권한 정책으로 <strong>AmazonEC2RoleforAWSCodeDeploy</strong> 를 체크한 후 다음: 태그로 넘어갑니다. 태그는 건너 뛰고 역할 이름은 <strong>blog-server-EC2CodeDeployRole</strong>을 입력한 후 역할 만들기를 클릭하겠습니다.</p>\n<p>지금 만든 역할은 blog-server EC2에 IAM 역할로 설정할 것입니다.</p>\n<p>마찬가지로 CodeDeploy도 역할을 생성하겠습니다.</p>\n<p><strong><a href=\"https://console.aws.amazon.com/iam/\">AWS IAM 콘솔</a> -&gt; 역할 -&gt; 역할 만들기</strong> 를 클릭합니다.</p>\n<p>AWS 서비스를 누른 후 이 역할을 사용할 서비스 선택에서 <strong>CodeDeploy</strong>를 선택합니다. 사용 사례 선택 섹션에서도 <strong>CodeDeploy</strong>를 선택합니다. 권한 정책으로 <strong>AWSCodeDeployRole</strong> 를 하나이므로 그냥 확인하고 다음: 태그로 넘어갑니다. 태그는 건너 뛰고 역할 이름은 <strong>blog-server-CodeDeployServiceRole</strong>을 입력한 후 역할 만들기를 클릭하겠습니다.</p>\n<h1>EC2에 AWS 역할 적용하기</h1>\n<p>EC2 콘솔로 이동한 후 아래와 같이 IAM 역할 연결/바꾸기 를 선택합니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/34.png\" alt=\"process tree\"></p>\n<p>아까만든 <strong>blog-server-EC2CodeDeployRole</strong> 을 선택한 후 적용합니다.</p>\n<h1>EC2 AWS CodeDeploy Agent 설치 및 설정</h1>\n<p>이제 blog-server 인스턴스에 CodeDeploy Agent를 설치하겠습니다.</p>\n<p>인스턴스로 접속한 후 패키지 업데이트를 수행합니다.</p>\n<pre><code>ssh -i my-key-pair.pem ec2-user@퍼블릭DNS\nsudo yum update -y\n</code></pre>\n<p>aws cli를 설치하겠습니다.</p>\n<pre><code>sudo yum install awscli\n</code></pre>\n<p>에이전트 설치 후 aws 설정을 하겠습니다.</p>\n<pre><code>sudo aws configure\n</code></pre>\n<p>AWS Access Key ID, AWS Secret Acecess Key ID는 사용자 생성할 때 받은 CSV를 보고 입력합니다.</p>\n<p>추가 정보는 아래와 같이 입력 후 엔터칩니다.\nDefault region name: ap-northeast-2\nDefault output format: json</p>\n<p>계속 설치를 진행하겠습니다.</p>\n<pre><code>cd /home/ec2-user\n\n# agent 파일 다운로드\naws s3 cp s3://aws-codedeploy-ap-northeast-2/latest/install . --region ap-northeast-2\n\n# 실행권한 추가\nchmod +x ./install\n\n# 설치 진행\nsudo ./install auto\n\n# agent가 실행 중인지 확인 PID가 나오면 정상적으로 실행 중인 상태입니다.\nsudo service codedeploy-agent status\n</code></pre>\n<p>만약 <strong>sudo ./install auto</strong> 커맨드 실행 결과 <strong>/usr/bin/env: ruby: No such file or directory</strong>가 나온다면 루비를 설치해야합니다. 아래와 같이 실행 후 다시 설치를 진행합니다.</p>\n<pre><code>sudo yum install ruby -y\n</code></pre>\n<p>추가로 재 부팅시 자동으로 code deploy agent가 실행될 수 있도록 스크립트를 생성하고 권한을 주겠습니다.</p>\n<pre><code># 아래 스크립트를 입력합니다.\nsudo vim /etc/init.d/codedeploy-startup.sh\n\nsudo chmod +x /etc/init.d/codedeploy-startup.sh\n</code></pre>\n<blockquote>\n<p>#!/bin/bash<br>\necho ‘Starting codedeploy-agent’<br>\nsudo service codedeploy-agent restart</p>\n</blockquote>\n<h1>nginx와 Docker로 무중단 배포하기</h1>\n<h2>1) 도커, 도커컴포즈 설치 및 프로젝트 파일 생성</h2>\n<p>도커 컨테이너 위에서 애플리케이션을 구동하기위해서 ec2에 도커와 도커컴포즈를 설치합니다.</p>\n<pre><code>sudo yum install docker\n\n# 도커 컴포즈 다운로드\n$ sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.25.4/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose\n\n# 실행 권한 주기\n$ sudo chmod +x /usr/local/bin/docker-compose\n\n# 설치 완료됐는 지 확인하기\n$ docker-compose --version\n\n# bash: docker-compose: command not found 문구가 나오면 아래 커맨드 실행하기\n$ sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose\n</code></pre>\n<p>잠시 배포에 대해 짚고 넘어가겠습니다. 뒤에서 실습을 진행하겠지만, AWS Code Deploy에서 배포한 파일은 /home/ec2-user/build 에 복사되게 할 것입니다.</p>\n<p>배포 후 /home/ec2-user/build 이 폴더에는 Dockerfile 과 docker-compose.yml 파일이 존재할것이고 이를 이용해 컨테이너에 서버를 올릴 것입니다.</p>\n<p>혹시 docker ps 해봤더니 <strong>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</strong> 에러가 떴다면 docker service가 실행이 안된 것이므로 아래와 같이 명령을 내리겠습니다. <a href=\"https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user\">도커 설치 가이드</a>를 참고했습니다.</p>\n<pre><code>sudo groupadd docker\nsudo usermod -aG docker $USER\nsudo newgrp docker\n\n# 아래 커맨드 실행 결과 상태가 active여야 정상적인 것!\nsudo systemctl status docker\nsudo systemctl start docker\nsudo systemctl enable docker\n</code></pre>\n<p>이제 프로젝트에 Dockerfile과 docker-compose 파일을 작성하겠습니다.</p>\n<blockquote>\n<p>도커에 대해 기본지식이 필요합니다. 나중에 도커 관련 포스팅도 작성하겠습니다…!</p>\n</blockquote>\n<p>프로젝트 루트에 다음과 같이 Dockerfile을 작성합니다.</p>\n<pre><code># 로컬과 같은 버전\nFROM node:12.14\n\n# 도커 이미지 만든 사람\nLABEL maintainer=&quot;joingaram@gmail.com&quot;\n\n# 3000포트로 도커 데몬에 연결\nEXPOSE 3000\n\n# 작업 디렉토리 &amp; 자동으로 작업 디렉토리로 현재 위치 변경\nWORKDIR /usr/src/app\n\nCOPY package.json .\nCOPY yarn.lock .\nRUN yarn cache clean &amp; yarn install --network-timeout 100000\nCOPY . .\n\nCMD [&quot;yarn&quot;, &quot;start&quot;]\n\n</code></pre>\n<p>프로젝트 루트에 docker-compose.blue.yml 파일과 docker-compose.green.yml 파일을 생성한 후 아래와 같이 입력합니다. 포트만 3001, 3002로 다릅니다.</p>\n<p>docker-compose.blue.yml</p>\n<pre><code>version: &quot;3.7&quot;\nservices: \n  blog-server:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    volumes: \n      - .:/usr/src/app\n    ports:\n      - &quot;3001:3000&quot; \n</code></pre>\n<p>docker-compose.green.yml</p>\n<pre><code>version: &quot;3.7&quot;\nservices: \n  blog-server:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    volumes: \n      - .:/usr/src/app\n    ports:\n      - &quot;3002:3000&quot;  \n</code></pre>\n<h2>2) nginx로 로드밸런싱 설정</h2>\n<p>우선 nginx를 설치합니다. 프록시 서버로 두 개의 도커 컨테이너를 로드밸런싱하는 역할을 담당할 것입니다.</p>\n<pre><code>sudo amazon-linux-extras install nginx1\nsudo service nginx start\n\n# 잘 실행되었는지 확인\nps -ef | grep nginx\n</code></pre>\n<p>이제 <strong>nginx 설정 파일 수정</strong> 작업을 하겠습니다.</p>\n<pre><code>sudo vi /etc/nginx/nginx.conf\n</code></pre>\n<p>다음과 같이 수정한 후 저장합니다.</p>\n<pre><code># Load Balancing\nupstream blog-server {\n  least_conn;\n  server 127.0.0.1:3001 weight=5 max_fails=3 fail_timeout=10s;\n  server 127.0.0.1:3002 weight=10 max_fails=3 fail_timeout=10s;\n}\n\nserver {\n  listen 80;\n  server_name 서버 아이피; # 세미콜론 붙여주셔야 합니다.\n  location / {\n    proxy_pass http://blog-server;\n  }\n}\n</code></pre>\n<p>잘 설정했는 지 확인하고 nginx를 재시작합니다.</p>\n<pre><code>\nsudo nginx -t\nsudo service nginx restart\n</code></pre>\n<blockquote>\n<p><a href=\"https://opentutorials.org/module/384/4328\">생활코딩nginx</a></p>\n<ul>\n<li>Nginx는 4개의 로드밸런싱 메서드를 제공합니다. 그중  least_conn 은 연결이 가장 작은 서버로 요청을 보냅니다.</li>\n<li>weight=n : 업스트림 서버의 비중을 나타냅니다. 이 값을 2로 설정하면 그렇지 않은 서버에 비해 두배 더 자주 선택됩니다.</li>\n<li>max_fails=n : n으로 지정한 횟수만큼 실패가 일어나면 서버가 죽은 것으로 간주합니다.</li>\n<li>fail_timeout=n : max_fails가 지정된 상태에서 이 값이 설정만큼 서버가 응답하지 않으면 죽은 것으로 간주합니다.</li>\n</ul>\n</blockquote>\n<h1>Jenkins 배포 설정</h1>\n<p>우선 Pipeline AWS STEP과 AWS Codedeploy 플러그인을 설치해줍니다. Pipeline AWS STEP은 S3로 소스 전송할 때, AWS Codedeploy로는 S3 버킷의 코드를 인스턴스에 배포하도록 설정하겠습니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/22.png\" alt=\"process tree\"></p>\n<p><img src=\"/assets/images/2020-02-24-img/25.png\" alt=\"process tree\"></p>\n<p>각 플러그인 사용방법</p>\n<ul>\n<li><a href=\"https://github.com/jenkinsci/pipeline-aws-plugin#deployapi\">Pipeline AWS STEP</a></li>\n<li><a href=\"https://github.com/jenkinsci/aws-codedeploy-plugin\">AWS Codedeploy</a></li>\n</ul>\n<h2>1) S3 UPLOAD 작성</h2>\n<p>먼저 AWS 접근을 위한 설정을 하겠습니다.</p>\n<p><strong>젠킨스 메인 -&gt; Credentials -&gt; System -&gt; Global credentials -&gt; Add Credentials</strong> 를 차례로 클릭합니다.</p>\n<p>Kind는 AWS Credentials를 선택하고 Access key와 secret key는 위에서 생성한 csv 파일을 보고 입력합니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/23.png\" alt=\"process tree\"></p>\n<p>OK 클릭 후 클릭해보면 아래와 같이 ID를 볼수 있습니다. 파이프라인 작성 시에 사용해야하므로 저장해둡니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/24.png\" alt=\"process tree\"></p>\n<p>AWS 연습하기 2탄에서 작업했던 파이프라인을 아래와 같이 수정합니다.</p>\n<ul>\n<li>credentials에는 위에서 복사한 ID를 입력합니다.</li>\n<li>Bucket에는 아까 생성한 S3 버킷 입력을 입력합니다.</li>\n</ul>\n<pre><code>pipeline {\n   agent any\n\n   environment {\n       S3PATH = &quot;${env.JOB_NAME}&quot;\n   }\n   tools {\n      nodejs &quot;node&quot;\n   }\n\n   stages {\n      stage('Build') {\n         steps {\n            git 'https://github.com/devgaram/express-project-blog.git'\n         }\n      }\n      \n      stage('Install dependencies') {\n          steps {\n              sh 'npm install -g yarn'\n              sh 'yarn install'\n          }\n      }\n      stage('Test') {\n          steps {\n              echo 'test..'\n              // yarn test\n          }\n      }\n      stage('Upload S3') {\n          steps {\n              echo 'Upload S3'\n              withAWS(credentials: '667cec8d-baa7-497f-b2db-2d424c121a22') {\n                s3Upload(file: '.', bucket: 'blog-server-bucket', path: &quot;${S3PATH}&quot;, excludePathPattern: '**/node_modules/**, **/.git/**')\n              }\n          }\n      }\n      stage('Deploy') {\n          steps {\n              echo 'deploy'\n          }\n      }\n   }\n   post {\n        success {\n            echo 'successed'\n        }\n        failure {\n            echo 'failed'\n        }\n   }\n}\n</code></pre>\n<p><strong>Apply -&gt; 저장 -&gt; Build Now</strong> 를 클릭하면 잘 실행될 것입니다.</p>\n<h2>2) AWS CodeDeploy 설정</h2>\n<p><strong>Jenkins 메인 -&gt; blog-server 아이템 -&gt; Pipeline Syntax -&gt; Snippet Generator</strong>를 선택합니다.</p>\n<p>Snippet Generators는 파이프라인 스크립트 생성에 도움을 주는 녀석입니다. 얘를 이용해 AWS CodeDeploy를 이용한 배포를 설정하겠습니다.</p>\n<p><strong>Steps 섹션 -&gt; Sample Step - step:General Build Step 선택 -&gt; Build Step - Deploy an application to AWS CodeDeploy 선택</strong> 을 진행합니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/26.png\" alt=\"process tree\"></p>\n<ul>\n<li>AWS CodeDeploy Application Name: EC2 인스턴스 이름</li>\n<li>AWS CodeDeploy Deployment Group: CodeDeploy 그룹 명</li>\n<li>AWS CodeDeploy Deployment Config: 배포 환경, 여기선 CodeDeployDefault.OneAtATime</li>\n<li>AWS Region: AP_NORTHEAST_2</li>\n<li>S3 Bucket: S3 버킷 이름</li>\n</ul>\n<p>Use Access/Secret keys 라디오 버튼을 선택하여 csv로 저장했던 내용을 입력해줍니다.</p>\n<p>마지막으로 Generate Pipeline Script 버튼을 클릭하면 나오는 텍스트를 복사합니다.</p>\n<p><img src=\"/assets/images/2020-02-24-img/27.png\" alt=\"process tree\"></p>\n<p>최종적으로 파이프라인을 아래와 같이 구성됩니다.</p>\n<pre><code>pipeline {\n   agent any\n\n   environment {\n       S3PATH = &quot;${env.JOB_NAME}&quot;\n       AWS_SECRET_ACCESS_KEY = &quot;${env.AWS_SECRET_ACCESS_KEY}&quot;\n   }\n   tools {\n      nodejs &quot;node&quot;\n   }\n\n   stages {\n      stage('Build') {\n         steps {\n            git 'https://github.com/devgaram/express-project-blog.git'\n         }\n      }\n      \n      stage('Install dependencies') {\n          steps {\n              sh 'npm install -g yarn'\n              sh 'yarn install'\n          }\n      }\n      stage('Test') {\n          steps {\n              echo 'test..'\n              // yarn test\n          }\n      }\n      stage('Upload S3') {\n          steps {\n              echo 'Upload S3'\n              withAWS(credentials: '667cec8d-baa7-497f-b2db-2d424c121a22') {\n                s3Upload(file: '.', bucket: 'blog-server-bucket', path: &quot;${S3PATH}&quot;, excludePathPattern: '**/node_modules/**, **/.git/**')\n              }\n          }\n      }\n      stage('Deploy') {\n          steps {\n              echo 'deploy'\n              step([$class: 'AWSCodeDeployPublisher', applicationName: 'blog-server', awsAccessKey: 'AKIASDBC2NNSJWD4F76B', awsSecretKey: &quot;${AWS_SECRET_ACCESS_KEY}&quot;, credentials: 'awsAccessKey', deploymentConfig: 'CodeDeployDefault.OneAtATime', deploymentGroupAppspec: false, deploymentGroupName: 'blog-server-CodeDeploy-group', excludes: '', iamRoleArn: '', includes: '**', proxyHost: '', proxyPort: 0, region: 'ap-northeast-2', s3bucket: 'blog-server-bucket', s3prefix: '', subdirectory: '', versionFileName: '', waitForCompletion: false])\n          }\n      }\n   }\n   post {\n        success {\n            echo 'successed'\n        }\n        failure {\n            echo 'failed'\n        }\n   }\n}\n\n\n</code></pre>\n<h2>3) AWS Deploy 설정 파일</h2>\n<p>AWS CodeDeploy는 프로젝트 루트에 있는 appspec.yml를 이용하여 배포를 진행합니다. 자세한 내용은 <a href=\"https://docs.aws.amazon.com/ko_kr/codedeploy/latest/userguide/reference-appspec-file.html#appspec-reference-server\">aws 가이드</a>에서 확인하세요.</p>\n<p>프로젝트 루트에 appspec.yml 파일 생성 후 아래와 같이 입력합니다. AWS CodeDeploy가 ec2의 /home/ec2-user/build/ 위치에 S3 버킷에 있는 코드를 옮기도록 설정했습니다. 배포 후에는 <a href=\"http://execute-deploy.sh\">execute-deploy.sh</a> 작업을 통해 도커 컨테이너를 올릴 것입니다.</p>\n<pre><code>version: 0.0\nos: linux\nfiles:\n  - source:  /\n    destination: /home/ec2-user/build/\nhooks:\n  AfterInstall: # 배포 후\n    - location: execute-deploy.sh\n      timeout: 180\n</code></pre>\n<p><a href=\"http://execute-deploy.sh\">execute-deploy.sh</a></p>\n<pre><code>#!/bin/bash\ncd /home/ec2-user/build\nchmod +x ./deploy.sh\n./deploy.sh &gt; /dev/null 2&gt; /dev/null &lt; /dev/null &amp;\n</code></pre>\n<p>현재 블루 컨테이너가 돌고 있다면 그린 컨테이너를 구동한 후 블루 컨테이너를 종료합니다. 이 방법을 통해 무중단 배포를 할 수 있는 것입니다. 아래와 같이 작성합니다.</p>\n<p><a href=\"http://deploy.sh\">deploy.sh</a></p>\n<pre><code>#!/bin/bash\n\nDOCKER_APP_NAME=blog-server\n\nEXIST_BLUE=$(docker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml ps | grep Up)\n\nif [ -z &quot;$EXIST_BLUE&quot; ]; then\n\techo &quot;blue up&quot;\n\tdocker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml up -d\n\n\tsleep 10\n\n\tdocker-compose -p ${DOCKER_APP_NAME}-green -f docker-compose.green.yml down\nelse\n\techo &quot;green up&quot;\n\tdocker-compose -p ${DOCKER_APP_NAME}-green -f docker-compose.green.yml up -d\n\n\tsleep 10\n\n\tdocker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml down\nfi\n</code></pre>\n<p>자 이제 실제로 커밋 푸시하면 배포까지 완료되는 것을 볼 수 있습니다!</p>\n<p><img src=\"/assets/images/2020-02-24-img/28.png\" alt=\"process tree\"></p>\n<blockquote>\n<p>추가로 해야할 것</p>\n<ul>\n<li>S3에 왜 node_modules랑 .git도 올라가는 거지…? 분명 제외시켰는 데…</li>\n</ul>\n</blockquote>\n<p>참고</p>\n<ul>\n<li><a href=\"https://jojoldu.tistory.com/265\">기억보단 기록을</a></li>\n<li><a href=\"https://velog.io/@jeff0720/Travis-CI-AWS-CodeDeploy-Docker-%EB%A1%9C-%EB%B0%B0%ED%8F%AC-%EC%9E%90%EB%8F%99%ED%99%94-%EB%B0%8F-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EB%B0%B0%ED%8F%AC-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0-2\">https://velog.io/@jeff0720/Travis-CI-AWS-CodeDeploy-Docker-로-배포-자동화-및-무중단-배포-환경-구축하기-2</a></li>\n<li><a href=\"https://medium.com/faun/create-a-continuous-delivery-pipeline-using-jenkins-gitlab-github-and-deploy-on-aws-ec2-with-3aaadf073196\">https://medium.com/faun/create-a-continuous-delivery-pipeline-using-jenkins-gitlab-github-and-deploy-on-aws-ec2-with-3aaadf073196</a></li>\n</ul>\n",
		"updatedAt": "2020-02-26T17:20:02.499Z",
		"id": "2020-02-26-how-to-use-aws",
		"filename": "infra\\2020-02-26-how-to-use-aws.json"
	},
	{
		"layout": "post-content",
		"title": "jekyll의 minimal-mistakes에서 자바스크립트 커스텀하는 방법",
		"date": "2019-01-05T00:00:00.000Z",
		"tags": [
			"jekyll",
			"github"
		],
		"category": [
			"jekyll"
		],
		"body": "<p>minimal-mistakes 테마를 적용한 jekyll 블로그를 커스텀하는 과정에서 자바스크립트 코드를 추가하는 방법입니다.<br>\nminimal-mistakes 문서에 자바스크립트 커스텀 방법이 잘 정리되어있습니다.\n<a href=\"https://mmistakes.github.io/minimal-mistakes/docs/javascript/\">공식문서 바로가기</a>.</p>\n<hr>\n<p>우리가 수정해야 할 파일은 /assets/js/ 에 위치한 _main.js 파일입니다.<br>\n하지만, jekyll은 _main.js 파일이 아닌 main.min.js 파일을 컴파일하여 화면에 반영합니다.<br>\nmain.min.js 는 _main.js 자바스크립트 코드를 압축화하고 난독화한 파일로 npm 패키지 중 하나인 uglify를 이용하여 만들 수 있습니다.</p>\n<h2>1. npm 셋팅</h2>\n<pre><code>&gt; npm init\n</code></pre>\n<p>블로그 프로젝트 디렉토리 위치에서 위 코드를 실행시키면 package.json 파일이 생성됩니다.</p>\n<h2>2. package.json 파일 수정</h2>\n<p><a href=\"https://github.com/mmistakes/minimal-mistakes/blob/master/package.json\">https://github.com/mmistakes/minimal-mistakes/blob/master/package.json</a>\npackage.json 파일을 아래와 같이 수정합니다.</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"minimal-mistakes\"</span>,\n  <span class=\"hljs-attr\">\"version\"</span>: <span class=\"hljs-string\">\"4.14.2\"</span>,\n  <span class=\"hljs-attr\">\"description\"</span>: <span class=\"hljs-string\">\"Minimal Mistakes 2 column Jekyll theme.\"</span>,\n  <span class=\"hljs-attr\">\"repository\"</span>: {\n    <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"git\"</span>,\n    <span class=\"hljs-attr\">\"url\"</span>: <span class=\"hljs-string\">\"git://github.com/mmistakes/minimal-mistakes.git\"</span>\n  },\n  <span class=\"hljs-attr\">\"keywords\"</span>: [\n    <span class=\"hljs-string\">\"jekyll\"</span>,\n    <span class=\"hljs-string\">\"theme\"</span>,\n    <span class=\"hljs-string\">\"minimal\"</span>\n  ],\n  <span class=\"hljs-attr\">\"author\"</span>: <span class=\"hljs-string\">\"Michael Rose\"</span>,\n  <span class=\"hljs-attr\">\"license\"</span>: <span class=\"hljs-string\">\"MIT\"</span>,\n  <span class=\"hljs-attr\">\"bugs\"</span>: {\n    <span class=\"hljs-attr\">\"url\"</span>: <span class=\"hljs-string\">\"https://github.com/mmistakes/minimal-mistakes/issues\"</span>\n  },\n  <span class=\"hljs-attr\">\"homepage\"</span>: <span class=\"hljs-string\">\"https://mmistakes.github.io/minimal-mistakes/\"</span>,\n  <span class=\"hljs-attr\">\"engines\"</span>: {\n    <span class=\"hljs-attr\">\"node\"</span>: <span class=\"hljs-string\">\"&gt;= 0.10.0\"</span>\n  },\n  <span class=\"hljs-attr\">\"devDependencies\"</span>: {\n    <span class=\"hljs-attr\">\"npm-run-all\"</span>: <span class=\"hljs-string\">\"^4.1.5\"</span>,\n    <span class=\"hljs-attr\">\"onchange\"</span>: <span class=\"hljs-string\">\"^5.1.3\"</span>,\n    <span class=\"hljs-attr\">\"uglify-js\"</span>: <span class=\"hljs-string\">\"^3.4.9\"</span>\n  },\n  <span class=\"hljs-attr\">\"scripts\"</span>: {\n    <span class=\"hljs-attr\">\"uglify\"</span>: <span class=\"hljs-string\">\"uglifyjs assets/js/vendor/jquery/jquery-3.3.1.min.js assets/js/plugins/jquery.fitvids.js assets/js/plugins/jquery.greedy-navigation.js assets/js/plugins/jquery.magnific-popup.js assets/js/plugins/jquery.smooth-scroll.min.js assets/js/_main.js -c -m -o assets/js/main.min.js\"</span>,\n    <span class=\"hljs-attr\">\"add-banner\"</span>: <span class=\"hljs-string\">\"node banner.js\"</span>,\n    <span class=\"hljs-attr\">\"watch:js\"</span>: <span class=\"hljs-string\">\"onchange \\\"assets/js/**/*.js\\\" -e \\\"assets/js/main.min.js\\\" -- npm run build:js\"</span>,\n    <span class=\"hljs-attr\">\"build:js\"</span>: <span class=\"hljs-string\">\"npm run uglify &amp;&amp; npm run add-banner\"</span>\n  }\n}\n</code></pre>\n<h2>3. uglify 설치 및 실행</h2>\n<p>uglify-js 패키지 설치</p>\n<pre><code>&gt; npm install uglify-js\n</code></pre>\n<p>package.json의 scripts 부분을 보면 build:js 스크립트 실행시 <strong>npm run uglify &amp;&amp; npm run add-banner</strong> 를 실행하도로 되어있습니다.\n이를 참고하여 cmd에서 <code class=\"codetainer\">npm run build:js</code>를 실행해봅시다. 정상적으로 _main.js 파일이 main.min.js로 압축된 것을 확인할 수 있을 것입니다.</p>\n<h2>4. jekyll serve 실행</h2>\n<p>이미 서버가 실행되어있다면 자동으로 반영됩니다.<br>\n그렇지 않다면 다시 <strong>jekyll serve</strong> 를 통해 서버를 실행해주면 커스텀한 자바스크립트 코드가 반영된 것을 확인할 수 있습니다.</p>\n",
		"updatedAt": "2020-01-22T18:24:11.358Z",
		"id": "2019-01-05-jekyll-js-custom",
		"filename": "etc\\2019-01-05-jekyll-js-custom.json"
	},
	{
		"layout": "post-content",
		"title": "Liquid 문법",
		"date": "2019-03-05T00:00:00.000Z",
		"tags": [
			"jekyll",
			"liquid"
		],
		"category": [
			"jekyll"
		],
		"body": "<p>jekyll 블로그 운영시 알아야할 필수 liquid 문법</p>\n<hr>\n<p><a href=\"https://shopify.github.io/liquid/basics/types/\">liquid 문법 정리된 사이트</a></p>\n<h2>Liquid</h2>\n<table>\n<thead>\n\t<tr><th>category</th><th>Input</th><th>Output</th></tr>\n</thead>\n<tbody>\n\t<tr>\n\t\t<td>Objects</td>\n\t\t<td>\n\t\t{ { page.title } }\t\n\t\t</td>\n\t\t<td>Introduction</td>\n\t</tr>\n\t<tr>\n\t\t<td>Tags</td>\n\t\t<td>\n\t\t{ % if user % } <br/>\n\t\t  &nbsp;&nbsp;Hello { { user.name } }! <br/>\n\t\t{ % endif % }\n\t\t</td>\n\t\t<td>Hello Adam!</td>\n\t</tr>\n\t<tr>\n\t\t<td>Filters</td>\n\t\t<td>\n\t\t{ { \"/my/fancy/url\" | append: \".html\" } }\n\t\t</td>\n\t\t<td>/my/fancy/url.html</td>\n\t</tr>\n\t<tr>\n\t\t<td>Filters</td>\n\t\t<td>\n\t\t{ { \"adam!\" | capitalize | prepend: \"Hello \" } }\n\t\t</td>\n\t\t<td>Hello Adam!</td>\n\t</tr>\n\t<tr>\n\t\t<td>assing String</td>\n\t\t<td>\n\t\t{ % assign my_string = \"Hello World!\" % }\n\t\t</td>\n\t\t<td>String 타입</td>\n\t</tr>\n\t<tr>\n\t\t<td>assing Number</td>\n\t\t<td>\n\t\t{ % assign my_int = 25 % }\n\t\t</td>\n\t\t<td>Number 타입</td>\n\t</tr>\n\t<tr>\n\t\t<td>assing Boolean</td>\n\t\t<td>\n\t\t{ % assign foo = true % }\n\t\t</td>\n\t\t<td>Boolean 타입</td>\n\t</tr>\n\t<tr>\n\t\t<td>Nil (empty)</td>\n\t\t<td>\n\t\tThe current user is { { user.name } }\n\t\t</td>\n\t\t<td>The current user is</td>\n\t</tr>\n\t<tr>\n\t\t<td>Array</td>\n\t\t<td>\n\t\t{ % for user in site.users % }<br/>\n\t\t  &nbsp;&nbsp; { { user } }<br/>\n\t\t{ % endfor % }\n\t\t</td>\n\t\t<td>Tobi Laura Tetsuro Adam</td>\n\t</tr>\n\t<tr>\n\t\t<td>Array</td>\n\t\t<td>\n\t\t{ { site.users[0] } }<br/>\n\t\t{ { site.users[1] } }<br/>\n\t\t{ { site.users[3] } }\n\t\t</td>\n\t\t<td>Tobi <br/>\n\t\tLaura <br/>\n\t\tAdam</td>\n\t</tr>\n\t<tr>\n\t\t<td>plus</td>\n\t\t<td>\n\t\t{ { 4 | plus: 2 } }\n\t\t</td>\n\t\t<td>6</td>\n\t</tr>\n\t<tr>\n\t\t<td>limit</td>\n\t\t<td>\n\t\t{ % for item in array limit:2 % }<br/>\n\t       &nbsp;&nbsp; { { item } }<br/>\n\t\t{ % endfor % }\n\t\t</td>\n\t\t<td>limit를 통해 2개까지만 반복문을 돌린다.</td>\n\t</tr>\n</tbody>\n</table>\n",
		"updatedAt": "2020-01-22T18:24:23.824Z",
		"id": "2019-03-05-liquid-site",
		"filename": "etc\\2019-03-05-liquid-site.json"
	},
	{
		"layout": "post-content",
		"title": "html5 와 css3 와 관련된 에러 모음",
		"date": "2019-03-14T00:00:00.000Z",
		"tags": [
			"android",
			"error"
		],
		"category": [
			"android"
		],
		"body": "<ol>\n<li>IE에서 CSS 적용 안되는 문제 (2019-03-14)</li>\n</ol>\n<hr>\n<h2>1. IE에서 CSS 적용 안되는 문제</h2>\n<p>HTML5, CSS3로 코딩된 페이지가 크롬과 IE 신형 버전에서는 정상적으로 적용되나, 구형 익스플로어에서 적용안되는 문제가 발생했다.\n이는 페이지 head 안에 아래의 메타 태그만 추가하면 해결된다.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"IE=edge, chrome=1\"</span>&gt;</span>\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:24:53.851Z",
		"id": "2019-03-14-html5-error",
		"filename": "etc\\2019-03-14-html5-error.json"
	},
	{
		"layout": "post-content",
		"title": "자바 API 정리",
		"date": "2019-06-27T00:00:00.000Z",
		"tags": [
			"java"
		],
		"categories": [
			"Java"
		],
		"body": "<p>JAVA 공부하면서 알게 된 API 정리한 글 입니다.</p>\n<hr>\n<h1>java.lang.String</h1>\n<h2>compareTo</h2>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compareTo</span><span class=\"hljs-params\">(String anotherString)</span>\n</span></code></pre>\n<p>두 개의 String을 사전적으로 비교하는 함수다.</p>\n<ul>\n<li>내부적으로</li>\n</ul>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">this</span>.charAt(k) - anotherString.charAt(k)\n</code></pre>\n<p>String을 구성하는 char의 유니코드 값으로 비교를 한다.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">this</span>.length()-anotherString.length()\n</code></pre>\n<p>각 String의 각 char index의 값이 모두 동일하면, 길이가 더 짧은 스트링이 사전적으로 앞선다.</p>\n<p><strong>사용법</strong></p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">int</span> returnVal = string1.compareTo(string2);\n</code></pre>\n<p>returnVal = 0, string1 == string2<br>\nreturnVal &gt; 0, string1 &gt; string2 사전적으로 string1이 string2보다 뒤에 있다는 뜻.<br>\nreturnVal &lt; 0, string1 &lt; string2 사전적으로 string1이 string2보다 앞에 있다는 뜻.</p>\n<hr>\n",
		"updatedAt": "2020-01-22T18:25:12.454Z",
		"id": "2019-06-27-java-api-1",
		"filename": "java\\2019-06-27-java-api-1.json"
	},
	{
		"layout": "post-content",
		"title": "JVM 메모리 구조",
		"date": "2019-10-16T00:00:00.000Z",
		"tags": [
			"java"
		],
		"categories": [
			"Java"
		],
		"body": "<p>예전 면접에서 JVM 메모리 구조에 관한 질문을 받은 적이 있었다…<br>\n횡설수설하며 대답하긴 했지만 좀 더 깔끔한 답변을 위해 정리해야할 필요성을 느꼈다…!!!</p>\n<p>우선, JVM이 뭘까?</p>\n<p>JVM(Java Virtual Machine) 은 자바로 작성된 애플리케이션을 실행하기 위해서 반드시 필요한 가상머신이다!</p>\n<p><img src=\"/assets/images/2019-10-16-img/memory01.png\" alt=\"1\">    <br/></p>\n<p>위 그림을 보면 일반 애플리케이션 코드는 OS만 거치고 하드웨어로 전달되지만 자바 애플리케이션은 JVM을 한번 더 거친다.\n그래서 자바는 속도가 느린 단점이 있다고 한다.</p>\n<p>왜??? 이유를 알기 위해 잠시 자바 응용 프로그램의 실행되는 과정을 살펴볼 필요가 있다.</p>\n<ol>\n<li>응용프로그램이 실행되면 JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.</li>\n<li>javac.exe (자바 컴파일러)가 자바소스를 바이트 코드(*.class)로 컴파일한다.</li>\n<li>Class Loader가 JVM에 클래스 파일을 로드시킨다.</li>\n<li>java.exe (자바인터프리터, 실행엔진)이 컴파일된 바이트 코드를 해석한다.</li>\n<li>해석된 바이트 코드는 Runtime Data Areas에 배치되어 실행된다.</li>\n</ol>\n<p>위와 같이 하드웨어에 맞게 완전히 컴파일된 상태가 아닌 바이트 코드로 컴파일된 상태고 실행 시에 해석되기 때문에 느리다.\n그래도 요즘엔 바이트 코드를 하드웨어의 기계어로 바로 변환해주는 JIT 컴파일러와 향상된 최적화 기술이 적용되어서 속도 문제가 많이 개선되었다고 한다.</p>\n<p>장점으로는 JVM 덕분에 자바 애플리케이션은 OS에 종속되지 않는 점이 있다.<br>\n그래도 JVM은 OS에 종속되니깐 OS에 맞는 JVM이 필요하다.</p>\n<h2>JVM 메모리 구조</h2>\n<p><img src=\"/assets/images/2019-10-16-img/JvmSpec7.png\" alt=\"1\">    <br/>\n<a href=\"https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EA%B0%80%EC%83%81_%EB%A8%B8%EC%8B%A0\">JVM스펙</a></p>\n<p>이 중 3가지 주요 영역에 대해 알아보자.</p>\n<h2>메서드 영역</h2>\n<p>메서드 영역(Method area = static area = Class area)은 JVM이 *.class을 해석하여 얻은 클래스 정보(클래스 데이터)가 저장되는 공간이다. 이 때, 클래스 변수(static 멤버변수)도 같이 저장된다.<br>\n클래스정보에는 멤버변수의 이름/데이터 타입/접근 제어자 정보, 메소드의 이름/리턴 타입/매개변수/접근제어자 정보, 클래스인지 인터페이스인지 여부, 전체이름들이 해당된다.</p>\n<h2>힙</h2>\n<p>힙(Heap) 영역은 프로그램 실행 중에 생성되는 인스턴스(객체)가 저장되는 공간이다.<br>\n즉 new 키워드로 생성된 객체와 배열을 저장한다. 물론 인스턴스 변수도 같이 저장된다.</p>\n<h2>호출스택</h2>\n<p>호출 스택(call stack 또는 execution stack)은 호출된 메서드를 위한 메모리가 할당되는 곳으로 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함), 연산의 중간 결과, 리턴 값들을 저장하는 데 사용한다. 메서드가 작업을 마치면 할당되었던 메모리 공간은 반환되어 비워진다.</p>\n<p>참고서적) 자바의 정석<br>\n참고블로그) <a href=\"https://asfirstalways.tistory.com/158\">https://asfirstalways.tistory.com/158</a></p>\n",
		"updatedAt": "2020-01-22T18:25:47.525Z",
		"id": "2019-10-16-java-jvm-memory",
		"filename": "java\\2019-10-16-java-jvm-memory.json"
	},
	{
		"layout": "post-content",
		"title": "Java Comparator과 Comparable",
		"date": "2019-10-18T00:00:00.000Z",
		"tags": [
			"java"
		],
		"categories": [
			"Java"
		],
		"body": "<p>PS 문제를 풀다가 Arrays.sort()와 Collections.sort()를 오름차순(디폴트)이 아닌 다른 기준으로 정렬하고 싶을 때가 있었다. 찾아보니 Comparator 또는 Comparable을 사용하면 된다고 한다. 음… 알아본 김에 잊어버리지않게 기록을 해야겠다!</p>\n<h1>컬렉션을 입맛대로 정렬하고 싶다면?</h1>\n<p>내맘대로 컬렉션의 정렬 기준을 정하고 싶다면 <code>Comparator</code>과 <code>Comparable</code> 인터페이스를 사용하면 된다.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> java.util.Comparator;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Comparator</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(Object o1, Object o2)</span></span>;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">equals</span><span class=\"hljs-params\">(Object obj)</span></span>;\n}\n</code></pre>\n<br/>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> java.lang.Comparable;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Comparable</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compareTo</span><span class=\"hljs-params\">(Object o)</span></span>; <span class=\"hljs-comment\">// 양수 : 내림차순, 음수 : 오름차순</span>\n}\n</code></pre>\n<h1>그럼 둘의 차이는 무엇일까?</h1>\n<p>Comparable을 구현한 클래스들은 기본적으로 오름차순으로 정렬되도록 구현되어있다.<br>\nInteger, Character와 같은 <code>wrapper</code> 클래스(int, long, float, double 등을 객체화한 클래스)와 <code>String, Date, File</code>과 같은 것이 Comparable을 구현한 대표적 클래스이다. 그 외 Java API 문서에서 클래스 목록을 확인할 수 있다.<br>\n그래서 우리가 <code>Arrays.sort(정렬대상)</code> 로 오름차순 정렬을 할 수 있는 것이다. 아하!</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Integer</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Number</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Comparable</span> </span>{\n    ...\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compareTo</span><span class=\"hljs-params\">(Object o)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> compareTo((Integer) o);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compareTo</span><span class=\"hljs-params\">(Integer anotherInteger)</span> </span>{\n        <span class=\"hljs-keyword\">int</span> thisVal = <span class=\"hljs-keyword\">this</span>.value;\n        <span class=\"hljs-keyword\">int</span> anotherVal = anotherInteger.value;\n        <span class=\"hljs-keyword\">return</span> (thisVal &lt; anotherVal ? -<span class=\"hljs-number\">1</span> : (thisVal ==anotherVal ? <span class=\"hljs-number\">0</span> : <span class=\"hljs-number\">1</span>));\n    }\n}\n</code></pre>\n<p>실제 Integer 클래스의 일부이다.<br>\n보이는 것 처럼 Comparable 인터페이스를 구현하고 compareTo 메서드에서 오름차순으로 정렬되도록 정의해놓았다.</p>\n<p>Comparator 인터페이스는 Comparable로 구현된 클래스를, 또는 커스텀 클래스를 기본 정렬 기준 외에 다른 기준으로 정렬하고자 할 때 사용하면 된다.<br>\n아래는 실제 예제로 백준 16236 아기 상어 문제를 풀 때 우선순위큐의 정렬기준을 Comparator을 이용해 정의한 것이다.</p>\n<pre><code class=\"language-java\">PriorityQueue&lt;Point&gt; pq = <span class=\"hljs-keyword\">new</span> PriorityQueue&lt;&gt;(<span class=\"hljs-keyword\">new</span> Comparator&lt;Point&gt;() {\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(Point o1, Point o2)</span> </span>{\n\t\t<span class=\"hljs-keyword\">if</span> (o1.dis != o2.dis) <span class=\"hljs-keyword\">return</span> o1.dis-o2.dis;\n\t\t<span class=\"hljs-keyword\">if</span> (o1.row != o2.row) <span class=\"hljs-keyword\">return</span> o1.row-o2.row;\n\t\t<span class=\"hljs-keyword\">return</span> o1.col-o2.col;\n\t}\n});\n</code></pre>\n<p>또는 책의 예제를 보면 따로 클래스를 정의해서 사용할 수 있다.<br>\n이 예제는 Comparable을 구현한 클래스 String의 정렬 방식을 내림차순으로 바꾸는 방법이다.<br>\n단순히 -1을 곱해 반대의 값을 반환하게 구현했다.</p>\n<pre><code class=\"language-java\">\nArrays.sort(strArr, <span class=\"hljs-keyword\">new</span> Descending());\n\nClass Descending implements Comparator {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compareTo</span><span class=\"hljs-params\">(Object o1, Object o2)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (o1 <span class=\"hljs-keyword\">instanceof</span> Comparable &amp;&amp; o2 <span class=\"hljs-keyword\">instanceof</span> Comparable) {\n            Comparable c1 = (Comparable) o1;\n            Comparable c2 = (Comparable) o2;\n            <span class=\"hljs-keyword\">return</span> c1.compareTo(c2) * -<span class=\"hljs-number\">1</span>;\n        }\n    }\n}\n</code></pre>\n<p>이제 내맘대로 정렬할 수 있게 되었담!!!</p>\n<p>자바의 정석 책을 참고했습니다.</p>\n",
		"updatedAt": "2020-01-22T18:25:47.835Z",
		"id": "2019-10-18-java-compare",
		"filename": "java\\2019-10-18-java-compare.json"
	},
	{
		"layout": "post-content",
		"title": "(JS) call()과 apply()",
		"date": "2018-01-08T00:00:00.000Z",
		"tags": [
			"javascript"
		],
		"category": [
			"javascript"
		],
		"body": "<p>call() 과 apply() 메서드를 이용하여 명시적으로 this에 바인딩할 수 있습니다.</p>\n<hr>\n<p>모든 함수의 부모 객체인 Function.prototype 객체의 메서드라서 모든 함수에서 호출 가능합니다.</p>\n<h2>Function.prototype.apply()</h2>\n<pre><code class=\"language-javascript\">fun.apply(thisArg, [argArray])\n</code></pre>\n<p>fun 메서드를 호출할 때, fun 내부의 this를 매개변수인 thisArg로 바인딩 시킵니다.\nargArray는 fun 메서드에서 인자로 사용됩니다.<br>\n<span class=\"clr-grey\">argArray : 배열리터럴, Array 객체</span></p>\n<h2>Function.prototype.call()</h2>\n<pre><code class=\"language-javascript\">fun.call(thisArg[,arg1[,arg2[,....]]])\n</code></pre>\n<p>apply와 기능이 같으며, 배열형태가 아닌 각각의 하나의 인자형태로 값을 넘긴다는 차이점이 있습니다.</p>\n<h1>추가 개념</h1>\n<h2>객체의 메서드를 호출할 때, 객체 메서드 내부의 this는?</h2>\n<p>해당 메서드를 호출한 객체</p>\n<h2>함수를 호출할 때, 함수 내부의 this는?</h2>\n<p>전역객체에 바인딩 된다. window\n*내부함수를 호출했을 때도, 내부 this는 window!</p>\n<h2>생성자 함수를 호출할 때, 생성자 함수 내부의 this는?</h2>\n<p>생성자 함수 코드가 실행되기 전 생성되는 빈 객체<br>\n이 객체는 부모인 프로토타입과 연결되어있으므로 부모의 프로퍼티와 메서드를 사용할 수 있다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.age = <span class=\"hljs-number\">0</span>;    <span class=\"hljs-comment\">// (1)</span>\n    setInterval( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">growUp</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-keyword\">this</span>.age++;    <span class=\"hljs-comment\">// (2)</span>\n    },<span class=\"hljs-number\">1000</span>); \n} \n<span class=\"hljs-keyword\">var</span> p  = <span class=\"hljs-keyword\">new</span> Person();\n</code></pre>\n<p>(1)의 this는 생성자 함수를 호출하면서 만들어지는 빈 객체<br>\n(2)의 this는 window 전역객체를 가르킨다.</p>\n<p>그래서, 위의 코드는 1초마다 나이가 1씩 증가하는 결과를 얻을 수 없다.</p>\n<p>그렇다면, (2)가 Person 생성자로 만들어진 객체로 바인딩되게 하고 싶으며 어떻게 해야할까?</p>\n<p>아래 코드와 같이 비전역 변수에 할당하여 해결할 수 있다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-keyword\">var</span> that = <span class=\"hljs-keyword\">this</span>;\n    that.age = <span class=\"hljs-number\">0</span>;     \n \n    setInterval( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">growUp</span>(<span class=\"hljs-params\"></span>)</span>{\n        that.age++;\n    }, <span class=\"hljs-number\">1000</span>); \n}\n</code></pre>\n<p>ES6의 화살표 함수를 이용하면 비전역 변수를 이용하지 않고도 생성자 객체에 바인딩 시킬 수 있다.<br>\n화살표 함수는 자신만의 this를 생성하지 않기 때문이다!!</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.age = <span class=\"hljs-number\">0</span>;     \n \n    setInterval( <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n        <span class=\"hljs-keyword\">this</span>.age++;\n    }, <span class=\"hljs-number\">1000</span>); \n}\n</code></pre>\n<p>위 화살표 함수 내 this는 정확히 Person() 생성자를 통해 생성된 객체를 가리키게 된다!</p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98\">출처</a></p>\n",
		"updatedAt": "2020-01-22T18:21:09.421Z",
		"id": "2018-01-08-javascript-callapply",
		"filename": "javascript\\2018-01-08-javascript-callapply.json"
	},
	{
		"layout": "post-content",
		"title": "(생활코딩) Javascript 입문1",
		"date": "2018-01-09T00:00:00.000Z",
		"tags": [
			"javascript"
		],
		"category": [
			"javascript"
		],
		"body": "<p>생활코딩 URL : <a href=\"https://opentutorials.org/course/743\">https://opentutorials.org/course/743</a><br>\n생활코딩 강의에서 기억하고 싶었던 내용을 포스팅해보았다.</p>\n<hr>\n<h1>변수의 효용을 이해하자.</h1>\n<ul>\n<li>필요에 의해서 변할 수 있는 영역과 변하지 않는 영역을 구분해서 코딩해야한다.</li>\n<li>재활용 가능해진다. 유지보수 용이해진다.</li>\n</ul>\n<h1>비교</h1>\n<pre><code class=\"language-javascript\">alert( <span class=\"hljs-number\">1</span> === <span class=\"hljs-string\">\"1\"</span>);   <span class=\"hljs-comment\">//false    데이터타입[형식]도 동일해야함.**이걸쓰자!</span>\nalert( <span class=\"hljs-number\">1</span> == <span class=\"hljs-string\">\"1\"</span>);     <span class=\"hljs-comment\">//true     버그발생 가능성 높음..</span>\n\n<span class=\"hljs-keyword\">var</span> a;\nalert(a);    <span class=\"hljs-comment\">//undefined 값이 정의되지 않음</span>\nalert(<span class=\"hljs-literal\">undefined</span> == <span class=\"hljs-literal\">null</span>)      <span class=\"hljs-comment\">//true</span>\nalert(<span class=\"hljs-literal\">undefined</span> === <span class=\"hljs-literal\">null</span>)    <span class=\"hljs-comment\">//false</span>\nalert( <span class=\"hljs-literal\">true</span> == <span class=\"hljs-number\">1</span> )    <span class=\"hljs-comment\">//true **숫자 1은 true로 간주, 그 외는 false로.</span>\nalert( <span class=\"hljs-literal\">true</span> === <span class=\"hljs-number\">1</span> )    <span class=\"hljs-comment\">//false </span>\nalert(<span class=\"hljs-literal\">NaN</span> === <span class=\"hljs-literal\">NaN</span>);    <span class=\"hljs-comment\">//false</span>\n</code></pre>\n<h2>[데이터타입]</h2>\n<p>undefined : 값이 정의되지 않은 상태, 프로그래머가 의도하지 않음 false로 간주<br>\nnull    :    값이 없는 상태, 프로그래머가 의도함. false로 간주<br>\nNaN   : 0/0 계산할 수 없음. false로 간주</p>\n<h1>조건문</h1>\n<p>if(’’) alert(‘빈문자열’); //false 빈문자열은 false/ 문자열있으면 true로 간주</p>\n",
		"updatedAt": "2020-01-22T18:21:09.421Z",
		"id": "2018-01-09-javascript-opentutorials-1",
		"filename": "javascript\\2018-01-09-javascript-opentutorials-1.json"
	},
	{
		"layout": "post-content",
		"title": "(생활코딩) Javascript 입문2",
		"date": "2018-01-10T00:00:00.000Z",
		"tags": [
			"javascript"
		],
		"category": [
			"javascript"
		],
		"body": "<p>생활코딩 URL <a href=\"https://opentutorials.org/course/743/\">https://opentutorials.org/course/743/</a><br>\n반복문, 함수 정의방법, 배열, 객체</p>\n<hr>\n<h1>반복문</h1>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">for</span>( <span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">10</span>; i++){\n    <span class=\"hljs-keyword\">if</span>( i === <span class=\"hljs-number\">5</span>) <span class=\"hljs-keyword\">break</span>;     <span class=\"hljs-comment\">// 그 즉시, for문 중단 - coding1~4 까지만 출력됨</span>\n    <span class=\"hljs-keyword\">if</span>( i === <span class=\"hljs-number\">5</span>) <span class=\"hljs-keyword\">continue</span>; <span class=\"hljs-comment\">// 실행을 중단하고 반복문 이어서 함. - coding1~4/6~9까지 출력됨.</span>\n    <span class=\"hljs-built_in\">document</span>.write(<span class=\"hljs-string\">\"coding\"</span>+i+<span class=\"hljs-string\">\"\"</span>);\n}\n</code></pre>\n<h1>함수 정의 방법</h1>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// [첫번째 방법]</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">numbering</span>(<span class=\"hljs-params\">arg</span>)</span>{\n   <span class=\"hljs-comment\">//statement</span>\n}\n\n<span class=\"hljs-comment\">// [두번째 방법]</span>\n<span class=\"hljs-keyword\">var</span> numbering = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n <span class=\"hljs-comment\">//statement </span>\n }\n\n <span class=\"hljs-comment\">// [세번째 방법-익명함수]</span>\n (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-comment\">//statement </span>\n })();\n <span class=\"hljs-comment\">//*일회성 함수</span>\n</code></pre>\n<h1>배열</h1>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> member = [<span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-string\">'c'</span>];    <span class=\"hljs-comment\">//생성</span>\nalert(member[<span class=\"hljs-number\">0</span>]);                <span class=\"hljs-comment\">// 'a' </span>\n\n<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">0</span>; i&lt;member.length; i++){    <span class=\"hljs-comment\">// 배열의 크기만큼 반복</span>\n  <span class=\"hljs-built_in\">document</span>.write(member[i].toUpperCase()) + <span class=\"hljs-string\">\"\"</span>;\n}\n<span class=\"hljs-comment\">/*배열의 원소 추가하는 방법*/</span>\nmember.push(<span class=\"hljs-string\">'f'</span>);        <span class=\"hljs-comment\">// a,b,c,f - 배열의 맨 뒤에 삽입</span>\nmember.concat([<span class=\"hljs-string\">'e'</span>,<span class=\"hljs-string\">'f'</span>]); <span class=\"hljs-comment\">// a,b,c,f,e,f - 복수의 원소 추가</span>\nmember.unshift(<span class=\"hljs-string\">'g'</span>);     <span class=\"hljs-comment\">// g,a,b,c,f,e,f - 배열의 맨 앞에 삽입</span>\nmember.splice(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">'B'</span>); <span class=\"hljs-comment\">// g,a,B,b,c,f,e,f - 배열의 2번째 인덱스 0(앞에) B를 추가</span>\n\n<span class=\"hljs-comment\">/*배열의 원소 삭제하는 방법 및 정렬 */</span>\nmember.shift();        <span class=\"hljs-comment\">// 배열의 첫번째 원소 삭제</span>\nmember.pop();        <span class=\"hljs-comment\">// 배열의 마지막 원소 삭제</span>\nmember.sort();        <span class=\"hljs-comment\">// 오름차순 정렬</span>\nmember.reverse();    <span class=\"hljs-comment\">// 내림차순 정렬</span>\n</code></pre>\n<h2>배열의 함수. splice</h2>\n<ul>\n<li>배열의 특정구간을 추출하거나, 특정 구간에 특정 배열을 추가한다.</li>\n<li>array.splice( index, howmany, [element1…N])<br>\n<span class=\"clr-grey\">\nindex : 배열의 위치<br>\nhowmany : index에서부터 제거될 원소의 수로, 1이면 index 값만 제거되어 값이 추가된다.<br>\n0일 때는 삭제 없이 인덱스 앞쪽에 값이 추가됨. 없으면 배열 끝까지(길이)<br>\nelement1…N : 추가될 Value\n</span></li>\n</ul>\n<h2>배열의 정렬. sort - 사용자정의가능</h2>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sortNumber</span>(<span class=\"hljs-params\">a,b</span>)</span>{\n    <span class=\"hljs-keyword\">return</span> a-b;    <span class=\"hljs-comment\">//리턴값이 음수, 양수, 0인지에 따라 순서 정함.</span>\n}\n<span class=\"hljs-keyword\">var</span> numbers = [<span class=\"hljs-number\">20</span> ,<span class=\"hljs-number\">10</span> <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">15</span>]\nnumbers.sort(sortNumber); <span class=\"hljs-comment\">// 8,10,15,20</span>\n</code></pre>\n<h1>객체</h1>\n<p>배열 - 자동으로 색인 추가[number], 순서존재<br>\n객체 - 인덱스의 값을 숫자 뿐만 아니라 문자 등 원하는 이름으로 지정 가능 (데이터타입 : 연관배열, 맵, 딕셔너리), 순서존재X</p>\n<pre><code class=\"language-javascript\">/*객체의 생성*/\nvar grades = {'aa':10, 'bb':6, 'cc': 80};    //객체의 생성\nvar grades = {};    //비어있는 객체의 생성\nvar grades = new object();    //비어있는 객체의 생성\n\n/*객체의 할당*/\ngrades['aa'] = 10;\ngrades['bb'] = 6;\ngrades['cc'] = 80;\n\n/*객체의 접근 key/value*/\ngrades['bb']    //6\ngrades.bb       //6\ngrades['b'+'b'] //6\ngrades.'b'+'b';  //에러 남\n\n/*객체의 값 가져오기*/\nfor(var key in grades){    //객체를 구성하는 값들의 키값만 하나씩 가져옴\n document.write(\"key : \"+key+\" value : \"+grades[key] + \"\");\n}\n\n/*객체지향 프로그래밍 - 서로 연관된 데이터, 처리를 하나의 그릇안에 그룹핑 한것*/\nvar grades = {\n 'list' : {'aa':10, 'bb':6, 'cc': 80},\n 'show' : function(){\n      alert(\"hello world\"); \n  },\n'show2' : function(){\n      console.log(this.list);     //this란? 함수가 속해있는 객체를 가리킨다. 여기선 grades를 가리킴.\n },\n'show_list' : function(){\n  for(var name in this.list){\n   console.log(name,  this.list[name]);\n  }\n }\n}\nalert(grades['list]['aa']); //10\ngrades['show']();       //객체의 함수호출. alert창 뜸.\ngrades.show_list();    //객체의 함수호출 aa,10 bb,6 cc,80 출력\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:21:09.422Z",
		"id": "2018-01-10-javascript-opentutorials-2",
		"filename": "javascript\\2018-01-10-javascript-opentutorials-2.json"
	},
	{
		"layout": "post-content",
		"title": "(생활코딩) Javascript 입문3",
		"date": "2018-01-11T00:00:00.000Z",
		"tags": [
			"javascript"
		],
		"category": [
			"javascript"
		],
		"body": "<p>생활코딩 javscript 과정 중 정규표현식 내용을 정리했습니다.</p>\n<hr>\n<h1>정규표현식(Regular Expression)</h1>\n<ul>\n<li>문자열에서 특정 문자를 찾을 때 사용 … * 나중에 생활코딩 정규표현식 강의도 듣기!! &amp; 전화번호 때 사용했던 경험 넣기</li>\n<li>컴파일 -&gt; 실행 단계로 이뤄진다.</li>\n<li>컴파일 : 찾고 싶은 패턴을 만듬.</li>\n<li>실행 : 문자열에서 패턴을 추출.</li>\n</ul>\n<h2>정규표현식 객체를 만드는 방법</h2>\n<ol>\n<li>var pattern = /a/</li>\n<li>var pattern = new RegExp(‘a’);</li>\n</ol>\n<h2>패턴 추출</h2>\n<ol>\n<li>pattern.exec(‘abcdef’)    // [“a”]; a배열 추출</li>\n<li>pattern.exec(‘bcdefg’)    // null a가 없어서.</li>\n<li>pattern.test(‘abcdef’)     // true</li>\n<li>pattern.test(‘bcdefg’)     // false</li>\n</ol>\n<h2>문자열 객체의 메소드에서 정규표현식 사용하기</h2>\n<p>String.match()<br>\nString.replace()</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-string\">'abcdef'</span>.match(pattern)    <span class=\"hljs-comment\">// [\"a\"]</span>\n<span class=\"hljs-string\">'bcdefg'</span>.match(pattern)    <span class=\"hljs-comment\">// null</span>\n<span class=\"hljs-string\">'abcdef'</span>.replace(pattern,<span class=\"hljs-string\">'A'</span>)    <span class=\"hljs-comment\">// Abcdef</span>\n</code></pre>\n<h2>옵션</h2>\n<p>i 대소문자 구분 안함</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> oi = <span class=\"hljs-regexp\">/a/i</span>;\n<span class=\"hljs-string\">\"Abcdef\"</span>.match(oi);    <span class=\"hljs-comment\">//[\"A\"]</span>\n</code></pre>\n<p>g 검색된 모든 결과 리턴</p>\n<pre><code>var og = /a/g;\n&quot;abcdea&quot;.match(og);    //[&quot;a&quot;,&quot;a&quot;]\n</code></pre>\n<h2>치환</h2>\n<pre><code>var pattern = /(\\w+)\\s(\\w+)/;    //()는 그룹, \\s는 공백, +는 1개이상, \\w는 문자(0-9,a-z,A-Z)\nvar str = &quot;coding everybody&quot;;\nvar result = str.replace(pattern, &quot;$2, $1&quot;);    //$N는 N번째 그룹.\nconsole.log(result);\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:21:09.421Z",
		"id": "2018-01-11-javascript-opentutorials-3",
		"filename": "javascript\\2018-01-11-javascript-opentutorials-3.json"
	},
	{
		"layout": "post-content",
		"title": "(생활코딩) javascript 함수지향1",
		"date": "2018-01-11T00:00:00.000Z",
		"tags": [
			"javascript"
		],
		"category": [
			"javascript"
		],
		"body": "<p>생활코딩 함수지향 파트 중 변수의 유효범위에 대한 내용을 정리했습니다.</p>\n<hr>\n<h1>변수의 유효범위</h1>\n<p>예제1) 지역변수와 전역변수의 구분1</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> vscope = <span class=\"hljs-string\">'global'</span>;    <span class=\"hljs-comment\">//전역변수</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fscope</span>(<span class=\"hljs-params\"></span>)</span>{\n   alert(vscope);\n}\nfscope();    <span class=\"hljs-comment\">//global</span>\n</code></pre>\n<span class=\"clr-grey\">\n**Note:** 전역변수 : 애플리케이션 전역에서 접근 가능한 변수    \n**Note:** 지역변수 : 함수 내에서만 접근 가능한 변수    \n*변수에 접근할 때, 지역변수를 우선적으로 찾는다.\n</span>\n</br>\n예제2) 지역변수와 전역변수의 구분2\n```javascript\nvar vscope = 'global';   \nfunction fscope(){\n   var vscope = 'local';    //지역변수\n   var lv = 'local value';   //지역변수\n   alert(vscope);\n}\nfscope();    //local\nalert(lv);    //undefined\n```\n<p>예제3) 지역변수와 전역변수의 구분3</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">a</span>(<span class=\"hljs-params\"></span>)</span>{\n   i=<span class=\"hljs-number\">0</span>;\n}\n<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i =<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">5</span>; i++){    <span class=\"hljs-comment\">// i는 전역변수</span>\n    a();\n    <span class=\"hljs-built_in\">document</span>.write(i);\n}\n</code></pre>\n<p>for문의 i는 전역변수기 때문에 해당 코드는 계속 실행되다가 브라우저가 멈춘다.</p>\n<p>예제4) 전역변수 안쓰는 방법1</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> MYAPP = {}\nMYAPP.calculator = { <span class=\"hljs-comment\">//객체의 속성(calculator)에도 객체를 생성.</span>\n  <span class=\"hljs-string\">'left'</span> : <span class=\"hljs-literal\">null</span>,\n  <span class=\"hljs-string\">'right'</span> : <span class=\"hljs-literal\">null</span>\n}\nMYAPP.coordinate = {\n   <span class=\"hljs-string\">'left'</span> : <span class=\"hljs-literal\">null</span>,\n   <span class=\"hljs-string\">'right'</span> : <span class=\"hljs-literal\">null</span>\n}\n\nMYAPP.calculator.left = <span class=\"hljs-number\">10</span>;\nMYAPP.calculator.right = <span class=\"hljs-number\">20</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-keyword\">return</span> MYAPP.calculator.left + MYAPP.calculator.right;\n}\n<span class=\"hljs-built_in\">document</span>.write(sum());    <span class=\"hljs-comment\">//30</span>\n</code></pre>\n<p>MYAPP 전역변수 하나만 생성하고, 그 안에 필요한 전역변수를 정의한다.</p>\n<p>예제5) 전역변수 안쓰는 방법2</p>\n<pre><code class=\"language-javascript\">(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n<span class=\"hljs-keyword\">var</span> MYAPP = {}\nMYAPP.calculator = { <span class=\"hljs-comment\">//객체의 속성(calculator)에도 객체를 생성.</span>\n  <span class=\"hljs-string\">'left'</span> : <span class=\"hljs-literal\">null</span>,\n  <span class=\"hljs-string\">'right'</span> : <span class=\"hljs-literal\">null</span>\n}\nMYAPP.coordinate = {\n   <span class=\"hljs-string\">'left'</span> : <span class=\"hljs-literal\">null</span>,\n   <span class=\"hljs-string\">'right'</span> : <span class=\"hljs-literal\">null</span>\n}\n\nMYAPP.calculator.left = <span class=\"hljs-number\">10</span>;\nMYAPP.calculator.right = <span class=\"hljs-number\">20</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-keyword\">return</span> MYAPP.calculator.left + MYAPP.calculator.right;\n}\n<span class=\"hljs-built_in\">document</span>.write(sum());    <span class=\"hljs-comment\">//30</span>\n}());    <span class=\"hljs-comment\">//익명함수</span>\n</code></pre>\n<p>전역변수가 절대 존재하지 않게 개발할 때, 익명함수. 일회성함수를 이용한다.<br>\nJquery와 같은 라이브러리에서 모듈화 기법으로 많이 사용한다.</p>\n<p>예제6) 자바와의 차이점. for문 안에서의 변수.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">for</span>( <span class=\"hljs-keyword\">var</span> i =<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">1</span>; i++){\n  <span class=\"hljs-keyword\">var</span> name= <span class=\"hljs-string\">\"local no!\"</span>;\n}\nalert(name);    <span class=\"hljs-comment\">//local no!</span>\n</code></pre>\n<p>자바는 반복문, 조건문 안에서 선언된 변수를 지역변수 취급하기 때문에 위와 같은 로직으로 실행시키면 에러가 난다.<br>\n그러나 자바스크립트에서 해당 변수는 전역변수이다.</p>\n<p>예제7) 정적 유효범위</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">5</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">a</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">10</span>;\n  b();\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">b</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-built_in\">document</span>.write(i);    <span class=\"hljs-comment\">//누구의 i일까?</span>\n}\na();    <span class=\"hljs-comment\">//5가 출력된다!</span>\n</code></pre>\n<p>함수에서 변수를 찾을 때, 함수 내 지역변수를 먼저 찾고. 전역변수를 찾는다.<br>\n<span class=\"clr-note\">\n**사용(호출)될 때가 아니라 정의될 때의 전역변수가 사용된다. -&gt; 정적 유효범위\n</span></p>\n",
		"updatedAt": "2020-01-22T18:21:09.422Z",
		"id": "2018-01-11-javascript-opentutorials-function-1",
		"filename": "javascript\\2018-01-11-javascript-opentutorials-function-1.json"
	},
	{
		"layout": "post-content",
		"title": "(생활코딩) javascript 함수지향2",
		"date": "2018-01-13T00:00:00.000Z",
		"tags": [
			"javascript"
		],
		"category": [
			"javascript"
		],
		"body": "<p>생활코딩 함수지향 파트 중 값으로서의 함수와 콜백에 대한 내용을 정리했습니다.</p>\n<hr>\n<h1>1. 값으로서 함수</h1>\n<p>예제1) 자바스크립트에서는 함수도 객체이며, 함수도 값이 될 수 있다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">a</span>(<span class=\"hljs-params\"></span>)</span>{}     <span class=\"hljs-comment\">//함수는 a라는 변수에 담겨진 값.</span>\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{}\n</code></pre>\n<p>예제2) 함수는 객체 안에 저장될 수 있다.</p>\n<pre><code class=\"language-javascript\">a = {\n   <span class=\"hljs-attr\">b</span> : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n   }\n}\n</code></pre>\n<p>b는 key, 객체 안에서 변수 역할(어떤 값을 저장하고 있기 때문) = 속성(property)<br>\n속성에 저장된 값이 함수면 메소드라 부름.<br>\n즉, a라는 객체에 b라는 속성이 있는데, 이 속성의 값은 함수(메소드)다.</p>\n<p>예제3) 함수는 변수, 객체에 저장될 수 있고 인자로도 사용할 수 있다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">cal</span> (<span class=\"hljs-params\">func, num</span>)</span>{\n   <span class=\"hljs-keyword\">return</span> func(num)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">increase</span> (<span class=\"hljs-params\">num</span>)</span>{\n   <span class=\"hljs-keyword\">return</span> num+<span class=\"hljs-number\">1</span>;\n}\nalert (cal (increase, <span class=\"hljs-number\">1</span>) );\n\n<span class=\"hljs-comment\">// 위 코드는 아래와 같이 해석될 수 있다.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">cal</span> (<span class=\"hljs-params\"> func, num</span>)</span>{\n   <span class=\"hljs-keyword\">var</span> func = increase (num){\n       <span class=\"hljs-keyword\">return</span> num+<span class=\"hljs-number\">1</span>\n   }\n}\n<span class=\"hljs-comment\">// 즉, func(1) =&gt; 2가 출력됨.</span>\n</code></pre>\n<p>예제4) 함수를 리턴 값으로도 사용할 수 있다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">cal</span> (<span class=\"hljs-params\">mode</span>)</span>{\n val funcs = {\n  <span class=\"hljs-string\">'plus'</span> : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">left, right</span>) </span>{ <span class=\"hljs-keyword\">return</span> left + right },\n  <span class=\"hljs-string\">'minus'</span> : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">left, right</span>) </span>{ <span class=\"hljs-keyword\">return</span> left - right }\n }\n <span class=\"hljs-keyword\">return</span> funcs[mode];\n}\nalert (cal(<span class=\"hljs-string\">'plus'</span>)(<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>));\n</code></pre>\n<p>return funcs[‘plus’] 는 funcs 객체의 plus 속성의 값인 function(left, right) {return left+right} 메소드를 리턴시킨다.<br>\ncal(‘plus’)(2,1)은 cal(‘plus’)함수의 인자 값으로 2, 1을 전달하겠다는 의미이다.<br>\ncal(‘plus’)는 function(left, right) {return left+right} 이므로 알럿창에 3이 뜬다.</p>\n<p>예제5) 함수를 배열의 값으로 사용할 수 있다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> process = [\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">input</span>) </span>{<span class=\"hljs-keyword\">return</span> input + <span class=\"hljs-number\">10</span>;},\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">input</span>) </span>{<span class=\"hljs-keyword\">return</span> input * input;},\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">input</span>) </span>{<span class=\"hljs-keyword\">return</span> input / <span class=\"hljs-number\">2</span>;}\n];\n<span class=\"hljs-keyword\">var</span> input = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i  &lt; process.length; i++)\n   input = process[i](input);\n\nalert(input); <span class=\"hljs-comment\">//60.5</span>\n</code></pre>\n<h1>2. 콜백</h1>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> numbers = [<span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>];\nnumbers.sort();    <span class=\"hljs-comment\">// numbers는 배열객체, sort()는 메소드(내장메소드)</span>\n<span class=\"hljs-built_in\">console</span>.log(numbers) <span class=\"hljs-comment\">// 1, 10, 2, 20, 3, 4, 5, 6, 7, 8, 9 - 문자 기준으로 정렬한 듯.</span>\n</code></pre>\n<span class=\"clr-grey\">\nsort()    \narray.sort (sortfunc)    \n반환값 : 정렬된 배열\n</span>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> numbers = [<span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>];\n<span class=\"hljs-keyword\">var</span> sortfunc = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a, b</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(a &gt; b)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(a &lt; b)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    <span class=\"hljs-keyword\">else</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n<span class=\"hljs-keyword\">var</span> sortfunc = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a, b</span>)</span>{\n    <span class=\"hljs-keyword\">return</span> a-b;    <span class=\"hljs-comment\">//역순은 return b-a;</span>\n}   \n    numbers.sort(sortfunc);    <span class=\"hljs-comment\">// 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20</span>\n</code></pre>\n<p>sortfunc가 콜백함수가 된다.<br>\n함수는 값으로서 사용할 수 있기 때문에 sortfunc를 sort에 인자로 전달함으로서 sort 메소드를 사용자가 원하는 방식으로 바꿀 수 있다.</p>\n<p><span class=\"clr-note\">**콜백은 비동기처리에서 유용하게 사용된다.</span></p>\n",
		"updatedAt": "2020-01-22T18:21:09.421Z",
		"id": "2018-01-13-javascript-opentutorials-function-2",
		"filename": "javascript\\2018-01-13-javascript-opentutorials-function-2.json"
	},
	{
		"layout": "post-content",
		"title": "(생활코딩) javascript 함수지향3",
		"date": "2018-01-13T00:00:00.000Z",
		"tags": [
			"javascript"
		],
		"category": [
			"javascript"
		],
		"body": "<p>생활코딩 함수지향 파트 중 클로저에 대한 내용을 정리했습니다.</p>\n<hr>\n<h1>1. 클로저의 개념</h1>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">outter</span>(<span class=\"hljs-params\"></span>) </span>{ \n  <span class=\"hljs-keyword\">var</span> title = <span class=\"hljs-string\">'coding everybody'</span>; \n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ \n    alert(title); \n  } \n} \ninner = outter(); \ninner();\n</code></pre>\n<p>함수 outter의 리턴 값은 내부함수이며 변수 inner에 내부함수가 값으로 저장된다.<br>\noutter 호출이 종료된 순간, outter는 사라진다.<br>\n하지만, inner()를 실행했을 때 알럿창에 coding everybody가 보인다.</p>\n<p>왜?<br>\n<span class=\"clr-note\">내부함수는 외부함수가 종료되도 외부함수에 접근할 수 있다.</span></p>\n<h1>2. private variable</h1>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">factory_movie</span>(<span class=\"hljs-params\">title</span>)</span>{ \n    <span class=\"hljs-keyword\">return</span>{ \n        <span class=\"hljs-attr\">get_title</span> : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ \n            <span class=\"hljs-keyword\">return</span> title; \n        }, \n        <span class=\"hljs-attr\">set_tile</span> : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">_title</span>)</span>{ \n            <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">typeof</span> _title === <span class=\"hljs-string\">'String'</span>){ \n                title = _title; \n            } <span class=\"hljs-keyword\">else</span>{ \n                alert(<span class=\"hljs-string\">'제목은 문자열이여야 합니다.'</span>); \n            } \n        } \n    } \n} \nghost = factory_movie(<span class=\"hljs-string\">'Ghost in the shell'</span>); \nmatrix = factory_movie(<span class=\"hljs-string\">'Matrix'</span>); \nalert(ghost.get_title());    <span class=\"hljs-comment\">//Ghost in the shell </span>\nalert(matrix.get_tiel());    <span class=\"hljs-comment\">//Matrix</span>\n</code></pre>\n<p>factory_movie의 리턴 값은 get_title, set_title 메소드를 속성으로 가지고 있는 객체이다.<br>\nghost, matrix 변수는 객체를 담게된다.<br>\nfactory_movie 호출 후, 함수의 생이 종료되어도 ghost, matrix를 통해 함수의 지역변수인 title에 접근할 수 있다.</p>\n<p>왜 private variable을 사용해야 하는가?<br>\n<span class=\"clr-note\">외부에서 title 변수를 수정해도 ghost, matrix가 가진 title의 맥락에는 영향을 주지 않는다.    즉, 데이터의 수정과 저장을 안전하게 할 수 있다.</span></p>\n<h1>3. 클로저의 응용</h1>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> arr = []; \n<span class=\"hljs-keyword\">for</span>( <span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">5</span>; i++){\n     arr[i] = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ \n        <span class=\"hljs-built_in\">console</span>.log(i);\n     } \n} \n \n<span class=\"hljs-keyword\">for</span>( <span class=\"hljs-keyword\">var</span> index <span class=\"hljs-keyword\">in</span> arr ){ \n    <span class=\"hljs-built_in\">console</span>.log(arr[index]()); \n} \n<span class=\"hljs-comment\">//결과는 5 5 5 5 5</span>\n</code></pre>\n<p>함수가 실행되는 시점의 변수가 내부함수에 저장된다.<br>\n두번째 반목문에서 배열객체의 함수를 실행하는 순간의 i가 콘솔에 찍히게 된다.<br>\n그러나, i는 첫번째 포문에 의해 이미 5가 되어버린 상태이므로 5만 다섯번 찍히게 된다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> arr = []; \n<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">5</span>; i++){ \n    arr[i] = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">id</span>)</span>{ \n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ \n            <span class=\"hljs-keyword\">return</span> id; \n        } \n    }(i); \n} \n \n<span class=\"hljs-keyword\">for</span>( <span class=\"hljs-keyword\">var</span> index <span class=\"hljs-keyword\">in</span> arr){ \n    <span class=\"hljs-built_in\">console</span>.log(arr[index]());  \n} \n<span class=\"hljs-comment\">//결과는 0,1,2,3,4</span>\n</code></pre>\n<p>외부함수의 인자 값으로 i가 전달되고, 내부함수는 이 시점의 i를 저장한다.<br>\n첫번째 포문에서 외부함수가 i를 인자값으로 하면서 실행되는 시점에서 내부함수가 정의된다.</p>\n",
		"updatedAt": "2020-01-22T18:21:10.070Z",
		"id": "2018-01-13-javascript-opentutorials-function-3",
		"filename": "javascript\\2018-01-13-javascript-opentutorials-function-3.json"
	},
	{
		"layout": "post-content",
		"title": "(생활코딩) javascript 함수지향4",
		"date": "2018-01-13T00:00:00.000Z",
		"tags": [
			"javascript"
		],
		"category": [
			"javascript"
		],
		"body": "<p>생활코딩 함수지향 파트 중 arguments와 apply()에 대한 내용을 정리했습니다.</p>\n<hr>\n<h1>1. arguments</h1>\n<pre><code class=\"language-javascript\">function sum(){ \n    var i, _sum = 0; \n    for( i=0; i&lt; arguments.length; i++){ \n        document.write(i +  \":\" + arguments[i] + &lt;'br/&gt;'); \n        _sum += arguments[i];  \n    } \n    return _sum; \n} \ndocument.write('result : ' + sum(1,2,3,4)); \n</code></pre>\n<p>arguments는 사용자가 전달한 인자들이 담겨있는 객체다.</p>\n<ul>\n<li>.length를 통해 함수가 몇개의 인자 전달 받았는 지를 알 수 있다.</li>\n<li>arguments[i] 를 통해 각 자리의 인자 값을 알 수 있다.</li>\n</ul>\n<p>자바스크립트는 매개변수의 수가 함수의 정의와 달라도 에러가 발생하지 않는다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">one</span>(<span class=\"hljs-params\">arg1</span>)</span>{ \n    <span class=\"hljs-built_in\">console</span>.log( \n        <span class=\"hljs-string\">'one.length'</span>, one.length,         <span class=\"hljs-comment\">//1 </span>\n        <span class=\"hljs-string\">'arguments'</span>, <span class=\"hljs-built_in\">arguments</span>.length <span class=\"hljs-comment\">//2 </span>\n    ); \n}  \none(<span class=\"hljs-string\">'val1'</span>, <span class=\"hljs-string\">'val2'</span>);\n</code></pre>\n<p>위의 차이점을 이용해보면. 함수에 정의된 매개변수의 갯수와 실제 전달받는 인자의 갯수를 비교해서 대상 함수가 올바르게 사용되었는 지를 체크 할 수 있다.</p>\n<h1>2. apply() 내장함수</h1>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span>(<span class=\"hljs-params\">arg1, arg2</span>)</span>{ \n    <span class=\"hljs-keyword\">return</span> arg1+arg2; \n} \nsum(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>)    <span class=\"hljs-comment\">//3 </span>\nsum.apply        <span class=\"hljs-comment\">//function apply(){[native code]}     native code : 내장함수란 뜻 </span>\nsum.apply(<span class=\"hljs-literal\">null</span>, [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>]);    <span class=\"hljs-comment\">//3     -첫번째 인자가 null로 들어갈 때는, 쓰지않기.</span>\n</code></pre>\n<p>왜 사용할까?</p>\n<pre><code class=\"language-javascript\">o1 = {<span class=\"hljs-attr\">val1</span> :<span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">val2</span>:<span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">val3</span>:<span class=\"hljs-number\">3</span>} \no2 = {<span class=\"hljs-attr\">v1</span>:<span class=\"hljs-number\">10</span>, <span class=\"hljs-attr\">v2</span>:<span class=\"hljs-number\">50</span>, <span class=\"hljs-attr\">v3</span>:<span class=\"hljs-number\">100</span>, <span class=\"hljs-attr\">v4</span>:<span class=\"hljs-number\">25</span>} \n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span>(<span class=\"hljs-params\"></span>)</span>{ \n    <span class=\"hljs-keyword\">var</span> _sum = <span class=\"hljs-number\">0</span>; \n    <span class=\"hljs-keyword\">for</span>( name <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">this</span>){ \n      _sum += <span class=\"hljs-keyword\">this</span>[name]; \n    } \n    <span class=\"hljs-keyword\">return</span> _sum; \n} \nalert(sum.apply(o1))    <span class=\"hljs-comment\">//6 </span>\nalert(sum.apply(o2))    <span class=\"hljs-comment\">//185</span>\n</code></pre>\n<p>o1 객체를 sum의 인자 값으로 전달한다.<br>\nthis는 var this = o1; 과 암시적으로 같다.<br>\n실행되는 그 순간에는 o1이라는 객체의 메소드 sum이 된다는 것.<br>\n즉, o1 = { va1 : 1, val2 : 2, val3 : 3, sum : sum} 에 o1.sum()과 같다.</p>\n",
		"updatedAt": "2020-01-22T18:21:10.070Z",
		"id": "2018-01-13-javascript-opentutorials-function-4",
		"filename": "javascript\\2018-01-13-javascript-opentutorials-function-4.json"
	},
	{
		"layout": "post-content",
		"title": "(생활코딩) javascript 객체지향1",
		"date": "2018-01-13T00:00:00.000Z",
		"tags": [
			"javascript"
		],
		"category": [
			"javascript"
		],
		"body": "<p>생활코딩 객체지향에 대한 내용을 정리했습니다.</p>\n<hr>\n<p>객체(object)는 연관되어 있는 것(변수, 메소드)들을 그룹화한 것, 각 그룹화된 것은 독립성을 가지는 부품이 된다.</p>\n<h1>1. 객체의 생성 방법</h1>\n<p>this는 함수가 속해있는 객체인 person을 가리킨다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> person = {}; \nperson.name = <span class=\"hljs-string\">'egoing'</span>; \nperson.introduce = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ \n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'My name is'</span> + <span class=\"hljs-keyword\">this</span>.name; \n} \n<span class=\"hljs-built_in\">document</span>.write( person.introduce());\n</code></pre>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> person = { \n    <span class=\"hljs-string\">'name'</span> : <span class=\"hljs-string\">'egoing'</span>, \n    <span class=\"hljs-string\">'introduce'</span> : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ \n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'My name is'</span> + <span class=\"hljs-keyword\">this</span>.name;     \n    } \n}\n</code></pre>\n<h1>2. 생성자와 new</h1>\n<p>생성자는 객체를 만드는 역할을 하는 함수.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\"></span>)</span>{} \n<span class=\"hljs-keyword\">var</span> p0 = Person();    <span class=\"hljs-comment\">//undefined </span>\n<span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> Person();    <span class=\"hljs-comment\">//Person{} 비어있는 객체</span>\n</code></pre>\n<p>new Person()<br>\nPerson() 함수가 객체의 참조자가 될 수 있다.</p>\n<p>자바는 클래스 안에 생성자가 있고, 클래스의 객체를 만든다.<br>\n자바스크립트에서는 생성자가 함수일 뿐, 어디에 속해있지 않다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\">name</span>)</span>{ \n    <span class=\"hljs-keyword\">this</span>.name = name; \n    <span class=\"hljs-keyword\">this</span>.introduce = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ \n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'My name is '</span>+<span class=\"hljs-keyword\">this</span>.name; \n    } \n} \n \n<span class=\"hljs-keyword\">var</span> p1 = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">'egoing'</span>); \n<span class=\"hljs-keyword\">var</span> p2 = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">'leezche'</span>); \n \n<span class=\"hljs-built_in\">document</span>.write(p1.introduce());    <span class=\"hljs-comment\">//My name is egoing </span>\n<span class=\"hljs-built_in\">document</span>.write(p2.introduce());    <span class=\"hljs-comment\">//My name is leezche</span>\n</code></pre>\n<p>생성자 Person이라는 함수를 정의했다.<br>\nPerson 앞에 new가 존재하기 때문에 함수가 아닌 생성자가 된다.<br>\n생성자 함수가 하는 일은 객체의 초기화이며, 객체가 가지고 있는 정보, 객체가 할 수 있는 일을 정의하게 된다.<br>\n덕분에 코드의 재사용성이 높아진다.</p>\n<h1>3. 함수와 this</h1>\n<p>전역변수와 전역함수는 모두 window라는 전역객체의 속성과 메소드다.<br>\n<span class=\"clr-grey\">node.js에서 전역객체는 global이다.</span></p>\n<h2>1) 메소드와 this</h2>\n<p>this는 함수를 어떻게 호출하느냐에 따라 this를 가리키는 대상이 달라진다.</p>\n<p>전역함수의 this는 window와 같다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span>(<span class=\"hljs-params\"></span>)</span>{ \n    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">window</span> === <span class=\"hljs-keyword\">this</span>){ \n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"window === this\"</span>);  \n    } \n}  \nfunc();    <span class=\"hljs-comment\">//window === this</span>\n</code></pre>\n<p>객체의 소속인 메소드의 this는 그 객체를 가르킨다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> o = { \n    <span class=\"hljs-attr\">func</span> : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ \n        <span class=\"hljs-keyword\">if</span>(o === <span class=\"hljs-keyword\">this</span>){ \n            <span class=\"hljs-built_in\">document</span>.write(<span class=\"hljs-string\">\"o === this\"</span>);     \n         } \n    } \n} \no.func();    <span class=\"hljs-comment\">//o===this</span>\n</code></pre>\n<h2>2) 생성자와 this</h2>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> funcThis = <span class=\"hljs-literal\">null</span>; \n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Func</span>(<span class=\"hljs-params\"></span>)</span>{ \n    funcThis = <span class=\"hljs-keyword\">this</span>; \n} \n \n<span class=\"hljs-keyword\">var</span> o1 = Func(); \n<span class=\"hljs-keyword\">if</span>( funcThis === <span class=\"hljs-built_in\">window</span>){ \n    <span class=\"hljs-built_in\">document</span>.write(<span class=\"hljs-string\">'window'</span>); \n} \n \n<span class=\"hljs-keyword\">var</span> o2 = <span class=\"hljs-keyword\">new</span> Func(); \n<span class=\"hljs-keyword\">if</span>(funcThis === o2){ \n    <span class=\"hljs-built_in\">document</span>.write(<span class=\"hljs-string\">'o2 &lt;/br&gt;'</span>); \n} \n<span class=\"hljs-comment\">// window, o2 둘다 출력됨.</span>\n</code></pre>\n<p>Func를 생성자로 사용되면 this는 객체를 가리키고, 함수로 사용되면 this는 window는 가리킨다.</p>\n<h2>3) 객체로서 함수</h2>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span>(<span class=\"hljs-params\">x,y</span>)</span>{<span class=\"hljs-keyword\">return</span> x+y;} \n<span class=\"hljs-keyword\">var</span> sum2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Function</span>(<span class=\"hljs-string\">'x'</span>,<span class=\"hljs-string\">'y'</span>,<span class=\"hljs-string\">'return x+y'</span>);\n</code></pre>\n<p>sum이라는 함수는 sum이라는 객체를 만든 것이다.<br>\n<span class=\"clr-grey\">\nfunction sum(){} 함수 리터럴<br>\nvar o ={} 객체리터럴<br>\nvar a = [0,1,2] 배열 리터럴<br>\n편리하게 값을 만들 수 있는 문법적인 체계를 리터럴이라고 한다.\n</span></p>\n<h2>4) apply와 this</h2>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> o = {} \n<span class=\"hljs-keyword\">var</span> p = {} \n \n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span>(<span class=\"hljs-params\"></span>)</span>{ \n    <span class=\"hljs-keyword\">switch</span>(<span class=\"hljs-keyword\">this</span>){ \n        <span class=\"hljs-keyword\">case</span> o :  \n            <span class=\"hljs-built_in\">document</span>.write(<span class=\"hljs-string\">'o'</span>); \n            <span class=\"hljs-keyword\">break</span>;\n        <span class=\"hljs-keyword\">case</span> p :  \n            <span class=\"hljs-built_in\">document</span>.write(<span class=\"hljs-string\">'p'</span>); \n            <span class=\"hljs-keyword\">break</span>; \n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-built_in\">window</span> :  \n            <span class=\"hljs-built_in\">document</span>.write(<span class=\"hljs-string\">'window'</span>); \n            <span class=\"hljs-keyword\">break</span>; \n    } \n} \n \nfunc();              <span class=\"hljs-comment\">//window </span>\nfunc.apply(o);    <span class=\"hljs-comment\">//o</span>\nfunc.apply(p);    <span class=\"hljs-comment\">//p</span>\n</code></pre>\n<p>자바스크립트의 this는 변화무쌍하다.</p>\n",
		"updatedAt": "2020-01-22T18:21:09.422Z",
		"id": "2018-01-13-javascript-opentutorials-object-1",
		"filename": "javascript\\2018-01-13-javascript-opentutorials-object-1.json"
	},
	{
		"layout": "post-content",
		"title": "(생활코딩) javascript 객체지향2",
		"date": "2018-01-13T00:00:00.000Z",
		"tags": [
			"javascript"
		],
		"category": [
			"javascript"
		],
		"body": "<p>생활코딩 객체지향 파트 중 상속과 프로토타입에 대한 내용을 정리했습니다.</p>\n<hr>\n<h1>1. 상속</h1>\n<p>상속을 하기 위한 준비 작업</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\">name</span>)</span>{ \n    <span class=\"hljs-keyword\">this</span>.name = name; \n} \n \nPerson.prototype.name = <span class=\"hljs-literal\">null</span>; \nPerson.prototype.introduce = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ \n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'My name is'</span> + <span class=\"hljs-keyword\">this</span>.name; \n} \n \n<span class=\"hljs-keyword\">var</span> p1 = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">'egoing'</span>); \n<span class=\"hljs-built_in\">document</span>.write(p1.introduce());    <span class=\"hljs-comment\">//My name is egoing</span>\n</code></pre>\n<p>객체의 프로퍼티 정의 방법은 생성자를 이용하는 것과 프로토타입을 이용하는 것이 있다.<br>\nPerson 객체에는 prototype이라는 속성이 있는 데 그 안에는 어떤 객체가 있다.<br>\n.name을 통해 그 객체에 값을 줄 수 있다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\">name</span>)</span>{ \n   <span class=\"hljs-keyword\">this</span>.name = name; \n}\nPerson.prototype.name = <span class=\"hljs-literal\">null</span>; \nPerson.prototype.introduce = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ \n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'My name is'</span> + <span class=\"hljs-keyword\">this</span>.name; \n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Programmer</span>(<span class=\"hljs-params\">name</span>)</span>{ \n    <span class=\"hljs-keyword\">this</span>.name = name; \n}\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Designer</span>(<span class=\"hljs-params\">name</span>)</span>{ \n    <span class=\"hljs-keyword\">this</span>.name = name; \n}\n \n<span class=\"hljs-comment\">/**상속방법**/</span>\nDesigner.prototype = <span class=\"hljs-keyword\">new</span> Person();\nDesigner.prototype.design= <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"beautiful!\"</span>; \n} \nProgrammer.prototype = <span class=\"hljs-keyword\">new</span> Person(); \nProgrammer.prototype.coding = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ \n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello world!\"</span>; \n}\n \n<span class=\"hljs-keyword\">var</span> p1 = <span class=\"hljs-keyword\">new</span> Programmer(<span class=\"hljs-string\">'egoing'</span>); \n<span class=\"hljs-built_in\">document</span>.write(p1.introduce() + <span class=\"hljs-string\">''</span>);    <span class=\"hljs-comment\">//My name is egoing이 출력됨 </span>\n<span class=\"hljs-built_in\">document</span>.write(p1.coding() + <span class=\"hljs-string\">''</span>);    <span class=\"hljs-comment\">//hello world! </span>\n \n<span class=\"hljs-keyword\">var</span> p2 = <span class=\"hljs-keyword\">new</span> Desiner(<span class=\"hljs-string\">'leezche'</span>); \n<span class=\"hljs-built_in\">document</span>.write(p2.design() + <span class=\"hljs-string\">''</span>);    <span class=\"hljs-comment\">//beautiful!</span>\n</code></pre>\n<p>Programmer에는 introduce 속성이 정의되어 있지않은데 어떻게 사용할 수 있었을까?<br>\nPerson의 introduce를 상속받았기 때문이다.</p>\n<p>객체를 생성할 때, 자바스크립트는 생성자 함수가 prototype라는 프로퍼티를 갖고 있는 지 확인한다.<br>\n그리고 생성자 함수에 들어있는 객체와 똑같은 객체를 만들어서 생성자의 결과로 리턴을 해준다.</p>\n<p>name과 introduce라는 프로퍼티가 prototype이라는 객체가 가지고 있다.<br>\n즉, prototype이라는 객체를 리턴한다?<br>\n그래서 Programmer의 prototype이라는 프로퍼티에 저장된다.</p>\n<span class=\"clr-note\">\n*생성자의 prototype에 상속받을 객체를 new 한다.    \n*Programmer.prototype = new Person()\n</span>\n<p>기본적으로 가지고있는 property를 가진 객체를 생성하기 위해서 객체 리터럴 대신, new라는 키워드를 사용한다.</p>\n<h1>2. prototype</h1>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Ultra</span>(<span class=\"hljs-params\"></span>)</span>{} \nUltra.prototype.ultraProp = <span class=\"hljs-literal\">true</span>; \n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Super</span>(<span class=\"hljs-params\"></span>)</span>{} \nSuper.prototype = <span class=\"hljs-keyword\">new</span> Ultra(); \n \n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sub</span>(<span class=\"hljs-params\"></span>)</span>{} \nSub.prototype = <span class=\"hljs-keyword\">new</span> Super(); \n \n<span class=\"hljs-keyword\">var</span> o = <span class=\"hljs-keyword\">new</span> Sub() \n<span class=\"hljs-built_in\">console</span>.log(o.ultraProp);    <span class=\"hljs-comment\">//true출력됨. </span>\n \n<span class=\"hljs-comment\">//1) </span>\no.ultraProp = <span class=\"hljs-number\">1</span>; \n<span class=\"hljs-built_in\">console</span>.log(o.ultraProp);    <span class=\"hljs-comment\">//1</span>\n</code></pre>\n<p>o.ultraProp o라는 객체가 ultraProp를 가지고 있는지 찾는다. 그래서 1이 출력됨.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Ultra</span>(<span class=\"hljs-params\"></span>)</span>{} \nUltra.prototype.ultraProp = <span class=\"hljs-literal\">true</span>; \n \n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Super</span>(<span class=\"hljs-params\"></span>)</span>{} \nSuper.prototype = <span class=\"hljs-keyword\">new</span> Ultra(); \n \n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sub</span>(<span class=\"hljs-params\"></span>)</span>{} \nSub.prototype = <span class=\"hljs-keyword\">new</span> Super(); \nSub.prototype.ultraProp = <span class=\"hljs-number\">2</span>; \n \n<span class=\"hljs-keyword\">var</span> o = <span class=\"hljs-keyword\">new</span> Sub() \n<span class=\"hljs-built_in\">console</span>.log(o.ultraProp);    <span class=\"hljs-comment\">//2가 출력됨</span>\n</code></pre>\n<p>o객체에 ultraProp 프로퍼티를 찾는다. 없으면 o라는 객체의 생성자를 알아 낸후, 이 생성자의 프로토타입 객체를 뒤져서 그 객체의 propery에 ultraProp가 있는 지 찾는다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Ultra</span>(<span class=\"hljs-params\"></span>)</span>{} \nUltra.prototype.ultraProp = <span class=\"hljs-literal\">true</span>; \n \n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Super</span>(<span class=\"hljs-params\"></span>)</span>{} \nSuper.prototype = <span class=\"hljs-keyword\">new</span> Ultra(); \n \n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sub</span>(<span class=\"hljs-params\"></span>)</span>{} \n<span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-keyword\">new</span> Super(); \ns.ultraProp = <span class=\"hljs-number\">3</span>; \nSub.prototype = s;  \n \n<span class=\"hljs-keyword\">var</span> o = <span class=\"hljs-keyword\">new</span> Sub() \n<span class=\"hljs-built_in\">console</span>.log(o.ultraProp);    <span class=\"hljs-comment\">//3이 출력됨</span>\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:21:10.070Z",
		"id": "2018-01-13-javascript-opentutorials-object-2",
		"filename": "javascript\\2018-01-13-javascript-opentutorials-object-2.json"
	},
	{
		"layout": "post-content",
		"title": "Vue2 65분만에 배우기!",
		"date": "2018-04-07T00:00:00.000Z",
		"tags": [
			"vuejs"
		],
		"category": [
			"javascript"
		],
		"body": "<p>유튜브 영상 The Vue Tutorial for 2018 - Learn Vue 2 in 65 Minutes 중 몰랐던 내용 정리한 글입니다.</p>\n<h2>1. Vue-CLI 설치하기</h2>\n<p>Vue-CLI를 통해 Vue 프로젝트를 빠르고 쉽게 생성할 수 있다.</p>\n<pre><code>&gt; mkdir vue-toy\n&gt; cd vue-toy\n&gt; npm install -g @vue/cli        -- Vue-CLI 설치\n&gt; vue create vue-voca            -- Vue 프로젝트 생성[ vue create 프로젝트이름 ]\n</code></pre>\n<p>2018.04.09추가) yarn 설치 후, yarn을 통해 Vue-Cli 설치하는 방법</p>\n<pre><code>&gt; npm install -g yarn\n&gt; yarn global add @vue/cli\n</code></pre>\n<p>뷰 프로젝트를 생성하면 다음과 같은 프롬프트를 볼 수 있다.</p>\n<pre><code>Vue CLI v3.0.0-beta.6\n?Please Pick a preset : (Use arrow Keys)\n&gt; default (babel, eslint)\n   menually select features\n</code></pre>\n<p>2018.04.09추가)</p>\n<ul>\n<li>Vue-Cli의 기본 템플릿은 babel, eslint, unit-mocha를 포함한다.</li>\n</ul>\n<p>default로 생성을 성공적으로 완료하면 다음과 같이 명령어를 실행한다.</p>\n<pre><code>&gt; cd vue-voca\n&gt; npm run serve\n</code></pre>\n<p>성공적으로 컴파일이 되면 <a href=\"http://localhost:8080/\">http://localhost:8080/</a> 로 들어가본다.\n아래와 같은 화면을 볼 수 있다면, 성공적으로 Vue.js App을 생성한 것이다.</p>\n<p><img src=\"/assets/images/2018-04-07-img.png\" alt=\"화면\"></p>\n<h2>2. Vue Form Validation</h2>\n<p>VeeValidate는 폼 유효성 체크를 위한 패키지다.</p>\n<p>설치방법</p>\n<pre><code>&gt; yarn add vee-validate\n#또는\n&gt; npm install vee-validate --save\n</code></pre>\n<p>사용방법</p>\n<pre><code>import VeeValidate from 'vee-validate';\nVue.use(veeValidate);\n</code></pre>\n<h2>3. Vue router</h2>\n<pre><code>&gt; npm add vue-router\n#또는\n&gt; yarn add vue-router\n</code></pre>\n<pre><code>import vue from 'vue'\nimport Router from 'vue-router'\n</code></pre>\n<p>vue 후에 vue-router를 임포트해야한다.</p>\n<p>동영상에서 진행한 프로젝트를 따라한 <a href=\"https://github.com/devgaram/vueStudy\">깃으로 가기</a>. 개인적인 주석이 포함되어있습니다.</p>\n",
		"updatedAt": "2020-01-22T18:22:59.005Z",
		"id": "2018-04-07-vue2",
		"filename": "javascript\\2018-04-07-vue2.json"
	},
	{
		"layout": "post-content",
		"title": "자바스크립트의 실행 컨텍스트",
		"date": "2019-12-09T00:00:00.000Z",
		"categories": [
			"javascript"
		],
		"body": "<p>인사이드 자바스크립트를 정리하며 작성한 포스팅입니다.<br>\n이 포스팅은 실행 컨텍스트의 개념과 생성 과정에 대해 정리한 내용이며 실행 컨텍스트 이해를 위한 필수 개념인 스코프 체인과 this 바인딩에 대해서는 추후 정리할 예정입니다.</p>\n<h1>실행 컨텍스트란?</h1>\n<p>콜 스택에 쌓이는 각각의 정보들이 하나의 실행 컨텍스트라고 생각하며 아래의 문구를 읽어보자.</p>\n<ul>\n<li>ECMAScript는 <strong>실행 가능한 코드를 형상화하고 구분하는 추상적인 개념</strong>으로 정의한다.</li>\n<li><strong>실행 가능한 자바스크립트 코드 블록이 실행되는 환경</strong>으로 코드 블록 안에는 변수, 객체, 실행 가능한 코드가 들어있다.</li>\n<li>스택의 TOP에 위치하는 실행 컨텍스트가 <strong>현재 실행되는 컨텍스트</strong>다.</li>\n<li>현재 실행되는 컨텍스트와 관련 없는 코드 블록이 실행되면 새로운 실행 컨텍스트가 생성되어 스택에 쌓이고 제어권이 생성된 컨텍스트로 이동한다.</li>\n</ul>\n<p>그렇다면 실행 컨텍스트가 형성되는 경우는 언제일까?<br>\nECMAScript에서 실행 컨텍스트가 형성되는 경우를 다음과 같이 규정하고 있다.</p>\n<ul>\n<li>전역 코드</li>\n<li>eval() 함수로 실행되는 코드</li>\n<li><strong>함수 안의 코드를 실행하는 경우</strong> (대부분의 경우)</li>\n</ul>\n<h1>실행 컨텍스트 생성 과정</h1>\n<p>자바스크립트에서 함수를 실행하여 실행 컨텍스트를 생성하면 자바스크립트 엔진은 다음 순서대로 작업을 실행한다.</p>\n<h2>1. 활성 객체 생성</h2>\n<p>실행 컨텍스트가 생성되면 엔진은 이 컨텍스트가 접근 할 수 있는 활성 객체를 생성하며 활성 객체에 앞으로 사용할 매개변수, 사용자 정의 변수 및 객체를 저장한다.</p>\n<h2>2. arguments 객체 생성</h2>\n<p>2단계에서는 arguments 객체를 생성하며 앞서 만들어진 활성 객체는 이 arguments 객체를 참조한다.</p>\n<p>잠깐 arguments 객체에 대해 알아보고 넘어가자</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span>(<span class=\"hljs-params\">arg1, arg2</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(arg1, arg2);\n}\n\nfunc() <span class=\"hljs-comment\">// undefined undefined</span>\nfunc(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// 1 undefined</span>\nfunc(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 1 2</span>\nfunc(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">// 1 2</span>\n</code></pre>\n<p>자바스크립트에서는 위 예제와 같이 함수 형식에 맞춰 인자 값을 넘겨주지 않아도 에러가 발생하지 않는다. 넘겨지지 않은 인자에는 <strong>undefined</strong>값이 할당되고, 초과된 인수는 무시된다.</p>\n<p>이러한 자바스크립트 특성 때문에 함수 코드를 작성할 때, 런타임 시에 호출된 인자의 개수를 확인하고 이에 따라 동작을 다르게 해줘야 할 경우가 있는 데, 이를 가능케 하는 게 바로 <strong>arguments 객체</strong>다.</p>\n<p>자바스크립트에서는 함수를 호출할 때 인수들과 함께 암묵적으로 arguments 객체가 함수 내부로 전달되며 arguments 객체에 넘긴 인자들이 배열형태로 저장된다. 단, 실제 배열이 아닌 <strong>유사 배열 객체</strong>다. 유사 배열 객체는 length 프로퍼티가 있어서 배열과 유사하게 동작하지만, 배열 메서드를 사용할 경우 에러가 발생한다.</p>\n<p>만약 arguments 객체에서 배열 메서드를 사용하고 싶다면 명시적으로 this를 바인딩 하면 된다.\ncall과 apply 메서드를 이용하여 this를 바인딩 할 수 있고, ES6 부터는 Arrays.from() 메서드와 전개 연산자를 사용할 수 있다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> args = <span class=\"hljs-built_in\">Array</span>.prototype.slice.apply(<span class=\"hljs-built_in\">arguments</span>); <span class=\"hljs-comment\">// Array.prototype.slice() 메서드를 호출한다. 단, this는 arguments 객체로 바인딩한다.</span>\n\n<span class=\"hljs-comment\">// ES6 이후</span>\n<span class=\"hljs-keyword\">var</span> args = <span class=\"hljs-built_in\">Array</span>.from(<span class=\"hljs-built_in\">arguments</span>);\n<span class=\"hljs-keyword\">var</span> args = [...arguments];\n</code></pre>\n<h2>3. 스코프 정보 생성</h2>\n<p>현재 컨텍스트의 유효 범위를 나타내는 <strong>스코프 정보</strong>를 생성한다.<br>\n스코프 정보는 현재 실행 중인 실행 컨텍스트 안에서 <strong>연결 리스트</strong>와 유사한 형식으로 만들어진다.<br>\n현재 컨텍스트에서 특정 변수에 접근해야 할 경우, 이 리스트를 사용하며 현재 컨텍스트의 변수뿐 아니라 상위 실행 컨텍스트의 변수도 접근이 가능하다. 이 리스트에서 변수를 찾지 못하면 정의되지 않은 변수로 판단하여 에러를 검출한다. 이 때, 활성 객체는 리스트의 맨 앞에 추가된다.</p>\n<p>스코프 체인이 어떻게 만들어지는 지는 추후에 포스팅할 예정이다.</p>\n<h2>4. 변수 생성</h2>\n<p>실행 컨텍스트 내부에서 사용되는 <strong>지역 변수</strong>의 생성이 이루어진다. 여기서 생성되는 변수는 변수 객체에 저장되며 변수 객체는 앞서 생성한 활성 객체다.</p>\n<ul>\n<li>지역 변수나 내부 함수를 메모리에 생성하고 지역 변수에는undefined를 할당한다.</li>\n<li>인자를 생성하고 값을 할당한다. 인자값이 넘겨지지 않았다면 undefined를 할당한다.</li>\n<li>메모리에 생성할 뿐, <strong>초기화</strong>는 이루어지지 않는다.</li>\n</ul>\n<h2>5. this 바인딩</h2>\n<p>함수 호출 패턴에 따라 this는 다른 객체를 참조(바인딩)하며, this가 참조하는 객체가 없으면 전역 객체를 참조한다. this 함수 호출 패턴은 중요한 개념이므로 추후에 포스팅할 예정이다.</p>\n<h2>6. 코드 실행</h2>\n<p>코드 블록의 여러 가지 표현식이 실행되면서 변수의 초기화 및 연산, 또 다른 함수 실행 등이 이루어진다.</p>\n<p><strong>참고</strong><br>\n전역 실행 컨텍스트는 일반적인 실행 컨텍스트와 약간 다르다.</p>\n<ul>\n<li>arguments 객체가 없다.</li>\n<li>스코프 체인은 전역 객체 하나만을 포함한다.</li>\n<li>전역 코드가 실행될 때 생성되는 컨텍스트다.</li>\n<li>전역 실행 컨텍스트의 <strong>변수 객체는 전역 객체(window)다.</strong> 따라서 전역적으로 선언된 함수와 변수는 전역 객체의 프로퍼티가 된다.</li>\n</ul>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">10</span>;\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">window</span>.a); <span class=\"hljs-comment\">// 10</span>\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:26:10.769Z",
		"id": "2019-12-09-javascript",
		"filename": "javascript\\2019-12-09-javascript.json"
	},
	{
		"layout": "post-content",
		"title": "ES6를 모르면 React 배우기가 어려워요.",
		"date": "2019-12-17T00:00:00.000Z",
		"tags": [
			"es6",
			"react"
		],
		"categories": [
			"javascript"
		],
		"body": "<p>React를 배워볼까? 하고 두근거리는 마음으로 React 공식 문서에 방문해서 자습서부터 차근차근 읽어본 적이 있습니다.<br>\n그런데, 으잉? 이건 대체 뭐지? 제게 커다란 장벽이 나타났습니다. 그 것은 바로 바로… <strong>ES6 문법!!!</strong><br>\n그래서 준비했습니다. <span class=\"clr-note\">“ES6를 모르면 React 배우기가 어려워요!”</span> 지금부터 저와 함께 ES6 최신 문법을 정리해봅시다!</p>\n<h1>변수 선언하기</h1>\n<h2>1. const</h2>\n<p>블록(중괄호 {}) 유효 범위의 상수를 선언하며 재할당 및 재선언이 불가능합니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> number = <span class=\"hljs-number\">42</span>;\n\n<span class=\"hljs-keyword\">try</span> {\n  number = <span class=\"hljs-number\">99</span>;\n} <span class=\"hljs-keyword\">catch</span>(err) {\n  <span class=\"hljs-built_in\">console</span>.log(err); <span class=\"hljs-comment\">// TypeError: Assignment to constant variable.</span>\n}\n\n<span class=\"hljs-built_in\">console</span>.log(number); <span class=\"hljs-comment\">// 42</span>\n</code></pre>\n<h2>2. let</h2>\n<p><code class=\"codetainer\">let</code> 키워드를 사용하면 변수의 유효 범위를 블록 {} 안으로 한정시킬 수 있고 글로벌 변수의 값을 보호할 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> topic = <span class=\"hljs-string\">\"js\"</span>\n<span class=\"hljs-keyword\">if</span> (topic) {\n  <span class=\"hljs-keyword\">var</span> topic = <span class=\"hljs-string\">\"리액트\"</span>\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'블록'</span>, topic) <span class=\"hljs-comment\">// 블록 리액트</span>\n}\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'글로벌'</span>, topic) <span class=\"hljs-comment\">// 글로벌 리액트</span>\n</code></pre>\n<p>위 예제의 if 블록 안의 topic 변수와 if 블록 밖의 topic 변수는 같은 변수입니다.<br>\n<code class=\"codetainer\">var</code> 키워드는 함수 유효 범위를 가지기 때문입니다. 자바스크립트의 호이스팅에 의해 함수 안에 정의된 변수는 함수의 맨 앞에서 정의되고 <code class=\"codetainer\">undefined</code>로 초기화되기 때문에 두 topic 변수가 사실상 같은 변수가 됩니다.\n<br/><br/></p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> topic = <span class=\"hljs-string\">\"js\"</span>\n<span class=\"hljs-keyword\">if</span> (topic) {\n  <span class=\"hljs-keyword\">let</span> topic = <span class=\"hljs-string\">\"리액트\"</span>\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'블록'</span>, topic) <span class=\"hljs-comment\">// 블록 리액트</span>\n}\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'글로벌'</span>, topic) <span class=\"hljs-comment\">// 글로벌 js</span>\n</code></pre>\n<p>if 블록 안의 변수가 if 블록 밖의 변수에 영향을 끼치지 않게 하려면 <code class=\"codetainer\">let</code> 키워드를 사용하면 됩니다. <code class=\"codetainer\">let</code>은 블록 유효 범위이므로 호이스팅 시 블록의 맨 앞에서 정의되고 초기화 됩니다.\n<br/><br/></p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-built_in\">console</span>.log(name) <span class=\"hljs-comment\">// Uncaught ReferenceError: Cannot access 'name' before initialization</span>\n<span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">'lee'</span> \n\n<span class=\"hljs-built_in\">console</span>.log(age); <span class=\"hljs-comment\">// undefined</span>\n<span class=\"hljs-keyword\">var</span> age = <span class=\"hljs-string\">'20'</span>\n</code></pre>\n<p>단, var로 선언된 변수는 선언과 초기화가 동시에 진행되고 let을 선언된 변수는 호이스팅되어 선언 단계가 이뤄지나 초기화 단계는 실제 let이 사용된 코드에 도착할 때 이루어집니다. 그래서 let 키워드로 선언한 변수를 초기화 단계 이전에 접근하면 reference 에러가 발생합니다.</p>\n<h2>3. 템플릿 문자열</h2>\n<p>템플릿 문자열 덕분에 더하기 기호 + 없이 편하게 문자열과 변수를 이어 붙인 string을 생성할 수 있습니다.<br>\n<code class=\"codetainer\">${}</code> 안에는 자바스크립트 변수, 식 어떤 것이든 가능하며 템플릿 문자열은 공백, 탭, 개행 문자를 사용할 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${lastName}</span>, <span class=\"hljs-subst\">${firstName}</span> <span class=\"hljs-subst\">${middleName}</span>`</span>)\n</code></pre>\n<p><span class=\"clr-grey\"></span>\n<span class=\"clr-note\"></span></p>\n<h2>4. 디폴트 파라미터</h2>\n<p>이제 함수를 호출 시 인자 값이 넘어오지 않았다면 디폴트 값을 사용할 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span>(<span class=\"hljs-params\">name=<span class=\"hljs-string\">\"lee\"</span>, age=<span class=\"hljs-string\">\"20\"</span></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${name}</span> : <span class=\"hljs-subst\">${age}</span>`</span>)\n}\nfunc() <span class=\"hljs-comment\">// lee : 20</span>\n</code></pre>\n<p>함수 호출 시 인자 넘기지 않아도 디폴트 값을 사용해 함수가 정상적으로 실행됩니다. 문자열뿐 아니라 객체 등 다양한 타입의 값을 디폴트로 사용할 수 있습니다.</p>\n<h1>화살표 함수 =&gt;</h1>\n<p>화살표 함수를 사용하면 function 키워드 없이도 함수를 만들 수 있고 return을 사용하지 않아도 식을 계산한 값이 자동으로 반환됩니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> materials = [\n  <span class=\"hljs-string\">'Hydrogen'</span>,\n  <span class=\"hljs-string\">'Helium'</span>,\n  <span class=\"hljs-string\">'Lithium'</span>,\n  <span class=\"hljs-string\">'Beryllium'</span>\n];\nmaterials.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">{length}</span>) =&gt;</span> length); <span class=\"hljs-comment\">// [8, 6, 7, 9]</span>\n</code></pre>\n<br/>\n또한, <span class=\"clr-note\">화살표 함수는 this를 새로 바인딩 하지 않습니다.</span> 대신 코드에서 바로 바깥의 함수(혹은 class)의 this 값을 사용합니다. 뿐만 아니라 <code class=\"codetainer\">arguments, super, new.target</code>을 바인딩 하지 않습니다.\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> obj = {\n  <span class=\"hljs-attr\">i</span>: <span class=\"hljs-number\">10</span>,\n  <span class=\"hljs-attr\">b</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.i, <span class=\"hljs-keyword\">this</span>),\n  <span class=\"hljs-attr\">c</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-keyword\">this</span>.i, <span class=\"hljs-keyword\">this</span>)\n  }\n}\nobj.b(); <span class=\"hljs-comment\">// prints undefined, Window</span>\nobj.c(); <span class=\"hljs-comment\">// prints 10, Object {...}</span>\n</code></pre>\n<br/>\nthis를 바인딩 하지 않기 때문에 메소드 함수에는 사용하지 않아야 하며 생성자로서도 사용할 수 없기 때문에 <code class=\"codetainer\">new</code>와 함께 사용하면 오류가 발생합니다.\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> Foo = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {};\n<span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">new</span> Foo(); <span class=\"hljs-comment\">// TypeError: Foo is not a constructor</span>\n</code></pre>\n<h1>ES6 객체와 배열</h1>\n<h2>1. 구조 분해(Destructuring)</h2>\n<p>구조 분해를 사용하면 객체의 필드를 원하는 변수에 대입할 수 있습니다.</p>\n<p>다음은 sandwich를 분해해서 bread와 meat 필드를 같은 이름의 변수에 넣어주는 코드입니다. 두 변수의 값은 sandwich에 있는 같은 이름의 필드 값으로 초기화되지만, 두 변수를 변경해도 원래의 필드 값은 바뀌지는 않습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> sandwich = {\n  <span class=\"hljs-attr\">bread</span>: <span class=\"hljs-string\">\"크런치\"</span>,\n  <span class=\"hljs-attr\">meat</span>: <span class=\"hljs-string\">\"참치\"</span>,\n  <span class=\"hljs-attr\">cheese</span>: <span class=\"hljs-string\">\"스위스\"</span>,\n  <span class=\"hljs-attr\">toppings</span>: [<span class=\"hljs-string\">\"상추\"</span>, <span class=\"hljs-string\">\"토마토\"</span>, <span class=\"hljs-string\">\"머스타드\"</span>]\n}\n\n<span class=\"hljs-keyword\">var</span> {bread, meat} = sandwich\n\n<span class=\"hljs-built_in\">console</span>.log(bread, meat) <span class=\"hljs-comment\">// 크런치 참치</span>\n</code></pre>\n<p>객체를 분해해서 함수의 인자로 넘길 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> func = <span class=\"hljs-function\">(<span class=\"hljs-params\">{firstName}</span>) =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`이름은 <span class=\"hljs-subst\">${firstName}</span>`</span>)\n}\n\nfunc({\n  <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">'garam'</span>,\n  <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">'lee'</span>\n}) <span class=\"hljs-comment\">// 이름은 lee</span>\n</code></pre>\n<p>배열의 경우도 비슷합니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> x = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\n<span class=\"hljs-keyword\">var</span> [y, z] = x;\n<span class=\"hljs-built_in\">console</span>.log(y,z); <span class=\"hljs-comment\">// 1 2</span>\n</code></pre>\n<p>변수 선언이 분리되어도 값 할딩이 가능합니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> a, b;\n[a, b] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n<span class=\"hljs-built_in\">console</span>.log(a, b); <span class=\"hljs-comment\">// 1 2</span>\n</code></pre>\n<p>기본값을 할당하여 분해한 값이 undefined면 기본 값을 사용합니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> a, b;\n[a=<span class=\"hljs-number\">5</span>, b=<span class=\"hljs-number\">7</span>] = [<span class=\"hljs-number\">1</span>];\n<span class=\"hljs-built_in\">console</span>.log(a); <span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-built_in\">console</span>.log(b); <span class=\"hljs-comment\">// 7</span>\n</code></pre>\n<p>두 변수 값 교환이 가능합니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">3</span>;\n\n[a, b] = [b, a];\n<span class=\"hljs-built_in\">console</span>.log(a); <span class=\"hljs-comment\">// 3</span>\n<span class=\"hljs-built_in\">console</span>.log(b); <span class=\"hljs-comment\">// 1</span>\n</code></pre>\n<p>불필요한 값을 콤마를 사용해 생략하는 리스트 매칭을 사용할 수 있습니다. 무시하고 싶은 원소 위치에 콤마를 넣으면 리스트 매칭이 됩니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> [,,third] = [<span class=\"hljs-string\">\"a\"</span>,<span class=\"hljs-string\">\"b\"</span>,<span class=\"hljs-string\">\"c\"</span>]\n<span class=\"hljs-built_in\">console</span>.log(third) <span class=\"hljs-comment\">// c</span>\n</code></pre>\n<h2>2. 객체 리터럴 개선</h2>\n<p>구조 분해의 반대라고 할 수 있으며 객체 리터럴 개선을 사용하면 현재 영역에 있는 변수를 객체의 필드로 묶을 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"lee\"</span>\n<span class=\"hljs-keyword\">var</span> age = <span class=\"hljs-string\">\"20\"</span>\n<span class=\"hljs-keyword\">var</span> print = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${<span class=\"hljs-keyword\">this</span>.name}</span> : <span class=\"hljs-subst\">${<span class=\"hljs-keyword\">this</span>.age}</span>`</span>)\n}\n<span class=\"hljs-keyword\">var</span> person = {name, age, print}\nperson.print() <span class=\"hljs-comment\">// lee : 20</span>\n</code></pre>\n<p>객체 리터럴 개선으로 변수를 객체의 필드로 대입할 수 있으며 function 키워드를 입력하지 않고 메서드를 정의할 수 있다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// 예전 방식</span>\n<span class=\"hljs-keyword\">var</span> obj = {\n  <span class=\"hljs-attr\">name</span>: name,\n  <span class=\"hljs-attr\">age</span>: age,\n  <span class=\"hljs-attr\">print</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${name}</span> : <span class=\"hljs-subst\">${age}</span>`</span>)\n  }\n}\n\n<span class=\"hljs-comment\">// 개선된 방식</span>\n<span class=\"hljs-keyword\">const</span> obj = {\n  name,\n  age,\n  print() {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${name}</span> : <span class=\"hljs-subst\">${age}</span>`</span>)\n  }\n}\n</code></pre>\n<h2>3. 스프레드 연산자</h2>\n<p>스프레드 연산자는 세 개의 점(…)으로 이루어진 연산자로,\n<code class=\"codetainer\">함수호출, 배열 리터럴과 문자열, 객체 리터럴</code>에서 사용할 수 있습니다.</p>\n<p>이전에는 두 배열의 모든 원소가 들어간 새로운 배열을 만들기 위해서 <code class=\"codetainer\">push(), splice(), concat() </code> 등을 사용해야 했습니다. 이제 스프레드 연산자를 통해 쉽게 만들 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// 이전 방식</span>\n<span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n<span class=\"hljs-keyword\">var</span> arr2 = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\narr1 = arr1.concat(arr2);\n\n<span class=\"hljs-comment\">// 전개 방식</span>\n<span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n<span class=\"hljs-keyword\">var</span> arr2 = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\narr1 = [...arr1, ...arr2]; <span class=\"hljs-comment\">// arr1은 [0,1,2,3,4,5]</span>\n\n<span class=\"hljs-comment\">// 새로운 배열 생성</span>\n<span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n<span class=\"hljs-keyword\">var</span> arr2 = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\n<span class=\"hljs-keyword\">var</span> arr3 = [...arr1, ...arr2] <span class=\"hljs-comment\">// [0,1,2,3,4,5]</span>\n\n<span class=\"hljs-comment\">// 중간 조합도 가능</span>\n<span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n<span class=\"hljs-keyword\">var</span> arr2 = [<span class=\"hljs-number\">3</span>, ...arr1, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]; <span class=\"hljs-comment\">// 3,0,1,2,4,5</span>\n\n<span class=\"hljs-comment\">// 나머지 원소 얻기 가능</span>\n<span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">var</span> [first, ...rest] = arr1;\n<span class=\"hljs-built_in\">console</span>.log(rest); <span class=\"hljs-comment\">// 1,2,3</span>\n</code></pre>\n<p>스프레드 연산자는 원본 배열을 변경하지 않고 복사본을 만듭니다.<br>\n다음 예제를 통해 실제로 확인해보자. arr1 배열의 마지막 원소를 변수에 담으려고 <code class=\"codetainer\">Array.reverse</code>를 이용해 배열을 뒤집고 첫번째 원소를 변수에 넣는 예제입니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// 원본 배열이 변경된다.</span>\n<span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n<span class=\"hljs-keyword\">var</span> [last] = arr1.reverse();\n<span class=\"hljs-built_in\">console</span>.log(last); <span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-built_in\">console</span>.log(arr1); <span class=\"hljs-comment\">// 2 1 0</span>\n\n<span class=\"hljs-comment\">// 전개 연산을 통해 원본 배열 유지하기</span>\n<span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n<span class=\"hljs-keyword\">var</span> [last] = [...arr1].reverse();\n<span class=\"hljs-built_in\">console</span>.log(last); <span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-built_in\">console</span>.log(arr1); <span class=\"hljs-comment\">// 0,1,2</span>\n</code></pre>\n<p>객체에 사용할 수도 있습니다. 사용법은 배열과 유사합니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> obj1 = { <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>, <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">42</span> };\n<span class=\"hljs-keyword\">var</span> obj2 = { <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'baz'</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">13</span> };\n<span class=\"hljs-keyword\">var</span> obj3 = <span class=\"hljs-string\">\"obj\"</span>\n<span class=\"hljs-keyword\">var</span> mergedObj = { ...obj1, ...obj2, obj3};\n<span class=\"hljs-built_in\">console</span>.log(mergedObj); <span class=\"hljs-comment\">// { foo: \"baz\", x: 42, y: 13, obj3: \"obj\" }</span>\n</code></pre>\n<p>함수 호출할 때도 사용할 수 있어서 배열의 엘리먼트를 함수의 인자로 사용하고자 할 때<code class=\"codetainer\">Function.prototype.apply()</code>를 대체할 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// 이전 방식</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\">x, y, z</span>) </span>{ }\n<span class=\"hljs-keyword\">var</span> args = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\nmyFunction.apply(<span class=\"hljs-literal\">null</span>, args);\n\n<span class=\"hljs-comment\">// 전개 방식</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\">x, y, z</span>) </span>{ }\n<span class=\"hljs-keyword\">var</span> args = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\nmyFunction(...args);\n\n<span class=\"hljs-comment\">// new 키워드와 함께 사용할 수 있습니다.</span>\n<span class=\"hljs-keyword\">var</span> dateFields = [<span class=\"hljs-number\">1970</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>];  <span class=\"hljs-comment\">// 1 Jan 1970</span>\n<span class=\"hljs-keyword\">var</span> d = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(...dateFields);\n</code></pre>\n<h1>클래스</h1>\n<p>이전에는 공식적으로 클래스가 없어서 타입을 함수로 정의하고 그 함수 객체에 있는 프로토타입을 사용해 메서드를 정의했습니다. ES6부터 클래스 선언이 추가되어서 쉽게 클래스 패턴 생성이 가능해졌습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> Foo = <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>() {}\n  bar() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Hello World!\"</span>;\n  }\n};\n\n<span class=\"hljs-keyword\">var</span> instance = <span class=\"hljs-keyword\">new</span> Foo();\ninstance.bar(); <span class=\"hljs-comment\">// \"Hello World!\"</span>\nFoo.name; <span class=\"hljs-comment\">// \"\"</span>\n</code></pre>\n<p>class 키워드를 사용하더라도 내부적으로는 자바스크립트의 프로토타입 상속을 사용하고 있습니다. <code class=\"codetainer\">Foo.prototype</code>을 콘솔에 찍어보면 프로토타입에 생성자와 bar 메서드가 있는 것을 확인할 수 있을 것입니다.</p>\n<h1>ES6 모듈</h1>\n<p>모듈은 다른 자바스크립트 파일의 코드를 쉽게 불러서 활용할 수 있는 재사용 가능한 코드 조각입니다. <code class=\"codetainer\">export</code>와 <code class=\"codetainer\">import</code> 키워드를 이용하면 됩니다.</p>\n<p><code class=\"codetainer\">export</code>를 사용해 다른 모듈에서 활용할 수 있도록 이름(함수, 객체, 변수, 상수 등)을 외부에 익스포트할 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// export_1.js</span>\n<span class=\"hljs-comment\">// print, log 함수를 외부에 export</span>\n<span class=\"hljs-comment\">// 로컬 선언됨</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> print(message) =&gt; log(message, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>())\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> log(message, timestamp) =&gt; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${timestamp.toString()}</span> : <span class=\"hljs-subst\">${message}</span>`</span>)\n\n<span class=\"hljs-comment\">// export_2.js</span>\n<span class=\"hljs-comment\">// 단 하나의 이름만 외부에 export 하고 싶다면 export default 사용</span>\n<span class=\"hljs-keyword\">const</span> freel = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>();\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> freel;\n</code></pre>\n<p><code class=\"codetainer\">import</code>를 사용해 다른 자바스크립트 파일을 불러와 사용할 수 있습니다. 임포트 시 객체 구조 분해를 사용할 수 있으며, <code class=\"codetainer\">export default</code>를 사용한 경우 구조분해 없이 한 이름으로 부를 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> { print, log } <span class=\"hljs-keyword\">from</span> ./export_1\n<span class=\"hljs-keyword\">import</span> freel <span class=\"hljs-keyword\">from</span> ./export_2\n\n<span class=\"hljs-comment\">// import * 를 사용하여 다른 모듈에서 가져온 모든 이름을 사용자가 정한 로컬 이름 공간 안에 가둘 수 있음</span>\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">from</span> fns <span class=\"hljs-keyword\">from</span> ./export_1\n</code></pre>\n<h1>커먼JS</h1>\n<p>모든 버전의 노드에서 지원하는 일반적인 모듈 패턴입니다. 커먼 JS를 사용하여 객체를 <code class=\"codetainer\">module.exports</code>를 사용해 익스포트할 수 있습니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">//export.js</span>\n<span class=\"hljs-keyword\">const</span> print(message) =&gt; log(message, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>())\n<span class=\"hljs-keyword\">const</span> log(message, timestamp) =&gt; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${timestamp.toString()}</span> : <span class=\"hljs-subst\">${message}</span>`</span>)\n\n<span class=\"hljs-built_in\">module</span>.exports = {print, log}\n</code></pre>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> { print, log } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./export'</span>)\n</code></pre>\n<h1>ES6에서 비동기 프로그래밍</h1>\n<p>나중에 따로 정리할 예정.</p>\n<h2>1. promises</h2>\n<h2>2. 제너레이터</h2>\n",
		"updatedAt": "2020-01-22T18:27:08.394Z",
		"id": "2019-12-17-javascript-es6",
		"filename": "javascript\\2019-12-17-javascript-es6.json"
	},
	{
		"layout": "post-content",
		"title": "(mocha) 자바스크립트 단위테스트 시작하기",
		"date": "2018-01-27T00:00:00.000Z",
		"tags": [
			"mocha",
			"javascript"
		],
		"category": [
			"javascript"
		],
		"body": "<p>mocha 자바스크립트 테스트 프레임워크로 단위테스트 시작하는 방법입니다.</p>\n<hr>\n<h1>단위테스트(Unit Test)가 필요한 이유?</h1>\n<p>프로그램을 작은 단위로 쪼개서 내가 짠 프로그램이 내가 원하는 결과대로 동작하는 지 테스트할 수 있다.<br>\n단위테스트를 거치면 프로그램의 안정성이 높아지며, 단위테스트를 믿고 리팩토링을 할 수 있다.</p>\n<p>자바스크립트로 짜여진 프로그램에서 오류를 찾을 때, 단위테스트를 거치지 않은 프로그램의 경우는 전체 흐름을 파악해가며 원인을 찾아야한다.<br>\n원인을 찾아 수정한다해도 이 결과가 어떤 이펙트를 가져올지 예상하기가 어려울 수 있다.</p>\n<h1>mocha 자바스크립트 테스트 프레임워크</h1>\n<h2>1. 셋팅하기 (Windows8)</h2>\n<p>mocha는 node.js가 기반인 프레임워크이기 때문에 node.js가 설치되어있어야 한다.<br>\n설치 후 cmd 창에 node --version 이라고 쳐서 버전 정보가 제대로 나오면 설치가 잘 된 것이다.</p>\n<p>cmd 창에 아래와 같이 입력하면 mocha 사용 준비 완료!</p>\n<pre><code>$npm install -g mocha\n</code></pre>\n<p>그리고 Assertion Library인 Chai를 추가해보자. 작업 디렉토리에서 아래를 cmd 창에서 실행한다.</p>\n<pre><code>$nbm install chai\n</code></pre>\n<p>그 결과, node_moduls 폴더가 생성된다.</p>\n<h2>2. 사용하기</h2>\n<p><a href=\"http://inspiredjw.com/entry/Mocha-%EB%A1%9C-%ED%95%98%EB%8A%94-JavaScript-Testing\">InspiredJW님의 티스토리 블로그를 참고했습니다!</a>.</p>\n<p>모카는 test 디렉토리에 있는 파일을 실행하기 때문에, 테스트 코드는 이 디렉토리 안에 위치시켜야한다.</p>\n<p>JsStudy/JsStudy.js</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-meta\">'use strict'</span>;\nexports.foo = <span class=\"hljs-function\">(<span class=\"hljs-params\">a,b</span>) =&gt;</span> {\n\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">typeof</span> a !== <span class=\"hljs-string\">'number'</span> || <span class=\"hljs-keyword\">typeof</span> b !== <span class=\"hljs-string\">'number'</span>)\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n\t<span class=\"hljs-keyword\">return</span> a*b;\n};\nexports.bar = <span class=\"hljs-function\">(<span class=\"hljs-params\">callback</span>) =&gt;</span> {};\n</code></pre>\n<p>JsStudy/test/JsStudyTest.js</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-meta\">'use strict'</span>;\n\n<span class=\"hljs-keyword\">let</span> chai = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'chai'</span>);\n<span class=\"hljs-keyword\">let</span> should = chai.should();\n<span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../JsStudy'</span>).foo;\n\ndescribe(<span class=\"hljs-string\">'Function Foo'</span>, () =&gt;{\n\tdescribe(<span class=\"hljs-string\">'with two number params'</span>,()=&gt;{\n\t\tit(<span class=\"hljs-string\">'should return product'</span>,()=&gt;{\n\t\t\t<span class=\"hljs-keyword\">let</span> result = foo(<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>);\n\t\t\tresult.should.be.a(<span class=\"hljs-string\">'number'</span>);\n\t\t\tresult.should.equal(<span class=\"hljs-number\">12</span>);\n\t\t});\n\t});\n});\n\ndescribe(<span class=\"hljs-string\">'with non-number params'</span>,()=&gt;{\n\tit(<span class=\"hljs-string\">'should return false'</span>,()=&gt;{\n\t\t<span class=\"hljs-keyword\">let</span> result = foo(<span class=\"hljs-number\">3</span>,<span class=\"hljs-literal\">null</span>);\n\t\tresult.should.be.false;\n\t});\n});\n</code></pre>\n<p>테스트 실행방법은 cmd 창에서 JsStudy 폴더로 이동한후, mocha 실행하기</p>\n<pre><code>$mocha\n</code></pre>\n<span class=\"clr-grey\">\nAPI    \n- describe() : 테이스틔 이름을 지정하며, 중첩하여 사용할 수 있다. 테스트를 구분하는 section이며, 단위테스트 부분을 콜백으로 넘겨준다.\n- it() : 단위테스트의 이름을 작성하고 실제 실행되는 코드를 콜백(done)으로 넘겨준다.\n- befor() : 테스트 코드가 실행되기 전 한번 실행된다.\n- after() : 모든 테스트 코드가 실행된 후 한 번 실행된다.\n- beforeEach() : (테스트 코드가 여러개일 경우) 각각의 테스트 코드가 실행되기 전마다 실행된다.\n- afterEach() : (테스트코드가 여러개일 경우) 각각의 테스트 코드가 실행된 후마다 실행된다.\n- .a(type[,msg]) : 지정된 타입과 동일한지 리턴.\n- .equal(val[,msg]) : === var과 주어진 타켓이 같은지.\n- .false : 타켓 === false\n</span>",
		"updatedAt": "2020-01-22T18:22:42.890Z",
		"id": "2018-01-27-mocha-unittest",
		"filename": "nodejs\\2018-01-27-mocha-unittest.json"
	},
	{
		"layout": "post-content",
		"title": "npm 시작하기",
		"date": "2018-04-11T00:00:00.000Z",
		"tags": [
			"npm"
		],
		"category": [
			"npm"
		],
		"body": "<h1>1. npm이란?</h1>\n<h2>npm은 어떻게 구성되어있을까?</h2>\n<p>npm은 세 개의 컴포넌트로 구성되어있습니다.</p>\n<ul>\n<li>the website - 패키지 탐색, 프로파일 설정, 개인 npm histoty 관리</li>\n<li>CLI ( the Command Line Interface ) - 개발자와 npm이 소통하는 방법으로 터미널에서 동작</li>\n<li>the registry - 자바스크립트 소프트웨어의 공용 데이터베이스 및 메타 정보</li>\n</ul>\n<h2>npm은 언제 사용할까?</h2>\n<ul>\n<li>앱에 패키지를 적용시키거나, 통합시키고 싶을 때</li>\n<li>바로 사용할 수 있는 독립된 툴을 다운받고싶을 때</li>\n<li>npx를 사용하여 다운로드받는 것 없이 패키지를 실행하고 싶을 때</li>\n<li>조직을 만들어서 유지보수, 개발 협업하고 싶을 때</li>\n<li>어디서든 npm 사용자와 코드를 공유하고 싶을 때</li>\n<li>코드 활용을 특정 개발자들로만 제한하고 싶을 때</li>\n<li>버전 및 코드 의존성 관리하고 싶을 때</li>\n<li>근본적인 코드가 업데이트될 때, 애플리케이션도 쉽게 업데이트되게 하고 싶을 때</li>\n<li>같은 문제를 해결하는 다양한 방법을 찾고싶을 때</li>\n<li>비슷한 프로젝트를 진행하는 개발자를 찾고 싶을 때</li>\n</ul>\n<h1>2. 패키지는 어떻게 찾을까?</h1>\n<p>패키지를 찾기위해서 npm의 검색창을 활용해야합니다. 그럼, 당신의 앱에 바코드(QR code) 기능을 넣고 싶다면 검색창에 QR code라고 입력해봅시다. QR Code와 관련된 패키지들이 조회되고, 패키지 선택에 도움을 줄 수 있는 랭킹 정보를 볼 수 있습니다.</p>\n<p>그렇다면 비슷한 패키지들 중, 우리는 어떤 패키지를 선택하면 될까요?</p>\n<h2>각각의 패키지들은 npm 분석기에 의해 다음의 4가지로 랭킹되고있습니다.</h2>\n<ul>\n<li>Optimal -  아래 세가지 기준을 의미있게 조합하여 순위를 지정합니다.</li>\n<li>Populary - 패키지가 다운로드된 횟수로 패키지 순위를 지정하며, 유용하고 안정적인 패키지가 해당됩니다.</li>\n<li>Quality - readme 파일 존재여부, 안정성, 테스트, 최신 의존성주입, 사용자정의 웹사이트, 코드 복잡성등을 고려합니다.</li>\n<li>Maintenance - 개발자가 관심을 기울이며, 보다 자주 유지보수되는 패키지를 순위로 지정합니다.</li>\n</ul>\n<h2>패키지를 선택해서 들어가보면 패키지 정보와 사용 방법등의 다양한 정보를 얻을 수 있습니다.</h2>\n<ul>\n<li>Readme - 개발자가 생성한 readme 파일로 패키지의 목적과 사용방법에 대해 설명되어있습니다.</li>\n<li>Dependencies - 대부분의 패키지들은 다른 패키지들로 만들어집니다. 이 패키지가 의존하고 있는 패키지들의 정보를 보여줍니다.</li>\n<li>Dependents - 이 패키지를 의존하고 있는 패키지들을 보여줍니다.</li>\n<li>Versions - 패키지 업데이트 정보를 보여줍니다.</li>\n</ul>\n<h1>3. npm 시작하기</h1>\n<p>npm은 Node.js로 개발되었기에 npm을 사용하기 위해서는 Node.js를 설치해야합니다.<br>\nWindows의 경우, 반드시 LTS 버전을 설치해야합니다.</p>\n<pre><code>&gt; node -v\n</code></pre>\n<p>설치가 완료되면 다음과 같이 노드의 버전을 확인해봅시다. 정상적으로 출력된다면 설치가 완료된 것입니다.<br>\nNode.js를 설치할 때, npm은 자동적으로 설치됩니다. 하지만, npm은 Node.js보다 더 자주 업데이트되기때문에 최신 버전으로 업데이트하는 방법을 알아야합니다.</p>\n<pre><code>&gt; npm -v\n#npm 버전을 확인합니다.\n&gt;npm install npm@latest -g\n#최신버전으로 업데이트합니다.\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:23:09.386Z",
		"id": "2018-04-11-npmstart1",
		"filename": "nodejs\\2018-04-11-npmstart1.json"
	},
	{
		"layout": "post-content",
		"title": "npm 로컬 패키지 설치하기",
		"date": "2018-04-13T00:00:00.000Z",
		"tags": [
			"npm"
		],
		"category": [
			"npm"
		],
		"body": "<h1>4. 로컬에 패키지를 설치해보자</h1>\n<p>패키지를 어떤 방식으로 사용하는지에 따라 우리는 로컬 또는 전역에 npm 패키지를 설치할 수 있습니다.</p>\n<ul>\n<li>Node.js의 require을 사용하여 당신의 모듈에서 패키지를 사용하려면 로컬로 설치하면 됩니다. 이는 npm 설치의 기본 동작입니다.</li>\n<li>패키지를 CLI와 같은 커맨드 라인 툴에서 사용하려면 전역으로 설치하면 됩니다.</li>\n</ul>\n<h2>패키지 다운로드하기</h2>\n<pre><code>&gt; npm install &lt;package_name&gt;\n</code></pre>\n<p>명령어를 실행하면 현재 디렉토리에 node_modules 디렉토리가 생성됩니다. (node_modules 디렉토리가 없을 경우)\n그리고 node_modules 디렉토리 안에 다운로드 받은 패키지가 존재하게됩니다.</p>\n<h2>설치된 패키지 어떤 버전일까?</h2>\n<p>로컬 디렉토리에 package.json 파일이 없다면, 가장 최신 버전의 패키지가 설치됩니다. package.json 파일이 있으면 npm은 package.json 파일에 선언된 semver rule을 만족하는 최신버전을 설치합니다.</p>\n<p>예) package.json</p>\n<pre><code>...\n&quot;dependencies&quot; : {\n&quot;lodash&quot; : &quot;~1.0.4&quot;\n}\n....\n</code></pre>\n<p>npm은 package.json에 따라 1.0.4 버전의 lodash 패키지를 설치하게됩니다.</p>\n<h2>패키지를 어떻게 사용할까?</h2>\n<p>일단 node_modules 디렉토리에 패키지가 있다면, 우리의 코드에서 패키지를 사용할 수 있습니다.</p>\n<p>예) index.js 파일</p>\n<pre><code>var lodash = require('lodash');\nvar output = lodash.without([1,2,3],1);\nconsole.log(output);    // 결과 : [2,3]\n</code></pre>\n<p>만약 lodash 패키지가 설치되지않았다면 Error : Cannot find module ‘lodash’ 에러를 보게될 것 입니다.</p>\n<h1>7. 로컬에 설치된 패키지 삭제해보자</h1>\n<p>node_modules 디렉토리의 패키지를 삭제하는 명령어</p>\n<pre><code>&gt; npm uninstall lodash\n</code></pre>\n<p>package.json의 dependecies에서 패키지를 제거하려면 save 플래그를 사용해야합니다.</p>\n<pre><code>&gt; npm uninstall --save lodash\n</code></pre>\n<p><strong>Note:</strong> 패키지가 devDependency로 설치된 경우, package.json에서 제거하는 방법은 다음과 같습니다.</p>\n<pre><code>&gt; npm uninstall --save-dev lodash\n</code></pre>\n<p>node_modules 디렉토리에 해당 패키지가 없다면 삭제가 정상적으로 된 것입니다.</p>\n<h1>8~10. 전역에 패키지를 설치/업데이트/삭제 해보기</h1>\n<p>패키지 설치</p>\n<pre><code>&gt; npm install -g jshint\n</code></pre>\n<p>패키지업데이트</p>\n<pre><code>&gt; npm update -g jshint\n</code></pre>\n<p>패키지 삭제</p>\n<pre><code>&gt; npm uninstall -g jshint\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:23:09.391Z",
		"id": "2018-04-13-npmstart2",
		"filename": "nodejs\\2018-04-13-npmstart2.json"
	},
	{
		"layout": "post-content",
		"title": "npm Working with package.json",
		"date": "2018-04-16T00:00:00.000Z",
		"tags": [
			"npm"
		],
		"category": [
			"npm"
		],
		"body": "<h1>5. Working with package.json</h1>\n<p>로컬에 설치된 npm 패키지를 관리하는 최상의 방법은 package.json 파일을 생성하는 것입니다.</p>\n<p>package.json 파일은 :</p>\n<ul>\n<li>프로젝트가 의존하고 있는 패키지들의 리스트를 보여줍니다.</li>\n<li>semantic versioning rule에 따라 프로젝트에 의존한 패키지들의 버전을 설정할 수 있습니다.</li>\n<li>빌드를 재현할 수 있으므로, 좀 더 쉽게 다른 개발자와 공유할 수 있습니다.</li>\n</ul>\n<h2>요구사항</h2>\n<p>package.json 파일이 반드시 가져야하는 것</p>\n<ul>\n<li>“name”\n<ul>\n<li>소문자</li>\n<li>한단어, 띄어쓰기 허용X</li>\n<li>-(dashes) 와 _ (underscores) 허용O</li>\n</ul>\n</li>\n<li>“version”\n<ul>\n<li>x.x.x 형태</li>\n<li>semver spec을 따름</li>\n</ul>\n</li>\n</ul>\n<pre><code>{\n &quot;name&quot; : &quot;my-awesome-package&quot;,\n &quot;version&quot; : &quot;1.0.0&quot;\n}\n</code></pre>\n<h2>package.json 파일 생성하기</h2>\n<pre><code>&gt; npm init\n또는\n&gt; npm init --yes \n#--yes === -y\n</code></pre>\n<p>위 명령어는 현재 디렉토리로부터 정보를 추출해서 해당 package.json 파일을 생성합니다.</p>\n<pre><code>{\n  &quot;name&quot;: &quot;my_package&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  },\n  &quot;repository&quot;: {\n    &quot;type&quot;: &quot;git&quot;,\n    &quot;url&quot;: &quot;https://github.com/ashleygwilliams/my_package.git&quot;\n  },\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;bugs&quot;: {\n    &quot;url&quot;: &quot;https://github.com/ashleygwilliams/my_package/issues&quot;\n  },\n  &quot;homepage&quot;: &quot;https://github.com/ashleygwilliams/my_package&quot;\n}\n</code></pre>\n<ul>\n<li>name : 현재 디렉토리 이름</li>\n<li>version : 항상 1.0.0</li>\n<li>description : readme 정보 또는 “”</li>\n<li>main : 항상 index.js</li>\n<li>scripts : 기존적으로 빈 테스트 스크립트를 만든다.</li>\n<li>keywords : empty</li>\n<li>author : empty</li>\n<li>license : ISC</li>\n<li>bugs : 현재 디렉토리의 정보</li>\n<li>homepage : 현재 디렉토리의 정보</li>\n</ul>\n<p>다음과 같이 명령어 실행시 옵션을 설정할 수 있습니다.</p>\n<pre><code>&gt; npm set init.author.email &quot;wombat@npmjs.com&quot;\n&gt; npm set init.author.name &quot;ag_dubs&quot; \n&gt; npm set init.license &quot;MIT&quot; \n</code></pre>\n<h2>Dependencies 지정하기</h2>\n<p>프로젝트가 의존하는 패키지를 지정하려면 package.json 파일에 사용할 패키지들을 나열해야합니다. 그리고 패키지들은 두 개의 타입으로 나열될 수 있습니다.</p>\n<ul>\n<li>“dependencies” : 프로젝트 배포 시</li>\n<li>“devDependencies” : 프로젝트 개발 또는 테스트 시</li>\n</ul>\n<p>package.jsondp dependencies를 추가하는 더 쉬운 방법은 npm install 명령어 실행시 --save 또는 --save-dev 플래그를 사용하는 것 입니다.</p>\n<pre><code>&gt; npm install &lt;package_name&gt; --save\n&gt; npm install &lt;package_name&gt; --save-dev\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:23:09.392Z",
		"id": "2018-04-16-npmstart3",
		"filename": "nodejs\\2018-04-16-npmstart3.json"
	},
	{
		"title": "Koa 가이드",
		"date": "2020-01-04T00:00:00.000Z",
		"tags": "koa",
		"category": "nodejs",
		"body": "<blockquote>\n<p>원본 <a href=\"https://github.com/koajs/koa/blob/master/docs/guide.md\">Koa user guide</a></p>\n</blockquote>\n<hr>\n<h1>가이드</h1>\n<p>이 가이드는 미들웨어 사용법과 애플리케이션 구조에 대해서 다룬다.\n예제의 미들웨어에서는 async 함수를 사용한다. 물론 commonFunction 또는 generatorFunction을 사용할 수도 있다.</p>\n<h2>목차</h2>\n<ul>\n<li><a href=\"#%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4-%EC%82%AC%EC%9A%A9%EB%B2%95\">미들웨어 사용법</a></li>\n<li><a href=\"#%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4-%ED%91%9C%EC%A4%80-%EC%82%AC%EC%9A%A9%EB%B2%95\">미들웨어 표준 사용법</a>\n<ul>\n<li><a href=\"#%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4-%EC%98%B5%EC%85%98%EB%93%A4\">미들웨어 옵션들</a></li>\n<li><a href=\"#%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4-%EC%9D%B4%EB%A6%84-%EC%A7%80%EC%A0%95\">미들웨어 이름 지정</a></li>\n<li><a href=\"#koa-compose%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4-%EC%A1%B0%ED%95%A9%ED%95%98%EA%B8%B0\">koa-compose를 통해 다양한 미들웨어 조합하기</a></li>\n<li><a href=\"#%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4-Response\">미들웨어 Response</a></li>\n</ul>\n</li>\n<li><a href=\"#async-operations\">Async operations</a></li>\n<li><a href=\"#debugging-koa\">Debugging Koa</a></li>\n</ul>\n<h1>미들웨어 사용법</h1>\n<p>Koa 미들웨어는 (ctx, next) 같은 파라미터를 가진 <code>MiddlewareFunction</code> 반환하는 간단한 함수다. 미들웨어가 동작할 때, 반드시 <code>next()</code> 를 통해 다음 미들웨어로 갈 수 있다.</p>\n<p>만약 Koa를 통해 전파되는 request 소요 시간을 추적하고 싶다면 다음과 같이 <code>X-Response-Time</code>  헤더에 시간을 셋팅하면 된다.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">responseTime</span>(<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> start = <span class=\"hljs-built_in\">Date</span>.now();\n  <span class=\"hljs-keyword\">await</span> next();\n  <span class=\"hljs-keyword\">const</span> ms = <span class=\"hljs-built_in\">Date</span>.now() - start;\n  ctx.set(<span class=\"hljs-string\">'X-Response-Time'</span>, <span class=\"hljs-string\">`<span class=\"hljs-subst\">${ms}</span>ms`</span>);\n}\n\napp.use(responseTime);\n</code></pre>\n<p>프론트엔드 개발자는 <code>next()</code> 전의 코드를 “capture” 단계로 <code>next()</code> 후의 코드를 “bubble” 단계로 생각할 수 있다.  아래의 이미지는 어떻게 async 함수로 request, reponse 구현을 스택 플로우로 활용할 수 있는 지 설명해준다.</p>\n<p><img src=\"/assets/images/2020-01-04-img/middleware.gif\" alt=\"Koa middleware\"></p>\n<ol>\n<li>response time 생성</li>\n<li>Await를 통해 다음 미들웨어로</li>\n<li>소요시간 계산을 위해 또 다른 time을 생성</li>\n<li>Await를 통해 다음 미들웨어로</li>\n<li>response body에 “Hello World” 셋팅</li>\n<li>소요시간 계산</li>\n<li>로그로 출력</li>\n<li>응답시간 계산</li>\n<li><code>X-Response-Time</code>  헤더 필드에 값 셋팅</li>\n<li>Koa로 이동하여 response 전달</li>\n</ol>\n<p>이제 우리는 Koa 미들웨어를 생성하는 방법에 대해 알아볼 것이다.</p>\n<h2>미들웨어 표준 사용법</h2>\n<p>이 섹션은 미들웨어 옵션, 디버깅 등을 위한 미들웨어 사용 방법에 대해 다룬다.</p>\n<h3>미들웨어 옵션들</h3>\n<p>공용 미들웨어를 생성할 때 옵션을 허용하여 편리하게 함수를 확장하여 미들웨어를 랩핑할 수 있다.  미들웨어에서 옵션을 허용하지 않을 수도 있는 데, 이는 좋은 표준이기도 하다.</p>\n<p>여기 <code>logger</code> 미들웨어는 커스텀을 위해 <code>format</code>을 이용하여 값을 셋팅 후 문자열로 리턴한다.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">logger</span>(<span class=\"hljs-params\">format</span>) </span>{\n  format = format || <span class=\"hljs-string\">':method \":url\"'</span>;\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">ctx, next</span>) </span>{\n    <span class=\"hljs-keyword\">const</span> str = format\n      .replace(<span class=\"hljs-string\">':method'</span>, ctx.method)\n      .replace(<span class=\"hljs-string\">':url'</span>, ctx.url);\n\n    <span class=\"hljs-built_in\">console</span>.log(str);\n\n    <span class=\"hljs-keyword\">await</span> next();\n  };\n}\n\napp.use(logger());\napp.use(logger(<span class=\"hljs-string\">':method :url'</span>));\n</code></pre>\n<h3>미들웨어 이름 지정</h3>\n<p>미들웨어의 이름을 지정하는 것은 선택사항이나 이름을 사용하면 디버깅 목적으로 사용할 때 유용하다.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">logger</span>(<span class=\"hljs-params\">format</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">logger</span>(<span class=\"hljs-params\">ctx, next</span>) </span>{\n\n  };\n}\n</code></pre>\n<h3>koa-compose를 통해 다양한 미들웨어 조합하기</h3>\n<p><a href=\"https://github.com/koajs/compose\">koa-compose</a> 를 사용하면 여러 개의 미들웨어를 조립하여 하나의 미들웨어로 사용할 수 있다. 미들웨어를 재사용하거나 export할 때 유리하다.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> compose = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'koa-compose'</span>);\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">random</span>(<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'/random'</span> == ctx.path) {\n    ctx.body = <span class=\"hljs-built_in\">Math</span>.floor(<span class=\"hljs-built_in\">Math</span>.random() * <span class=\"hljs-number\">10</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">await</span> next();\n  }\n};\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">backwards</span>(<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'/backwards'</span> == ctx.path) {\n    ctx.body = <span class=\"hljs-string\">'sdrawkcab'</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">await</span> next();\n  }\n}\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">pi</span>(<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'/pi'</span> == ctx.path) {\n    ctx.body = <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-built_in\">Math</span>.PI);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">await</span> next();\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> all = compose([random, backwards, pi]);\n\napp.use(all);\n</code></pre>\n<h3>미들웨어 Response</h3>\n<p>미들웨어는 요청에 대한 응답을 위해 <code>next()</code>를 생략할지도 모른다. 일반적으로 <code>next()</code>는 미들웨어의 라우팅을 결정하나 다음과 같은 작업을 한다.\n예를 들어 아래의 코드는 요청에 대해 &quot;two&quot;를 응답하나 3개의 미들웨어 모두 실행된다. 3개의 미들웨어에 response를 조작할 수 있는 기회가 주어지는 것이다.</p>\n<pre><code class=\"language-js\">app.use(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&gt;&gt; one'</span>);\n  <span class=\"hljs-keyword\">await</span> next();\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&lt;&lt; one'</span>);\n});\n\napp.use(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&gt;&gt; two'</span>);\n  ctx.body = <span class=\"hljs-string\">'two'</span>;\n  <span class=\"hljs-keyword\">await</span> next();\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&lt;&lt; two'</span>);\n});\n\napp.use(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&gt;&gt; three'</span>);\n  <span class=\"hljs-keyword\">await</span> next();\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&lt;&lt; three'</span>);\n});\n</code></pre>\n<p>아래의 코드는 두번째 미들웨어에서 <code>next()</code>를 생략했고 response로 &quot;two&quot;를 셋팅하여 세번째 미들웨어는 무시될 것이다.</p>\n<pre><code class=\"language-js\">app.use(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&gt;&gt; one'</span>);\n  <span class=\"hljs-keyword\">await</span> next();\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&lt;&lt; one'</span>);\n});\n\napp.use(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&gt;&gt; two'</span>);\n  ctx.body = <span class=\"hljs-string\">'two'</span>;\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&lt;&lt; two'</span>);\n});\n\napp.use(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&gt;&gt; three'</span>);\n  <span class=\"hljs-keyword\">await</span> next();\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'&lt;&lt; three'</span>);\n});\n</code></pre>\n<p>가장 마지막 미들웨어에서 <code>next()</code>를 실행하면 noop function, 아무 동작을 하지 않으며 미들웨어가 스택의 어느 곳에서나 올바르게 구성할 수 있다.</p>\n<h2>Async operations</h2>\n<p>Async 함수와 promise 기반인 Koa는 non-blocking sequential code를 허용한다. 예를 들어 이 미들웨어는 <code>./docs</code> 디렉토리에서 파일 이름들을 읽어온 후  parallel, 병렬로 각각의 마크다운 파일 형태의 내용을 읽어 body에 결과를 join 하여 셋팅한다.</p>\n<blockquote>\n<p>non-blocking이란, 어떤 쓰레드에서 오류가 발생하거나 멈추었을 때 다른 쓰레드에게 영향을 끼치지 않도록 만드는 방법들을 말한다.</p>\n</blockquote>\n<blockquote>\n<p>parallel, 병렬이라는 뜻처럼 데이터를 한번에 여러 개를 전송한다</p>\n</blockquote>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'mz/fs'</span>);\n\napp.use(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">ctx, next</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> paths = <span class=\"hljs-keyword\">await</span> fs.readdir(<span class=\"hljs-string\">'docs'</span>);\n  <span class=\"hljs-keyword\">const</span> files = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.all(paths.map(<span class=\"hljs-function\"><span class=\"hljs-params\">path</span> =&gt;</span> fs.readFile(<span class=\"hljs-string\">`docs/<span class=\"hljs-subst\">${path}</span>`</span>, <span class=\"hljs-string\">'utf8'</span>)));\n\n  ctx.type = <span class=\"hljs-string\">'markdown'</span>;\n  ctx.body = files.join(<span class=\"hljs-string\">''</span>);\n});\n</code></pre>\n<h2>Koa 디버깅하기</h2>\n<p>Koa along with many of the libraries it’s built with support the <strong>DEBUG</strong> environment variable from <a href=\"https://github.com/visionmedia/debug\">debug</a> which provides simple conditional logging.</p>\n<p>For example\nto see all Koa-specific debugging information just pass <code>DEBUG=koa*</code> and upon boot you’ll see the list of middleware used, among other things.</p>\n<pre><code>$ DEBUG=koa* node --harmony examples/simple\n  koa:application use responseTime +0ms\n  koa:application use logger +4ms\n  koa:application use contentLength +0ms\n  koa:application use notfound +0ms\n  koa:application use response +0ms\n  koa:application listen +0ms\n</code></pre>\n<p>Since JavaScript does not allow defining function names at\nruntime, you can also set a middleware’s name as <code>._name</code>.\nThis is useful when you don’t have control of a middleware’s name.\nFor example:</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>);\n<span class=\"hljs-keyword\">const</span> serve = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'koa-static'</span>);\n\n<span class=\"hljs-keyword\">const</span> publicFiles = serve(path.join(__dirname, <span class=\"hljs-string\">'public'</span>));\npublicFiles._name = <span class=\"hljs-string\">'static /public'</span>;\n\napp.use(publicFiles);\n</code></pre>\n<p>Now, instead of just seeing “serve” when debugging, you will see:</p>\n<pre><code>  koa:application use static /public +0ms\n</code></pre>\n",
		"updatedAt": "2020-01-22T18:19:16.346Z",
		"id": "koa-1",
		"filename": "nodejs\\koa-1.json"
	},
	{
		"title": "React 기반을 다져보자!",
		"date": "2020-01-07T00:00:00.000Z",
		"tags": [
			"jsx"
		],
		"categories": [
			"react"
		],
		"body": "<p><span class=\"clr-grey\">새로 알게 된 내용이 있으면 계속해서 추가할 예정입니다. </span></p>\n<blockquote>\n<p><strong>참조 링크</strong> <br/></p>\n<ul>\n<li><a href=\"https://reactjs-kr.firebaseapp.com/docs/hello-world.html\">리액트 공식 문서</a></li>\n</ul>\n</blockquote>\n<h1>JSX</h1>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> element = <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, world<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\nReactDOM.render(\n  element,\n  <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'root'</span>) <span class=\"hljs-comment\">// ID가 root인 노드에 렌더링하겠다!</span>\n);\n</code></pre>\n<ul>\n<li>JSX는 화면에서 볼 수 있는 내용에 대한 설명인 <code>React elements</code> 객체를 만든다.</li>\n<li>표현식이므로 if문, for 반복, 변수 할당, 매개 변수로 사용 가능하다.</li>\n<li>Babel은 JSX를 <code>React.createElement()</code> 호출로 컴파일합니다.</li>\n<li>리액트 요소는 <code>Immutable Objects</code>라서 한번 만들면 그 자식이나 속성을 변경할 수 없다. UI를 업데이트 하려면 새로운 요소를 만들어서 <code>ReactDOM.render()</code>에 전달해야한다.</li>\n</ul>\n<blockquote>\n<p><strong>Note:</strong> <br/>\n실제로 대부분의 React 어플리케이션은 ReactDOM.render() 를 한번만 호출한다. -&gt; state를 이용한다.</p>\n</blockquote>\n<h1>순수 함수란?</h1>\n<p>순수 함수는 입력을 변경하지않으며 항상 동일한 입력에 대해 동일한 결과를 반환하는 함수다.</p>\n<p><strong>순수 함수</strong></p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> a + b;\n}\n</code></pre>\n<p><strong>순수 함수가 아님</strong></p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">withdraw</span>(<span class=\"hljs-params\">account, amount</span>) </span>{\n  account.total -= amount;\n}\n</code></pre>\n<h1>Props</h1>\n<ul>\n<li>부모 컴포넌트에서 자식 컴포넌트로 전달된 데이터다.</li>\n<li>Props는 읽기전용이므로 수정할 수 없다.</li>\n<li>모든 React 컴포넌트는 props와 관련한 동작을 할 때 <code>순수 함수</code>처럼 동작해야한다.</li>\n</ul>\n<h1>State</h1>\n<h2>1. 클래스 컴포넌트에서 state 사용하기</h2>\n<pre><code class=\"language-javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Clock</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(props) {\n    <span class=\"hljs-keyword\">super</span>(props);\n    <span class=\"hljs-keyword\">this</span>.state = {<span class=\"hljs-attr\">date</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()};\n  }\n\n  <span class=\"hljs-comment\">// mounting : Clock 이 DOM에 최초로 렌더링 될 때</span>\n  componentDidMount() {\n\n  }\n\n  <span class=\"hljs-comment\">// unmounting : DOM에서 Clock 을 삭제했을 때</span>\n  componentWillUnmount() {\n\n  }\n  render() {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, world!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>It is {this.state.date.toLocaleTimeString()}.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  }\n}\n\nReactDOM.render(\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Clock</span> /&gt;</span>,\n  document.getElementById('root')\n);\n</span></code></pre>\n<h2>2. 함수형 컴포넌트에서 state 사용하기</h2>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> React, { useEffect, useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-comment\">// ...</span>\n\n<span class=\"hljs-keyword\">const</span> PetSitterApplyContainer = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> [current, setCurrent] = useState(<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// 인자는 초기값</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n\n  <span class=\"hljs-comment\">// 라이프사이클 훅</span>\n  useEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handleResize</span>(<span class=\"hljs-params\"></span>) </span>{\n      dispatch(resize(<span class=\"hljs-built_in\">window</span>.innerWidth, <span class=\"hljs-built_in\">window</span>.innerHeight))\n    }\n    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'resize'</span>, handleResize)\n  });\n\n  <span class=\"hljs-keyword\">const</span> next = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    setCurrent(current + <span class=\"hljs-number\">1</span>)\n  }\n\n  <span class=\"hljs-keyword\">const</span> prev = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    setCurrent(current - <span class=\"hljs-number\">1</span>)\n  }\n  \n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">PetSitterApply</span> \n      <span class=\"hljs-attr\">current</span>=<span class=\"hljs-string\">{current}</span> /&gt;</span>\n  )\n}\n</span></code></pre>\n<ul>\n<li>state는 React 컴포넌트가 유저 액션, 네트워크 응답, 기타 등등에 대한 응답으로 시간 경과에 따라 출력을 변경할 수 있게 한다.</li>\n<li>State는 로컬이며 캡슐화되어있다 : 부모 컴포넌트나 자식 컴포넌트는 특정 컴포넌트의 state 유무를 알 수 없으며 해당 컴포넌트가 함수나 클래스로 선언되었는 지 알 수 없기 때문</li>\n<li><code>componentDidMount() 훅</code> : 컴포넌트 출력이 DOM에 렌더링 된 이후 동작한다.</li>\n<li><code>componentWillUnmount() 훅</code> : 컴포넌트가 DOM에서 삭제된 이후 동작한다.</li>\n<li><code>useEffect</code> : 리액트 컴포넌트가 렌더링 될 때마다 특정 작업을 수행하도록 설정 할 수 있는 Hook으로 클래스형 컴포넌트의 componentDidMount 와 componentDidUpdate 를 합친 형태다.</li>\n</ul>\n<h2>3. State 바르게 사용하기</h2>\n<ul>\n<li>State를 직접 수정하지말기</li>\n</ul>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// Wrong</span>\n<span class=\"hljs-keyword\">this</span>.state.comment = <span class=\"hljs-string\">'Hello'</span>;\n\n<span class=\"hljs-comment\">// Correct</span>\n<span class=\"hljs-keyword\">this</span>.setState({<span class=\"hljs-attr\">comment</span>: <span class=\"hljs-string\">'Hello'</span>});\n</code></pre>\n<ul>\n<li>this.props 및 this.state가 비동기로 업데이트될 수 있다는 것을 고려하기</li>\n</ul>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// Wrong</span>\n<span class=\"hljs-keyword\">this</span>.setState({\n  <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-keyword\">this</span>.state.counter + <span class=\"hljs-keyword\">this</span>.props.increment,\n});\n\n<span class=\"hljs-comment\">// Correct : 이전 state를 인수로 받음</span>\n<span class=\"hljs-keyword\">this</span>.setState(<span class=\"hljs-function\">(<span class=\"hljs-params\">prevState, props</span>) =&gt;</span> ({\n  <span class=\"hljs-attr\">counter</span>: prevState.counter + props.increment\n}));\n</code></pre>\n<h1>하향식(top-down) 혹은 단방향(unidirectional) 데이터 흐름</h1>\n<ul>\n<li>모든 state는 항상 특정 컴포넌트가 가지며, 해당 state에서 파생된 모든 데이터 또는 UI는 트리의 컴포넌트 <code>아래(below)</code>에만 영향을 미친다.</li>\n<li>컴포넌트는 자신의 state를 자식 컴포넌트에 props 로 내려줄 수 있다. =&gt; <code>컴포넌트 트리 == props의 폭포</code></li>\n</ul>\n<h1>Refs</h1>\n<p>일반적인 리액트 데이터 플로우에서 부모 컴포넌트와 자식 컴포넌트는 <code>props</code>를 통해서만 통신할 수 있어서 자식 컴포넌트를 수정하려면 새로운 <code>props</code>와 함께 다시 렌더링해야한다. 그럼 일반적인 데이터 플로우 밖에서 자식 컴포넌트(컴포넌트 인스턴스 or DOM)에 직접 접근하려면 어떻게 해야할까? <code>Refs</code>를 사용하면 되지만 공식문서에서는 Refs 보다는 state를 이용하기로 권장한다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomTextInput</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(props) {\n    <span class=\"hljs-keyword\">super</span>(props);\n    <span class=\"hljs-keyword\">this</span>.focusTextInput = <span class=\"hljs-keyword\">this</span>.focusTextInput.bind(<span class=\"hljs-keyword\">this</span>);\n  }\n\n  focusTextInput() {\n    <span class=\"hljs-comment\">// Explicitly focus the text input using the raw DOM API</span>\n    <span class=\"hljs-keyword\">this</span>.textInput.focus();\n  }\n\n  render() {\n    <span class=\"hljs-comment\">// Use the `ref` callback to store a reference to the text input DOM</span>\n    <span class=\"hljs-comment\">// element in an instance field (for example, this.textInput).</span>\n    <span class=\"hljs-keyword\">return</span> (\n      &lt;div&gt;\n        &lt;input\n          type=\"text\"\n          ref={(input) =&gt; { this.textInput = input; }} /&gt;\n        &lt;input\n          type=\"button\"\n          value=\"Focus the text input\"\n          onClick={this.focusTextInput}\n        /&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n</code></pre>\n<ul>\n<li>React는 컴포넌트가 마운트될 때 DOM 요소와 함께 ref 콜백을 호출하며 언마운트될 때 null 과 함께 호출한다. ref 콜백은 componentDidMount 나 componentDidUpdate 라이프사이클 훅 전에 호출된다.</li>\n<li>ref 속성을 HTML 요소에서 사용하면, ref 콜백은 기본 DOM 요소를 인수로 받는다.</li>\n</ul>\n<blockquote>\n<p>Refs는 언제 사용하면 좋을까?</p>\n<ul>\n<li>input/textarea 포커스 제어, 텍스트 선택, 미디어 재생을 관리할 때</li>\n<li>명령형 애니메이션을 발동시킬 때</li>\n<li>써드 파티 DOM 라이브러리를 통합할 때</li>\n</ul>\n</blockquote>\n",
		"updatedAt": "2020-01-14T10:46:33.487Z",
		"id": "basic-react",
		"filename": "react\\basic-react.json"
	},
	{
		"title": "합성으로 컴포넌트에 다른 컴포넌트를 담아보자.",
		"date": "2020-01-13T00:00:00.000Z",
		"tags": [
			"Composition"
		],
		"categories": [
			"react"
		],
		"body": "<p>Modals을 만들면서 로그인 모달, 메모 모달 등 기능에 따라 모달 바디에 다른 UI를 보여주고 싶었다. 엘리먼트도 컴포넌트에 전달할 수 있을 까? 라는 의문으로 검색해보니 <strong>Composition</strong>이 나왔다.</p>\n<h1>컴포넌트에 다른 컴포넌트를 담고 싶다면?</h1>\n<h2>예시 1</h2>\n<p><code>props.children</code>을 사용하여 자식 엘리먼트를 그대로 출력할 수 있다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">import</span> Login <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./login\"</span> <span class=\"hljs-comment\">// 로그인 UI 컴포넌트</span>\n<span class=\"hljs-keyword\">import</span> ModalCard <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./modalCard\"</span> <span class=\"hljs-comment\">// 모달 컴포넌트</span>\n\n<span class=\"hljs-keyword\">const</span> Bio = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ModalCard</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Login</span> /&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ModalCard</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/&gt;</span>\n  )\n}\n</span></code></pre>\n<p>ModalCard JSX 태그 안에 있는 것들이 아래와 같이 ModalCard 컴포넌트의 children prop으로 전달됩니다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">const</span> ModalCard = <span class=\"hljs-function\">(<span class=\"hljs-params\">props</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"modal is-active\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"modal-background\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"modal-card\"</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">header</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"modal-card-head\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"modal-card-title\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"delete\"</span> <span class=\"hljs-attr\">aria-label</span>=<span class=\"hljs-string\">\"close\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">header</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">section</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"modal-card-body\"</span>&gt;</span>\n            {props.children}\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">section</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/&gt;</span>\n  )\n}\n// ...\n</span></code></pre>\n<h2>예시 2</h2>\n<p>React에서 prop으로 전달할 수 있는 것에는 제한이 없기 때문에 이렇게도 된다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">import</span> ModalCard <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./modalCard\"</span>\n<span class=\"hljs-keyword\">import</span> Login <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./login\"</span>\n\n<span class=\"hljs-keyword\">const</span> Bio = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">return</span> (\n    &lt;&gt;\n      {// ...}\n      &lt;ModalCard headTitle={`Who are you?`} ContentComponent={Login} isActive={isActive}/&gt;    \n    &lt;/&gt;\n  )\n}\n</code></pre>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">const</span> ModalCard = ({ \n  headTitle,\n  ContentComponent,\n  isActive,\n }) =&gt; {\n  \n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"modal\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"modal-background\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"modal-card\"</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">header</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"modal-card-head\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"modal-card-title\"</span>&gt;</span>{headTitle}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"delete\"</span> <span class=\"hljs-attr\">aria-label</span>=<span class=\"hljs-string\">\"close\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">header</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">section</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"modal-card-body\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ContentComponent</span> /&gt;</span>\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">section</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/&gt;</span>\n  )\n}\n</span></code></pre>\n<p>끝!</p>\n",
		"updatedAt": "2020-01-14T09:29:45.305Z",
		"id": "composition",
		"filename": "react\\composition.json"
	}
]